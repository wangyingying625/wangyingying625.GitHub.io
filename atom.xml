<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-14T13:32:01.408Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[格和布尔代数]]></title>
        <id>https://wangyingying625.github.io/post/ge-he-bu-er-dai-shu/</id>
        <link href="https://wangyingying625.github.io/post/ge-he-bu-er-dai-shu/">
        </link>
        <updated>2021-03-14T10:58:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="格">格</h2>
<p>为了说明格的概念和性质需要有偏序关系的准备知识</p>
<ol>
<li>什么是关系呢?<br>
关系(2元关系):元素全是有序对的集合<br>
如:R1={&lt;1,2&gt;,&lt;2,3&gt;}就是一个二元关系;<br>
R2={&lt;1,2&gt;,3,4}不是二元关系,其中3,4不是有序对<br>
(我会理解为关系是一种把一个元素变为另一个元素的方法,就像R1就是把1变成2,2变成3 的方法)</li>
</ol>
<p>总结一下就是首先关系是一个集合,集合中放的是有序对,即&lt;a,b&gt;与&lt;b,a&gt;代表的含义不同</p>
<ol start="2">
<li>那么,什么又叫偏序关系呢?<br>
这就得先说一说关系的一些性质了.关系是有序对的集合,它可能有一些什么性质来让我们更愿意使用它呢?<br>
自反:设R是A上的一个二元关系,说R是自反的当且仅当任取x在集合A里那么&lt;x,x&gt;就是关系R的一个元素.集合中的每个元素自己都和自己有关系(全部x都得满足)<br>
也就是说通过关系R能让元素集合A里面的所有元素都能保持自己</li>
</ol>
<p>反自反:任何x,自己和自己都没有关系(所有X都不能和自己有关系R)</p>
<p>对称:任选x和y,如果&lt;x,y&gt;有关系R那么&lt;y,x&gt;也有关系R(相等关系)<br>
也就是说一旦通过关系R,x能变成y,那么关系R也一定有办法把y变成x</p>
<p>反对称:任何两个点之间只有一条有向边</p>
<p>传递:当X和Y有关系,并且Y和Z有关系时,X和Z有关系(R和R的合成是R的子集)<br>
也就是说通过关系R如果x能变成y ,y 又能变成z的话.R就一定能把x直接变成z</p>
<p>那么这些乏味的概念和偏序关系究竟有什么关系呢?</p>
<p>In fact,偏序关系就是一种关系呀,就可以当做是把一个元素变成另一个元素的一种办法,但是它的变换是有要求的,它要求这个关系满足 自反性,反对称性和传递性,一般记作≼,被举的最多的例子就整数集上的大于和小于关系.<br>
为了让偏序关系被表示的更加明显和更方便使用,用哈斯图来表示它,比如集合{1,2,4}上的偏序关系就可以用下面的哈斯图来表示<br>
<img src="https://wangyingying625.github.io/post-images/1615721390271.png" alt="" loading="lazy"></p>
<p>偏序的概念可以联系到权限:假设ABC三人权限由高到低分别为超级管理员,管理员和普通用户,首先自反性保证了自己的信息自己能看到,反对称性表示B能看到C的信息,但是C看不到B的.传递性表明A能看到B的,B又能看到C的那么A一定能看到C的啊</p>
<p>有了这些就可以看格了!</p>
<p>首先是概念:<br>
格有两种等价概念:</p>
<ol>
<li>假设&lt;L,≼&gt;是一个偏序集,对于集合L中的任何两个元素都有最大下界和最小上界,那么&lt;L,≼&gt;就是格<br>
还用上面的ABC来举例,也就是说A和B总能找到一个人(A),那个人是能看到AB信息的人里权限最小的,也存在一个人那个人是能被A和B都看的人里权限最大的(C)</li>
</ol>
<p>那么是不是所有的偏序集都有这样的性质呢,并不是!<br>
<img src="https://wangyingying625.github.io/post-images/1615723952406.jpg" alt="" loading="lazy"><br>
这个显然不是格,因为部门A管理员和部门B管理员没有最小上界<br>
<img src="https://wangyingying625.github.io/post-images/1615723964097.jpg" alt="" loading="lazy"><br>
那么这个呢?这个也不是,因为A管理员和B管理员没有最大下界即A,B小组长无法区分大小</p>
<ol start="2">
<li>
<p>设&lt;L,∧,∨&gt;是具有两个二元运算的代数系统,如果∧对∨满足交换结合和吸收律,则称&lt;L,∧,∨&gt;是格</p>
<p>这是什么意思呢?<br>
如果偏序关系中有a≤b,那么就意味着a∨b=b<br>
也意味着a∧b=a<br>
这就说明偏序关系是可以用∨∧这两个运算来等价表示的</p>
<p>那么既然偏序关系要求具备自反,反对称,传递等关系的性质,当然也要要求这两个二元运算满足一些二元运算的要求.即交换,结合,和吸收律<br>
交换:x∧y=y∧x<br>
结合:(x∧y)∧z=x∧(y∧z)<br>
吸收:x∧(y∨x)=x</p>
</li>
</ol>
<p>那么有这些要求的格有什么性质呢:<br>
对偶命题:<br>
若果把格中的≤换成≥,同时把∨和∧互换,格中成立的一切命题换后也成立</p>
<p>和群类似,格中也有一些元素,它们自己就能满足格的概念.于是这些元素构成的集合和偏序关系就构成了子格</p>
<p>此外还有一些格具有更加特殊和良好的性质:<br>
<img src="https://wangyingying625.github.io/post-images/1615727173636.png" alt="" loading="lazy"></p>
<ol>
<li>完全格:格的每个非空子集都有最大下界和最小上界---如下图<br>
<img src="https://wangyingying625.github.io/post-images/1615726747189.png" alt="" loading="lazy"></li>
<li>分配格:设&lt;L,∧,∨&gt;是格,若对L中任取a,b,c都满足<br>
a∧(b∨c)=(a∧b)∨(a∧c)<br>
a∨(b∧c)=(a∨b)∧(a∨c)<br>
<img src="https://wangyingying625.github.io/post-images/1615727076862.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615727218456.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615727266934.png" alt="" loading="lazy"><br>
没错,我偷懒了🤔</li>
<li>有界格:设&lt;L,∧,∨&gt;是格,存在一个元素a∈L,使得a≤L中所有元素,那么称a是全下界;同时也存在一个元素b∈L,使得使得b≥L中所有元素,那么称b是全上界. 一般把全上界记为1,全下界记为0,有界格也写成&lt;L, ≤, 0, 1&gt;<br>
<img src="https://wangyingying625.github.io/post-images/1615727566609.png" alt="" loading="lazy"></li>
<li>有补格:有补格的定义涉及到补元,首先摆出补元的概念:<br>
补元：有界格&lt;L, ≤, 0, 1&gt;中, 对任意元素a∈L, 若存在b∈L, 并且a∧b = 0, a∨b = 1, 则称b是a的补元，补元不一定唯一。<br>
有补格：每一个元素都有补元，则称为有补格。<br>
有界分配格的补元唯一<br>
有界格中全上界与全下界互补</li>
<li>布尔格:如果一个格是有补分配格，就称为布尔代数<br>
<img src="https://wangyingying625.github.io/post-images/1615727947869.png" alt="" loading="lazy"></li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615728235216.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[群的理解]]></title>
        <id>https://wangyingying625.github.io/post/qun-de-li-jie/</id>
        <link href="https://wangyingying625.github.io/post/qun-de-li-jie/">
        </link>
        <updated>2021-03-14T09:26:42.000Z</updated>
        <content type="html"><![CDATA[<p>今天也是被离散数学折磨的一天<br>
学到了代数系统里的群,据说这是最简答的一种代数系统,不愿意接受自己连最简单的都学不明白的事实于是看了一堆相关的视频和文章,结论如下:</p>
<p>首先,群是一种代数系统,是代数系统就要求它有一些元素,还要求元素之间能进行某种运算.群的运算必须是二元运算,也就是说进行这种运算的只能是两个元素.</p>
<p>那么随便什么运算只要是两个元素之间进行的就可以吗?当然也不是.群对这个二元运算有更高的要求<br>
它要求这个二元运算是封闭的,可结合的,有单位元每个元素都有逆元.</p>
<p>首先封闭要求,群里任意两个元素之间都能进行这种运算,并且运算的结果仍然是群里的元素,不能跑出去</p>
<p>可结合指的是,假设进行运算的是元素a<em>b</em>c那么无论我先进行a<em>b还是b</em>c都不影响运算的结果</p>
<p>有单位元指的是群的元素里面存在那么一个元素,它在群的运算中不起作用,不管和谁运算,结果都是人家</p>
<p>有逆元指的是群中任何一个元素都能在群里找到另外一个元素,他们俩进行运算的结果是单位元.</p>
<p>只有满足以上四个公理的运算和集合才能叫做群.<br>
然而一个群中的元素们也有小团体，关系好的一些元素组成了一个子群，这个团体内也满足群的一切性质，只不过是组成元素是大群的一部分。</p>
<p>在此基础上阿贝尔群指的是,小猫和小狗聊天的结果与小狗和小猫聊天的结果一样最终都聊到了小鸭</p>
<p>循环群指的是,小猫和小猫聊天聊着聊着聊出来小狗,小狗和小猫聊天聊着聊着聊出来小猪...直到把集合里所有元素都聊出来,又聊回去小猫自己.也就是说小猫自己经过聊天这个运算聊出来了集合里的全部小动物们</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tell me about yourself]]></title>
        <id>https://wangyingying625.github.io/post/tell-me-about-yourself/</id>
        <link href="https://wangyingying625.github.io/post/tell-me-about-yourself/">
        </link>
        <updated>2021-03-13T13:51:34.000Z</updated>
        <content type="html"><![CDATA[<p>When you are applying for a position in a company especially English ability in reading and writing is important in the position,or when you are prepareing for the second examination about postgraduate entrance just like me, it is indispensable to introduce yourself in English.<br>
Then I will write about my introduction and my thought about writing it.<br>
(It is my first English blog,Although try my best to check it,errors and defects are inevitable,just forgive me.)</p>
<p>In the first place,post my introduction.It can also help you to know me by reading it.</p>
<blockquote></blockquote>
<p>Good afternoon,teachers.Thank you for the precious opporitunity.<br>
I will introduce myself from the following three aspects.The first is my basic information,the second is my undergraduate study,and the third is my work experience.</p>
<p>First,My name is mldwyy,twenty-three years old.I was born and raised in LL,a city of XX province.It's well-know for it's food,such as xxx and ooo.As for my character,I am a introverted person.And sometimes I notice that I am shy to share my ideas when there is a room of people.And it is something that I know I need to work on.In fact,recently I having been watching a few TED videos.And through the videos I have picked up a lot tools.Now they are helping me a lot.And teacher is a job that always need to share their ideas to students.I am always open to any coaching.And in my spare time,I like  playing with my cat.Her name is TaoTao.She is adopted and we adopted her with this name.</p>
<p>Second, I graduated from the xxx departmen of xx University in July,two thousand twenty.I have been study hard during my school time and my grade is excellent and I have gained scholarship several times.During my college, I enter the competitive too.</p>
<p>Third,I have worked in a Internet company as a front end engineer for nearly four months.My daily job was reading technical document and useing it to writing website programmes.So it is my strength that read and summarize a document just in a short time. And it was during that time that I decided to choose network security as my future major.I find it's necessary to help Interent enterprise improve the safety of their products.And that's I am passionate about.To learn more about it ,I ask for my friend in that major about a workable study plan and learned the basics of common vulnerabilities. I wish to devote my life and energy into the development of it.</p>
<p>That's all,Thanks for your listening.</p>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言]]></title>
        <id>https://wangyingying625.github.io/post/c-yu-yan/</id>
        <link href="https://wangyingying625.github.io/post/c-yu-yan/">
        </link>
        <updated>2021-03-12T09:25:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="unsigned与signed的转换">unsigned与signed的转换</h3>
<p>负数用补码表示,signed转化为unsigned时候不对数据做任何转换,只改变对数据的解释方式(即把以补码表示的负数直接输出)</p>
<pre><code class="language-c"> unsigned short a = -1;
    short b = a;
    ```
    输出b:-1,a:65535

### scanf结束之后会有一个'\n',如果scanf之后跟着getchar将会认为scanf结束时候的'\n'是getchar的输入
需要多加一个getchar()屏蔽\n的影响</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见算法]]></title>
        <id>https://wangyingying625.github.io/post/chang-jian-suan-fa/</id>
        <link href="https://wangyingying625.github.io/post/chang-jian-suan-fa/">
        </link>
        <updated>2021-03-12T08:27:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="把一个数组根据下标是奇数还是偶数分割成两个数组">把一个数组根据下标是奇数还是偶数分割成两个数组</h3>
<p>假设要分割的数组a=[1,2,3,4,5,6,7,8,9]</p>
<ol>
<li>定义一个变量i用来遍历数组a;</li>
<li>定义一个变量j用来标识数组b中下一个元素要存储的位置;</li>
<li>定义一个变量k用来标识数组c中下一个元素要存储的位置<br>
当(i%2)==0把a[i]中的值存入数组b[j++]<br>
否则把a[i]中的值存入数组c[k++]</li>
</ol>
<h3 id="删除字符串中的所有空格并且输出删除后的字符串以及被删除的空格数">删除字符串中的所有空格并且输出删除后的字符串以及被删除的空格数</h3>
<p>假设被操作的字符串是s=['h','e','l','l','o',' ','w','o','r','d']</p>
<ol>
<li>定义一个变量i用来遍历字符串s</li>
<li>定义一个变量j用来标识删除过后的字符串下个元素要存入的位置</li>
<li>遍历字符串s,如果当前字符是' ',则指针i后移;若当前字符不是' '则把当前字符存入s[j]的位置,并且j++</li>
<li>被删除的空格数就是i-j</li>
</ol>
<h3 id="排序算法">排序算法</h3>
<h4 id="选择">选择</h4>
<ol>
<li>简单选择:<br>
每一轮从未排好序的序列里选择一个最小的,与最前面未排序的元素交换<br>
直到排好</li>
<li>堆排序</li>
</ol>
<h4 id="交换">交换</h4>
<ol>
<li>冒泡<br>
从数组头开始两两比较,若前面的比后面的大就交换,第一轮比较结束时最大的元素被移动到最后<br>
从数组头开始再次两两比较,比较到倒数第二个时候截止<br>
...重复直到比较完或者一轮都没有交换</li>
<li>快排<br>
选取数列的第一个元素作为基准<br>
从第二个元素开始与基准比较,若比基准小就放到当前基准在数组中的地方,并把基准在数组中的指针向后移1</li>
</ol>
<h4 id="插入">插入</h4>
<ol>
<li>简单插入<br>
默认第一个元素排好序,从第二个元素开始,和前面的元素比较,若比前面的元素小就交换,直到比前面的大,开始下一轮比较直到全部排好</li>
<li>希尔排序<br>
把表按照某一特定增量k分割<br>
同一增量下的元素进行简单插入排序<br>
增量变为k/2,重复上述过程</li>
</ol>
<h4 id="归并">归并</h4>
<ol>
<li>二路归并排序<br>
把数组分为n/2个等长的子数组<br>
每个子数组里进行二路归并排序<br>
将排好序的相邻两个子数组再进行二路归并排序,知道最后只剩下两个n/2的数组</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代数系统]]></title>
        <id>https://wangyingying625.github.io/post/dai-shu-xi-tong/</id>
        <link href="https://wangyingying625.github.io/post/dai-shu-xi-tong/">
        </link>
        <updated>2021-03-11T02:23:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="代数结构">代数结构</h2>
<p>结构=集合+对应规则+公理</p>
<h3 id="代数系统基本概念">代数系统基本概念</h3>
<h4 id="代数系统的构成">代数系统的构成:</h4>
<ol>
<li>成分:载体(集合)和运算</li>
<li>公理:运算性质(交换结合分配零元单位元等)</li>
</ol>
<h5 id="n元运算">n元运算</h5>
<h6 id="定义">定义:</h6>
<ol>
<li>设A是集合,函数f:AXA-&gt;A称为A上的二元运算,也可以写为f(&lt;a1,a2&gt;)=a3</li>
<li>AXA意味着该二元运算的定义域是A即两次从A中任选元素都能进行运算(两次可选同意元素),如果随便取两次取出的a不能进行f这种运算,那么f就不是二元运算.(除法不是实数集合上的二元运算,当除数取0时候不能运算)</li>
<li>值域也是A,即运算对集合是封闭的</li>
</ol>
<h6 id="写法">写法:</h6>
<p>n元运算的写法:<br>
o(x1,x2,x3,x4,x5...)=y</p>
<h6 id="表示">表示:</h6>
<ol>
<li>表达式:xoy=x+y*2</li>
<li>运算表,左边第一列和上边第一行列出参与运算的表达式,中间写入运算的结果</li>
</ol>
<h6 id="二元运算律">二元运算律:</h6>
<p>只涉及一个二元运算的:</p>
<ol>
<li>交换:aob=boa</li>
<li>结合:(aob)oc=ao(boc)</li>
<li>幂等:aoa=a</li>
<li>消去:aob=aoc∧a≠𝛉=&gt;b=c(a不是零元)<br>
涉及两个运算的</li>
<li>分配:ao(b<em>c)=(aob)</em>(aoc),(b<em>c)oa=(boa)</em>(coa)</li>
<li>吸收:ao(a<em>b)=a,a</em>(aob)=a</li>
</ol>
<h6 id="特异元素的定义与性质">特异元素的定义与性质</h6>
<ol>
<li>单位元e:eoa=aoe=a(对系统中所有元素都满足,一系统最多一个)运算中不起作用</li>
<li>零元𝛉:𝛉oa=ao𝛉=𝛉(对系统中所有元素)</li>
<li>幂等元a:aoa=a</li>
<li>可逆元x:xoy=yox=e</li>
</ol>
<p>单位元和零元存在必唯一<br>
可结合的运算逆元必定唯一</p>
<h6 id="判断某一给定运算是否满足某些二元运算律是否有特异元素">判断某一给定运算是否满足某些二元运算律,是否有特异元素</h6>
<ol>
<li>表达式法</li>
<li>表格法</li>
</ol>
<h4 id="构成代数系统的方法">构成代数系统的方法</h4>
<ol>
<li>从原有代数系统抽一子集出来</li>
<li>由不同的代数系统做笛卡尔积(把两个不同的代数系统组合成新的代数系统)</li>
<li>抽象</li>
</ol>
<h3 id="代数系统">代数系统</h3>
<h4 id="概念">概念</h4>
<ol>
<li>
<p>成分:V=&lt;A,o,*...&gt;<br>
其中:A是载体,非空<br>
后面都是对集合A的各种运算</p>
</li>
<li>
<p>分类:<br>
同类型的:构成成分相同(如都有两个二元运算的&lt;Z,+,-&gt;和&lt;S,*,/&gt;)<br>
同种的:构成成分和公理都相同</p>
<p>构成成分:运算个数,对应运算的元数<br>
公理:交换,结合,幂等,吸收,分配,小区率,单位元...</p>
</li>
</ol>
<h4 id="由一个代数系统产生更多代数系统的方法">由一个代数系统产生更多代数系统的方法</h4>
<h5 id="子代数">子代数:</h5>
<p>代数系统里是否存在一子集,子集能良好的保持代数系统的性质:</p>
<ol>
<li>定义:设V=&lt;A,o1,o2,o3,...&gt;是代数系统,B是A的非空子集.若B对于V中的所有运算封闭,则称&lt;B,o1,o1...&gt;是V的子代数,若B真包含与A则称其是V的真子代数</li>
<li>当集合A里只有一个元素时是平凡的子代数</li>
</ol>
<h5 id="积代数">积代数:</h5>
<p>一. 定义:设V1=&lt;A,o,o1,o2...&gt;与V2=&lt;B,*,*1,<em>2...&gt;是同类型的代数系统,对于i=1,2,3...,两个代数系统中oi与</em>i对应的元数一样,则V1xV2=&lt;AxB,<sub>,</sub>1,~2,...&gt;<br>
其中:AxB是集合A与B的笛卡尔积<br>
本来的代数系统集合A是元素为数字或者字符或者矩阵的集合,生成的积代数的元素A'是序偶对的集合<br>
<img src="https://wangyingying625.github.io/post-images/1615445753647.jpg" alt="" loading="lazy"><br>
二. 性质:</p>
<ol>
<li>若第一个系统的第i个运算可交换,第二个系统的第i个运算也可交换,则生成的积代数的运算oi也是可交换的(可结合和幂等也有一样的性质)</li>
<li>若原来的因子运算oi,oj可分配且*i,*j可分配,那么新生成的<sub>i,</sub>j也可分配(吸收率也有改性质)</li>
<li>两个系统中的针对相同位置的运算oi,*i的零元和单位元相应的组合也是新运算中的零元和单位元</li>
<li>两个系统中的针对相同位置含单位元的运算oi,*i的逆元相应的组合也是新运算中的逆元</li>
</ol>
<h4 id="同构和同态代数系统之间的关系">同构和同态(代数系统之间的关系):</h4>
<p>把一个代数系统同函数映射到另外一个代数系统<br>
两个系统如果同构就没有区别,不过是赋予了不同的含义</p>
<h5 id="同态可以把一些有相同性质的代数系统联系起来">同态:(可以把一些有相同性质的代数系统联系起来)</h5>
<p>V1=&lt;A,o,o1,o2...&gt;,V2=&lt;B,*,*1,*2...&gt;是同类型的代数系统,假设oi是r元的,*i也是r元的,若满足:<br>
f(oi(a1,a2,a3...))=*i(f(a1),f(a2),f(a3)...),其中a1,a2,a3都是A中的元素<br>
即先运算再映射的值与先映射再运算的值相等<br>
<img src="https://wangyingying625.github.io/post-images/1615449353651.jpg" alt="" loading="lazy"></p>
<h5 id="同构">同构:</h5>
<p>同态按照映射类型可分为:<br>
单同态<br>
满同态<br>
同构<br>
<img src="https://wangyingying625.github.io/post-images/1615451578931.jpg" alt="" loading="lazy"></p>
<h4 id="同余关系和商代数">同余关系和商代数</h4>
<p>同余关系是一个等价关系,通过这个关系可以把元素划分成等价类.两个元素彼此等价,则运算过程中替换后,运算结果还等价.由此可把类抽象,即认为同一个类中的元素是一个元素.<br>
<img src="https://wangyingying625.github.io/post-images/1615458497151.jpg" alt="" loading="lazy"></p>
<h4 id="把代数系统进行分类得到不同种类的代数系统">把代数系统进行分类,得到不同种类的代数系统</h4>
<ol>
<li>只有一个运算的半群和群</li>
<li>有两个运算的环域</li>
<li>还有两个运算的格和布尔代数</li>
</ol>
<hr>
<h3 id="半群和独异点只有一个二元运算">半群和独异点(只有一个二元运算)</h3>
<p>广群:只需具备封闭性--&gt;添加公理<br>
半群:可结合的--&gt;添加公理<br>
独异点:含单位元--&gt;每个元素都有逆<br>
群(群中无零元)</p>
<h4 id="独异点含幺半群">独异点(含幺半群)</h4>
<p>可通过对半群增加单位元并且定义与单位元相关的运算扩张而成</p>
<h3 id="群">群(*)</h3>
<h4 id="群的定义">群的定义</h4>
<ol>
<li>定义与实例(可认为是对集合中元素的一种映射变换,变换过后元素还是那些元素只不过位置发生了变化)<br>
要求群中有一个二元运算*,且<em>满足结合律,每个元素都有关于二元运算</em>的逆元<br>
&lt;I,*&gt;整数集合上的乘法:封闭,可结合,有单位元,2,3...整数无逆元,不是群<br>
&lt;R,+&gt;实数集合上的加法运算,封闭,可结合,有单位元0,每个元素都有逆元,是群<br>
&lt;P(S),∩&gt;幂集上的交运算,封闭,可结合,有单位元,无逆元</li>
<li>术语<br>
阶:&lt;G,<em>&gt;是群,G中元素的个数叫该群的阶|G|<br>
等幂元:&lt;G,</em>&gt;是代数系统,若存在a∈G,使a*a=a则a是等幂元<br>
平凡群:只含有单位元e<br>
交换群:阿贝尔群<br>
元素a的阶:使aⁿ=e的最小n,有的群中元素的阶不存在(有限)</li>
<li>性质:<br>
&lt;G,<em>&gt;是群,存在任意的a,b∈G,必定存在唯一的x使得a</em>x=b<br>
群中只有单位元是等幂元<br>
群中每一行每一列都是G的一个置换<br>
<img src="https://wangyingying625.github.io/post-images/1615711087117.jpg" alt="" loading="lazy"></li>
</ol>
<h5 id="子群">子群</h5>
<p>若G是群,H是G的非空子集,若H关于G中运算构成群,则称H为G的子群,记作H≤G;如果H是真子集,就是真子群<br>
判定定理:<br>
H非空 + H∈G + 运算再H中可结合 + 单位元在H内  + 每个元素都有逆 + 运算在H中封闭 =&gt;<br>
任意a,b∈H,ab逆∈H<br>
H是有限集属于G,且运算再H上封闭<br>
性质:<br>
子群的单位元是父群的单位元</p>
<h4 id="阿贝尔群">阿贝尔群</h4>
<p>群中运算<em>满足a</em>b=b*a</p>
<h3 id="循环群">循环群</h3>
<p>群可以由其中一个元素生成<br>
如整数加群可看作由整数1生成</p>
<ol>
<li>循环群的生成元<br>
若G是无限循环群,则G的生成怨是a 和a的逆</li>
</ol>
<h3 id="格">格</h3>
<p>假设&lt;L,≼&gt;是一个偏序集,对于集合L中的任何两个元素都有最大下界和最小上界,那么&lt;L,≼&gt;就是格</p>
<p>在联机分析处理中,为了加快查询进度,可以将数据按照维度进行聚集<br>
设&lt;L,<em>,o&gt;是具有两个二元运算的代数系统,如果这两个二元运算满足交换结合和吸收律,则称&lt;L,</em>,o&gt;是格<br>
<img src="https://wangyingying625.github.io/post-images/1615718887510.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615718869919.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615601255121.jpg" alt="" loading="lazy"></p>
<h4 id="格的性质">格的性质</h4>
<ol>
<li>对偶原理:若果把格中的≤换成≥对P中所有格成立的一切命题换后也成立</li>
<li>有自反性和传递性(一般无分配律)</li>
<li>交换结合幂等吸收</li>
<li>&lt;S,<em>,o&gt;是具有两个二元运算的代数系统,如果</em>,o运算满足交换结合和吸收律,那么<br>
<em>,o运算满足幂等律:a</em>a=a*(ao(a<em>a))=a<br>
a</em>b=a  &lt;=&gt;  aob=b<br>
a<em>b=a</em>(aob)=a(吸收律)<br>
aob=(a*b)ob=b</li>
<li>有两个二元运算的代数系统,如果*,o满足交换结合和吸收律,可以适当定义S上的偏序≼,使得&lt;S,≼&gt;构成格,且其导出的代数系统就是&lt;S,<em>,o&gt;(最小上界的结果是o运算,最大下界的结果是</em>运算)<br>
定义二元关系R,aRb&lt;=&gt;aob=b<br>
证明R是偏序</li>
</ol>
<h4 id="子格">子格</h4>
<p>L的非空子集,且S关于L中的两个运算封闭</p>
<h4 id="格的同态">格的同态</h4>
<p>设L1,L2是两个格,有一映射f:L1-.L2使得任意x,y属于L1时都有f(x∧y)=f(x)∧f(y)<br>
f(x∨y)=f(x)∨f(y),则称f是L1到L2的同态<br>
<em>同态的性质</em></p>
<ol>
<li>f是格L1到L2的同态,则任意a,b∈L1,a≼b=&gt;f(a)≼f(b)   保序性(反之不一定)</li>
<li>f是双射,f为L1到L2的同构,当且仅当a≼b &lt;=&gt; f(a)≼f(b)</li>
</ol>
<h4 id="完备格">完备格:</h4>
<p>任意子集(可无限)都有最大下界和最小上界∧S和∨S(有穷集合构成的格是完备的)</p>
<h4 id="特殊格">特殊格</h4>
<ol>
<li>模格</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散数学思维导图]]></title>
        <id>https://wangyingying625.github.io/post/chi-san-shu-xue-si-wei-dao-tu/</id>
        <link href="https://wangyingying625.github.io/post/chi-san-shu-xue-si-wei-dao-tu/">
        </link>
        <updated>2021-03-10T08:52:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数理逻辑">数理逻辑</h2>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615366403802.png" alt="" loading="lazy"></figure>
<h2 id="集合论">集合论</h2>
<figure data-type="image" tabindex="2"><img src="https://wangyingying625.github.io/post-images/1615429075509.png" alt="" loading="lazy"></figure>
<h2 id="代数系统">代数系统</h2>
<figure data-type="image" tabindex="3"><img src="https://wangyingying625.github.io/post-images/1615728716696.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[爱读书的大肥兔]]></title>
        <id>https://wangyingying625.github.io/post/ai-du-shu-de-da-fei-tu/</id>
        <link href="https://wangyingying625.github.io/post/ai-du-shu-de-da-fei-tu/">
        </link>
        <updated>2021-03-10T04:38:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="被人讨厌的勇气">被人讨厌的勇气</h3>
<ol>
<li>既没有自卑感也不必炫耀优越性,能够保持一种平静而自然的状态.真正的爱应该是这样的.</li>
<li>过于希望得到别人的认可,就会按照别人的期待去生活.也就是舍弃真正的自己,活在别人的人生中.</li>
<li>假如说你不是为了满足别人的期待而活,那么他人也不是为了满足你的期待而活,当别人的行为不符合自己的想法时也不可发怒.</li>
<li>想要取得别人的认可的时候,几乎所有人都会采取&quot;满足别人的期待&quot;这一手段,这其实都是受&quot;如果做了恰当的事情就能够得到表扬&quot;这种赏罚教育的影响.但是,若果工作的主要目标变成了&quot;满足别人的期待&quot;,那工作就会变得相当痛苦.因为那样就会一味的在意别人的实现,害怕别人的评价,根本无法做真正的自己.</li>
<li>基本上,一切人际关系矛盾都起因于对别人的课题王加干涉或者自己的课题被别人妄加干涉.</li>
<li>时尚的父母总是说&quot;为你着想&quot;之类的话,但是,父母的行为有时候很明显是为了满足自己的目的--面子和虚荣又或者是支配欲.正因为察觉到了这种欺骗行为,孩子才会反抗.</li>
<li>关于自己的人生你能够做的就只有&quot;选择自己认为最好的道路&quot;.另一方面,别人如何评价你的选择,那是别人的课题,你根本无法左右.</li>
<li>没有学会直面困难的孩子最终会想要逃避一切困难.<br>
<img src="https://wangyingying625.github.io/post-images/1615352619902.jpg" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合论]]></title>
        <id>https://wangyingying625.github.io/post/ji-he/</id>
        <link href="https://wangyingying625.github.io/post/ji-he/">
        </link>
        <updated>2021-03-09T05:52:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="集合论">集合论:</h2>
<p>用集合论作为描述工具<br>
集合中的元素要各不相同<br>
集合中的元素不规定顺序<br>
集合的两种表示法可以互相转换</p>
<h3 id="集合基本概念">集合基本概念</h3>
<h4 id="集合的表示">集合的表示:</h4>
<ol>
<li>列举法 A={1,2,3}</li>
<li>描述法</li>
</ol>
<h3 id="常用术语">常用术语:</h3>
<ol>
<li>子集⊆:若B是A的子集,要求B中元素都是A中元素,也叫B包含于A,A包含B.空集是一切集合的子集</li>
<li>相等:A包含B且B包含A</li>
<li>真子集⊂:A是B的子集且A不等于B,则A⊂于B</li>
<li>幂集:设A是一个集合,则由A的全体子集组成的集合是A的幂集,记为P(A)</li>
<li>集合的元素个数:|A|表示集合A中的元素个数<br>
若|A|=n,则|P(A)|=2ⁿ</li>
<li>定义域:dom R</li>
<li>值域:ran R</li>
<li>域:ran R U dom R</li>
</ol>
<h3 id="集合的运算">集合的运算:</h3>
<ol>
<li>并集∪:设A与B为两个集合,由A和B中所有元素组成的集合是A和B的并集AUB</li>
<li>交集∩</li>
<li>不相交:设A和B为两个集合,若A∩B=∅,则A与B不相交</li>
<li>相对补:A-B,属于集合A而不属于集合B的全体元素</li>
<li>绝对补:任意集合A对全集E的绝对补,记为~A</li>
<li>对称差⨁:属于A不属于B的和属于B但不属于A的全体元素组成的集合</li>
<li>文氏图:集合与集合之间的关系以及一些运算的结果可以用文氏图直观表示.其中矩阵表示全集,圆或者其他封闭的曲线可以表示E的子集,运算结果得到的集合用阴影表示.<br>
<img src="https://wangyingying625.github.io/post-images/1615262997178.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="基本的集合恒等式">基本的集合恒等式:</h3>
<p>设E是全集,A,B,C是E的任意子集:</p>
<ol>
<li>幂等律:A ∪ A=A ,  A∩A=A</li>
<li>交换律:AUB=BUA ,A ∩B=B∩A</li>
<li>结合律:(AUB)UC=AU(BUC) , (A∩B)∩C=A∩(B∩C)</li>
<li>分配律:AU(B∩C)=(AUB)∩(AUC) , A∩(BUC)=(A∩B)U(A∩C)</li>
<li>德摩根律:<sub>(AUB)=</sub> A∩~B , <sub>(A∩B)=</sub>AU~B</li>
<li>吸收率:AU(A∩B)=A , A∩（AUB）= A</li>
<li>零律:AUE=E , A∩∅=∅</li>
<li>同一律:AU∅=A , A∩E=A</li>
<li>排中律:AU~A=E</li>
<li>矛盾律:A∩~A=∅</li>
<li>余补律:~∅=E , ~E=∅</li>
<li>双重否定率:<sub>(</sub>A)=A</li>
<li>补交转换率:A-B=A∩~B<br>
优先级:绝对补 幂集 广义交 广义并,并 交 相对补 对称差<br>
集合等式的证明可以用命题演算证明<br>
<img src="https://wangyingying625.github.io/post-images/1615269104056.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="有序对">有序对:</h3>
<p>&lt;a,b&gt;={{a},{a,b}},其中a是第一元素,b是第二元素.<br>
&lt;a,b,c&gt;=&lt;&lt;a,b&gt;,c&gt;  有序三元组</p>
<h3 id="卡式积笛卡尔积">卡式积(笛卡尔积):</h3>
<p>A与B是两个集合,他们的卡式积是一个新的集合.集合中的元素都是有序对,有序对中第一元素都在A中,第二元素都在B中,所有这样的有序对构成卡式积.</p>
<h4 id="卡式积性质">卡式积性质:</h4>
<ol>
<li>非交换(除非A=B或者A=∅或者B=∅)Ax∅=∅</li>
<li>非结合:(AxB)xc≠Ax(Bxc)甚至(AxA)xA≠Ax(AxA)</li>
<li>分配律:Ax(B∪C)=(AxB)∪(AxC)</li>
<li>AxB=∅ &lt;=&gt; A=∅∪B=∅两非空集合卡式积一定非空</li>
<li>无零因子</li>
</ol>
<p>性质证明:<br>
设A,B,C是任意集合:证明若A≠∅,则AxB ⊆ AxC &lt;=&gt; B ⊆ C<br>
<img src="https://wangyingying625.github.io/post-images/1615272819895.jpg" alt="" loading="lazy"></p>
<h2 id="二元关系与关系数据库相关">二元关系(与关系数据库相关)</h2>
<p>元素都是有序n元素的集合叫n元关系<br>
F1={&lt;1,2,3&gt;,&lt;你,我,他&gt;}是一个三元关系</p>
<h3 id="基本概念">基本概念</h3>
<ol>
<li>
<p>关系(2元关系):元素全是有序对的集合<br>
F1={&lt;1,2&gt;,&lt;2,3&gt;}<br>
F2={&lt;1,2&gt;,3,4}不是二元关系,其中3,4不是有序对</p>
</li>
<li>
<p>A到B的二元关系:AxB的任意子集(A对B的笛卡尔乘积都是A到B的二元关系)<br>
若|A|=m,|B|=n,则|AxB|=mn,|P(AxB)|=2nm次方<br>
即A到B的不同二元关系有2nm次方个</p>
<p>例1:设A={a1,a2},B={b1}<br>
则A到B的二元关系有:<br>
R1=∅,R2={&lt;a1,b1&gt;},R3={<a2>,<b1>},R4={&lt;a1,b1&gt;,&lt;a2,b1&gt;}<br>
B到A的二元关系有:<br>
R1=∅,R2={&lt;b1,a1&gt;},R3={<b1>,<a2>},R4={&lt;b1,a1&gt;,&lt;b1,a2&gt;}</p>
</li>
<li>
<p>恒等关系:A中每个元素自己和自己有关系的那种关系</p>
</li>
</ol>
<h3 id="基本运算">基本运算:</h3>
<ol>
<li>逆</li>
<li>合成(复合函数)</li>
<li>限制⨡:关系F和集合A,关系F对A的限制就是一些关系的集合,这些关系满足第一元素来自于A</li>
<li>象F[{a}]:关系F在集合A上的象就是F中第一个元素在A里面的第二个元素的集合(类似于H(A))</li>
<li>单根:F是单根的意味着在关系F=&lt;x,y&gt;中,<strong>任意</strong>一个y都对应<strong>唯一</strong>的x</li>
<li>单值:F是单值的意味着F中<strong>任意</strong>一个x都唯一对应一个y</li>
<li>(FoG)的逆=G-1oF-1</li>
</ol>
<p><img src="https://wangyingying625.github.io/post-images/1615276477548.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615277275790.jpg" alt="" loading="lazy"></p>
<h3 id="表示和性质">表示和性质</h3>
<h4 id="表示">表示:</h4>
<ol>
<li>集合</li>
<li>关系矩阵</li>
<li>关系图</li>
</ol>
<h4 id="性质">性质:</h4>
<ol>
<li>自反:设R是A上的一个二元关系,说R是自反的当且仅当任取x在集合A里那么&lt;x,x&gt;就有关系R.集合中的每个元素自己都和自己有关系(全部x都得满足)[关系矩阵主对角线元素都是1,关系图每个顶点都有环]</li>
<li>反自反:任何x,自己和自己都没有关系(所有X都不能和自己有关系R)[要求每个点都没有环,主对角线全为0]</li>
<li>非自反:存在x属于A那么&lt;x,x&gt;必不属于关系R(只要有一个不属于就行)</li>
<li>对称:任选x和y,如果&lt;x,y&gt;有关系R那么&lt;y,x&gt;也有关系R(相等关系)[关系图中不同两点间必然是双箭头,矩阵中必然是对称矩阵]任何两个点间都没有边的关系既是对称的也是反对称的</li>
<li>反对称:任何两个点之间只有一条有向边</li>
<li>非对称:只有有一个&lt;x,y&gt;不对称[存在两个点间只有一条边]</li>
<li>传递:当X和Y有关系,并且Y和Z有关系时,X和Z有关系(R和R的合成是R的子集)</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615280969332.jpg" alt="" loading="lazy"></figure>
<h3 id="闭包">闭包:</h3>
<p>关系的幂:<br>
<img src="https://wangyingying625.github.io/post-images/1615283212083.jpg" alt="" loading="lazy"><br>
包含给定的元素并且具有给定性质的最小集合</p>
<ol>
<li>自反闭包:要求都包含关系R,结果的二元关系是自反的(原来的R可能不自反,加一些元素使其自反),并且是最小的,R的自反闭包用r(R)表示</li>
<li>对称闭包:...结果的二元关系是对称的...,R的对称闭包用s(R)表示(任意两个结点都是对称的)</li>
<li>传递闭包:...结果的二元关系是传递的...R的传递闭包用t(R)表示(任意两个结点都是传递的)<br>
r(R1UR2)=r(R1)Ur(R2)并起来并不会增加环的数量<br>
s(R1UR2)=s(R1)Us(R2)两点之间本来就都有两条边,并起来并不会增加双向边的数量<br>
t(R1UR2)⊇t(R1)Ut(R2)并了以后长度为2 的路径会更多</li>
</ol>
<h4 id="求法">求法:</h4>
<p>r(R)=RUIA(恒等关系);矩阵上就是把对角线元素都改为1;图上就是每个点都加环<br>
s(R)=RUR逆;矩阵上变为对称阵;原来无边的不用加,原来有一条半的加反向边<br>
t(R)=RUR²UR³U...<br>
<img src="https://wangyingying625.github.io/post-images/1615287920816.jpg" alt="" loading="lazy"><br>
sr(R)=rs(R) , tr(R)=rt(R) , st(R)不一定对称⊆ts(R)</p>
<h3 id="等价关系用来分类">等价关系(用来分类)</h3>
<p>设A≠∅,且R⊆AxA,若R是自反的对称的传递的,则R是等价关系</p>
<h4 id="性质-2">性质:</h4>
<p>设R是A≠∅上的等价关系,则⩝x,y∈A有</p>
<ol>
<li>[x]≠∅(必定有x自己)</li>
<li>xRy=&gt;[x]=<a href="x%E5%92%8Cy%E6%9C%89%E5%85%B3%E7%B3%BB,y%E4%B9%9F%E5%92%8Cx%E6%9C%89%E5%85%B3%E7%B3%BB,y%E8%BF%98%E5%92%8C%E5%AE%83%E6%89%80%E5%9C%A8%E7%AD%89%E4%BB%B7%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0%E6%9C%89%E5%85%B3%E7%B3%BB,%E9%82%A3x%E4%B9%9F%E5%92%8Cy%E7%9A%84%E7%AD%89%E4%BB%B7%E7%B1%BB%E6%9C%89%E5%85%B3%E7%B3%BB">y</a></li>
<li>¬ xRy=&gt;[x]∩[y]≠∅当两元素没关系时他们的等价类一定不相交</li>
<li>所有等价类并起来就是原集合A</li>
</ol>
<h3 id="商集分类结果">商集:分类结果</h3>
<h3 id="序关系用来在一个类里排序">序关系(用来在一个类里排序)</h3>
<h1 id="函数">函数</h1>
<h1 id="自然数">自然数</h1>
<h1 id="基数和序数">基数和序数</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散数学问题]]></title>
        <id>https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/</id>
        <link href="https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/">
        </link>
        <updated>2021-03-08T08:23:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="命题与陈述句有什么关系">命题与陈述句有什么关系?</h2>
<p>命题是具有确定真假值的陈述句,由于命题有确定的真假值,所以可以当做布尔变量看待它</p>
<h2 id="如何从真值表写出主析取合取范式">如何从真值表写出主析取(合取)范式?</h2>
<p>主析取范式是极小项析取组成的,只需根据真值表写出满足条件的极小项即可.那么如何去找满足条件的极小项呢,要想让主析取范式(与原式等价)取真要求任一极小项取真,那么把所有极小项赋值为真的指派并起来就是主析取范式<br>
主合取范式是有极大项组成的,要想让主合取范式(原式)取假只需任一极大项取假,假设p=0,q=1时原命题为假,那么其中一个极大项应该为(p∨¬q)<br>
若得出主析取范式也可用主析取范式直接求出主合取范式</p>
<h2 id="如何判断两个公式是否等价">如何判断两个公式是否等价</h2>
<ol>
<li>列两个公式的真值表,若各种指派下他们俩取值都相等就等价</li>
<li>用基本等价公式推导证明</li>
<li>求各自的主析取(合取)范式,若所有的两个范式一样那就等价</li>
</ol>
<h2 id="如何给集合下定义">如何给集合下定义</h2>
<p>具有某种特殊性质的客体的集合</p>
<h2 id="二元关系有哪些表示方法">二元关系有哪些表示方法</h2>
<ol>
<li>集合表示法</li>
<li>矩阵表示</li>
<li>图表示</li>
</ol>
<h2 id="如何用集合定义关系函数">如何用集合定义关系,函数</h2>
<p>关系是以序偶作为元素的集合<br>
函数是一种特定的关系,要求定义域中的每个x都能唯一确定y</p>
<h2 id="什么是商集什么是划分">什么是商集,什么是划分</h2>
<p>商集是等价关系下的划分</p>
<h2 id="如何构造从集合a到集合b的双射函数">如何构造从集合A到集合B的双射函数</h2>
<ol>
<li>若AB都是有穷集合,先列出AB在把AB中的元素进行对应</li>
<li>若AB是实数区间,则平滑连接点&lt;A最小,B最小&gt;到&lt;A最大,B最大&gt;</li>
<li>若AB都是无穷集合,则把AB分别列出来,从前往后一一对应</li>
</ol>
<h2 id="什么是图">什么是图</h2>
<h2 id="有哪些图">有哪些图</h2>
<h2 id="图有什么性质">图有什么性质</h2>
<h2 id="什么是欧拉图">什么是欧拉图</h2>
<h2 id="什么是哈密顿图">什么是哈密顿图</h2>
<h2 id="什么是树">什么是树</h2>
<h2 id="如何用矩阵表示图">如何用矩阵表示图</h2>
<h2 id="什么是平面图">什么是平面图</h2>
<h2 id="什么是图的着色">什么是图的着色</h2>
<h2 id="什么是带权图">什么是带权图</h2>
<h2 id="什么是支配集">什么是支配集</h2>
]]></content>
    </entry>
</feed>