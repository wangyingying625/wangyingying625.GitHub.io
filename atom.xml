<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-24T01:38:09.937Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <subtitle>这一天,到了你幻想的年纪,却没能成为你幻想的自己.</subtitle>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[数据模型与数据模式]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-mo-xing-yu-shu-ju-mo-shi/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-mo-xing-yu-shu-ju-mo-shi/">
        </link>
        <updated>2021-03-22T11:28:55.000Z</updated>
        <content type="html"><![CDATA[<p>发现自己好像把这两个概念混起来了,我得仔细区分一下</p>
<h2 id="数据模型">数据模型:</h2>
<p>用来描述数据的一组定义.<br>
一般对数据的描述包括三个部分:数据结构+数据操作+完整性约束</p>
<p>首先数据模型是实现DBMS的基础,同时它还是对现实世界中数据的抽象.那就要求它既与现实贴近又要容易实现.<br>
于是采用了分层的方法,针对不同的用户使用不同的数据模型:</p>
<ol>
<li>概念模型:面向用户,与DBMS无关</li>
<li>逻辑模型:用户从数据库看到的数据模型.与DBMS有关,DBMS常用它所使用的逻辑模型来分类(如关系型数据库),用概念模型抽象的数据必须转化成逻辑模型才能在DBMS中实现.</li>
<li>物理模型:面向物理存储介质,用来反映数据在物理介质中的存储,与操作系统和硬件以及DBMS都有关</li>
</ol>
<h2 id="数据模式">数据模式:</h2>
<p>模式就是对数据结构的描述,也就是说模式是用来描述数据模型中的 <strong>数据结构</strong>那一部分的<br>
在DBMS中由于数据用多级模型描述,与之对应的数据模式也有多级</p>
<ol>
<li>外模式:面向用户的,用户能看到的数据,一般通过视图实现</li>
<li>模式:是对数据库全体数据结构的描述,一个数据库只有一个模式</li>
<li>内模式:是对数据库在物理介质中存储结构的描述,比如存储路径,存储方式和索引等</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表中的冒泡排序]]></title>
        <id>https://wangyingying625.github.io/post/lian-biao-zhong-de-mou-pao-pai-xu/</id>
        <link href="https://wangyingying625.github.io/post/lian-biao-zhong-de-mou-pao-pai-xu/">
        </link>
        <updated>2021-03-22T10:40:42.000Z</updated>
        <content type="html"><![CDATA[<p>对一组数的存储方法最常见的就是数组和链表,它们各自有优缺点,链表增删操作便捷,数组可以随机存取.也是因为这样的不同,导致一些排序算法无法在链表中使用.</p>
<p>在数组中的冒泡排序已经写了太多次了,今天想尝试一下链表中的排序:</p>
<p>首先,假设链表中存储的数据是这样的</p>
<p>3-&gt;5-&gt;1-&gt;9-&gt;2</p>
<p>数组中的排序代码如下</p>
<pre><code class="language-c">void sort(int *a,int length){
int i,j,t;
int flag;
for(i=0;i&lt;length;i++){
    flag=0;
    for(j=0;j&lt;i;j++){
        if(a[i]&lt;a[j]){
            t=a[i];
            a[i]=a[j];
            a[j]=t;
            flag=1;
        }
    }
    if(flag==0)
    return;
  }
}
</code></pre>
<p>在链表中因为没有了随机存取的优势</p>
<pre><code class="language-C">typedef struct node{
int data;
struct node * next;
}Node;
int t;
void sort(Node *head,){
Node *p=NULL;
Node *teil=NULL;
p=head-&gt;next;
while(p!=teil){
while(p-&gt;next!=teil){
        if(p-&gt;data  &gt; teil-&gt;data){
                t=p-&gt;data;
                p-&gt;data=teil-&gt;data;
                teil-&gt;data=t;
            }
            p=p-&gt;next;
        }
        teil=p;
        p=head-&gt;next;
    }
}









</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接纳负面的自己]]></title>
        <id>https://wangyingying625.github.io/post/jie-na-fu-mian-de-zi-ji/</id>
        <link href="https://wangyingying625.github.io/post/jie-na-fu-mian-de-zi-ji/">
        </link>
        <updated>2021-03-22T10:21:06.000Z</updated>
        <content type="html"><![CDATA[<p>我最终还是决定在我时间这么宝贵的现在来写下这篇文章.<br>
今天一天都处在一种很焦虑的状态,不断地想如果我失败了我该怎么办,也不断的强迫自己告诉自己说你别想了,多看一道题不比这强吗,但是似乎毫无作用,尽管播着很多温柔的歌曲,还是没有办法把自己从那种状态里抽离出来,还是眼睛做着眼睛的事,脑袋做着脑袋的事.但是越这样也就导致我的焦虑感更加严重.</p>
<p>意识到要想坦然面对未知的事情,就必须调节好自己的情绪.于是放下了手里的题尝试去看书,想通过里面的文字来让自己放松一点,来告诉自己我也很优秀.但是作用也微乎其微.</p>
<p>于是去搜索&quot;如何缓解焦虑&quot;尝试找到一个答案能让我放松.看到了这篇高赞回答,它对我有用,我打算记下来.以后,我可能还会用到.</p>
<blockquote></blockquote>
<p>你应该接纳自己的一切,爱自己的一切,不管是正面的自己还是负面的自己.当你获得了成功,你会激动会开心,这个时候你充满了自信,那是因为你给了自己肯定,你接纳了那个正面的自己.<br>
而当你失败的时候,你会悲伤,你会痛苦,那是因为你给了自己否定,你没有接纳这个负面的自己.<br>
其实人从一出生的时候,就被刻画了两个自己,一个是正面的一个是负面的.正面的出现的时候,你会开心,负面的出现的时候你也不该烦恼.因为那也是你自己,你唯一能做的就是包容和接纳.<br>
当你焦虑或者恐惧的时候,你什么也不要去想,坦然的接受.仔细去感受这个负面自己的到来.尝试去想&quot;原来这就是另一个我呀,原来她是这样的,我想看看她是怎样给我带来痛苦的.&quot;<br>
当对自己的一切进行接纳之后,其实对我来说各种痛苦也就被我同化成了朋友,也就很少有东西可以伤害到我了.<br>
学会接纳自己之后,你会尊重自己的每一个选择.因为那是你自己做出来的.不管你的选择导致了什么样的结果,都要去接受.因为你不再会去遗憾什么.<br>
即使外面的情况很糟糕了,只要我还活着,那么我就可以再次做出选择,再次去改变外界的世界.</p>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[与二叉树相关的算法]]></title>
        <id>https://wangyingying625.github.io/post/yu-er-cha-shu-xiang-guan-de-suan-fa/</id>
        <link href="https://wangyingying625.github.io/post/yu-er-cha-shu-xiang-guan-de-suan-fa/">
        </link>
        <updated>2021-03-22T08:35:56.000Z</updated>
        <content type="html"><![CDATA[<p>树应该算用的比较多的数据结构,但是几乎所有场景下的使用都离不开基础算法,比如二叉树遍历,树遍历,二叉树构造,今天就总结一下这些算法:<br>
<img src="https://wangyingying625.github.io/post-images/1616402444193.png" alt="" loading="lazy"></p>
<h3 id="二叉树存储">二叉树存储:</h3>
<p>要想遍历首先得了解二叉树的存储方法:<br>
链表法:结构体定义如下</p>
<pre><code class="language-c">typedef struct tree{
   struct * tree lchild;
   struct *tree rchild;
   char data;
}Tree;
</code></pre>
<ol>
<li>二叉树前序(根左右)递归遍历:<br>
ABDECFG</li>
</ol>
<pre><code class="language-C">void PreOrder(Tree t)
{
    if ( t )
    {
    printf(&quot;%c&quot;,t-&gt;data);
    PreOrder(t-&gt;lchild);
    PreOrder(t-&gt;rchild);
    }
</code></pre>
<ol start="2">
<li>二叉树前序非递归:<br>
需要借助栈实现</li>
</ol>
<pre><code class="language-c">void PreOrder1(Tree t)
{
    Tree p = t;
    Sqstack s;
    InitStack(s);//初始化一个栈
 
    while ( p || !StackEmpty(s) )
    {
    if ( p )
    {
        printf(&quot;%c&quot;,p-&gt;data);
        Push(s,p);
        p = p-&gt;lchild;    
    }
    else
    {
        Pop(s,p); 
        p = p-&gt;rchild;
    }
    }
 
}

</code></pre>
<ol start="3">
<li>二叉树中序递归:</li>
</ol>
<pre><code class="language-c">void order(Tree t){
    Tree p=t;
    if(p){
        p=p-&gt;lchild;
        printf(&quot;%c&quot;,p-&gt;data);
        p=p-&gt;rchild;
    }
}
</code></pre>
<ol start="4">
<li>二叉树中非递归:</li>
</ol>
<pre><code class="language-c">void order1(Tree t){
    Tree p=t;
     Sqstack s;
    InitStack(s);//初始化一个栈
while ( p || !StackEmpty(s) ){
    if(p){
        push(s,p);
        p=p-&gt;lchild;
    }
    else{
        pop(s,p);
        printf(&quot;%d&quot;,p-&gt;data);
        p=p-&gt;rchild;
    }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关系模式的分解]]></title>
        <id>https://wangyingying625.github.io/post/guan-xi-mo-shi-de-fen-jie/</id>
        <link href="https://wangyingying625.github.io/post/guan-xi-mo-shi-de-fen-jie/">
        </link>
        <updated>2021-03-19T13:10:16.000Z</updated>
        <content type="html"><![CDATA[<p>关系模式分解就是把一个关系模式分解成好多个关系模式<br>
判断分解后的关系模式们是否与分解前等价的方法是 判断是否无损连接和函数依赖</p>
<p>看了视频但是对属性集的闭包部分的理解还是有些不顺畅</p>
<hr>
<p>我决定用最通俗易懂的方式解释一些基本概念<br>
逻辑蕴涵:给定一个函数依赖集F(就是学号-&gt;姓名),如果能通过F证明其他函数依赖也成立(如学号-&gt;学院),那就认为其他函数依赖被F蕴涵</p>
<p>函数依赖集的闭包:现有一关系模式 R为student(Sno,Sname,Sage,Sdep),F为属性集上的函数依赖即<br>
(Sno-&gt;Sname,Sno-&gt;Sdep,Sname-&gt;Sage)<br>
那么F的闭包指的就是在R的属性集中所有可以由依赖集合F推导出的依赖集合,记作F+</p>
<p>属性集的闭包:对依赖集F，F+中所有X→A的A的集合称为X的闭包，记为XF+。可以理解为XF+表示所有X可以决定的属性。</p>
<p>最小函数依赖集(最小覆盖,极小函数依赖集):</p>
<ol>
<li>F中任意一个函数依赖右面仅有一个属性</li>
<li>F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</li>
<li>F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}U{Z→A}与F等价。</li>
</ol>
<p>Armstrong公理:(用来推导函数依赖的)</p>
<ol>
<li>自反律:B包含于A时,A-&gt;B</li>
<li>增广律:A-&gt;B那么AC-&gt;BC</li>
<li>传递律:A-&gt;B,B-&gt;C那么A-&gt;C</li>
</ol>
<hr>
<p>关系模式的分解方法:<br>
函数依赖投影求法:<br>
首先需要明白这个操作是在做什么,为了什么;</p>
<p>决定一个属性集是不是键的时候需要考虑第一它是否能决定属性集里所有元素,第二它是否具有最小性(即他的任何子集都不能决定属性集里的所有元素)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库中的函数依赖]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-zhong-de-han-shu-yi-lai/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-zhong-de-han-shu-yi-lai/">
        </link>
        <updated>2021-03-19T04:18:20.000Z</updated>
        <content type="html"><![CDATA[<p>数据库已经看完一遍了,但是发现函数依赖这块还是盲点,于是决定专门为它写一篇<br>
首先函数依赖出现在数据库设计中的原因是什么呢?<br>
很多时候我们设计的数据库往往会有很多问题,比如同一数据可能在两张表中出现,导致数据的不一致,<br>
还有当一张表中数据项过多时也会引起插入异常和删除异常.<br>
那么怎么来判断我的关系模式(数据库表)设计的是不是好呢<br>
这就涉及到函数依赖:</p>
<h2 id="函数依赖">函数依赖</h2>
<p>x中值相等时候Y中值也相等<br>
R是一个关系模式,且里面有属性α和β,如果对于R上任意的两条元组t1和t2都有当α上的值相同时β上的值也相同,那么就说β函数依赖于α.</p>
<h3 id="平凡的函数依赖">平凡的函数依赖</h3>
<p>β⊆α则α-&gt;β</p>
<h3 id="完全函数依赖">完全函数依赖</h3>
<p>如果x能决定Y,那么任意一个x的真子集都不能决定外,就说Y完全函数依赖于x</p>
<h3 id="部分函数依赖">部分函数依赖</h3>
<p>x能决定Y,但是其实x的某个真子集就能决定外,就说Y部分函数依赖于x</p>
<h3 id="传递函数依赖">传递函数依赖</h3>
<p>x能决定y,y能决定z,就说z对x有传递函数依赖</p>
<h3 id="确定集合的闭包">确定集合的闭包:</h3>
<p><img src="https://wangyingying625.github.io/post-images/1616133575272.png" alt="" loading="lazy"><br>
(BC)+=BCA   在关系中找由BC能确定谁,就加进去闭包里面,在用闭包里面的元素去集合中找还能不能确定其他元素,直到无其他元素能被新闭包中的元素确定</p>
<h3 id="找关系的候选码">找关系的候选码</h3>
<p><img src="https://wangyingying625.github.io/post-images/1616133692636.png" alt="" loading="lazy"><br>
(BC)+=BCA<br>
(AB)+=AB<br>
(AC)+=ABC<br>
即关系的候选码是BC和AC</p>
<h2 id="范式用来区分关系模式的优劣">范式(用来区分关系模式的优劣)</h2>
<h3 id="1nf">1NF</h3>
<p>表中所有的属性域都是原子的</p>
<h3 id="2nf">2NF</h3>
<p>消除了1NF中非主属性对主属性的部分函数依赖</p>
<h3 id="3nf">3NF</h3>
<p>消除了2NF中非主属性对码的传递函数依赖</p>
<h3 id="bcnf">BCNF</h3>
<p>消除了3NF中主属性对码的部分和传递函数依赖</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux的进程和相关的几个重要函数]]></title>
        <id>https://wangyingying625.github.io/post/linux-de-jin-cheng-he-xiang-guan-de-ji-ge-chong-yao-han-shu/</id>
        <link href="https://wangyingying625.github.io/post/linux-de-jin-cheng-he-xiang-guan-de-ji-ge-chong-yao-han-shu/">
        </link>
        <updated>2021-03-19T03:43:01.000Z</updated>
        <content type="html"><![CDATA[<p>在Linux系统中每个进程都有一个唯一的编号叫pid,除了init的根进程外任何一个进程都必须由父进程产生.<br>
一个系统中的所有父子进程连起来是一个树的关系,init的进程是根,其他进程是它的子孙<br>
由父进程产生子进程的方法有:</p>
<h2 id="fork">fork()</h2>
<p>这个方法会把父进程的所有数据复制一份给子进程,产生的子进程是和调用fork()方法时候的父进程一样的,父进程的fpid指向子进程的进程id,子进程因为它自己没有子进程所以fpid值为1,可以通过判断当前进程的fpid来让两个进程选择性的执行一些代码.<br>
接着可以通过返回值的不同来判断执行当前代码的是父进程还是子进程</p>
<p>在父进程中，fork返回新创建子进程的进程ID；<br>
在子进程中,fork返回值是0</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[看见你就会看见阳光]]></title>
        <id>https://wangyingying625.github.io/post/kan-jian-ni-jiu-hui-kan-jian-yang-guang/</id>
        <link href="https://wangyingying625.github.io/post/kan-jian-ni-jiu-hui-kan-jian-yang-guang/">
        </link>
        <updated>2021-03-19T03:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>我今天必须吐槽,gridea太不好用了,等我熬过这段忙碌又艰难的生活我一定第一件事就是换掉这个博客,再留你小子几天.<br>
好的正文开始!<br>
没错,是一个很温暖很阳光的标题,但是我最近的生活里充满了各种不顺利和无奈,我不知道是不是每个人都会有这样的一段时间,是不是我努力的熬过来我就会变得强,我其实不知道答案,但是我不断的告诉自己,是的!是的!是的!所以每次失望的放下电脑躺在床上放声大哭,然后再做起来再拿起电脑再去尝试.</p>
<p>今天是他生日,但是很戏剧性的是今天他被安排出差了.就一天,今天走明天就可能回来,本来应该觉得没关系的就一天而已嘛,但是就是觉得不舒服,哪哪都不舒服,甚至这种感觉从昨天前天就开始了.</p>
<p>这段时间我们的生活里充满了无奈和不顺利,他说这是因为我们对困难处境的记忆比对幸福的记忆深刻.我说因为我们能互相感受到彼此的情绪,所以一个人的困难被过成了两份.很多时候我也意识到如果没有他的陪伴,我也不能变成今天这样,虽然还是有很多缺点,还是很胆小但是确实多了些坚韧,这应该是几年前那个我想不到我会有的吧.</p>
<p>今天早晨我妈给我发微信我才意识到确实很久没有和她联系了,但是我过得不好的时候我真的不想和他们分享,不想他们那么无力的担心我,于是轻飘飘的回复了一个我自己都不知道到底有什么含义的表情,轻飘飘的假装这就是我的生活.是的,我宁愿在这里打出这一段段根本不会有人看的文字也不想告诉他们我在经历生活中必不可缺的属于困难的那一部分.</p>
<p>好在今天这里就只有我一个人,所以我还是可以擦干眼泪轻飘飘的假装这些事情对我都没有任何影响.<br>
然后接着打开视频,去一遍一遍的录制,去检查,去克服不自信.如果这是我要成长要进步就必经的道路的话,那我能撑过来,那没什么.我依然会坐在桌前去打开视频去模拟去录制.依然会在哭过一场之后告诉自己不过如此,这都没什么.<br>
<img src="https://wangyingying625.github.io/post-images/1616124377975.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[同态与同构]]></title>
        <id>https://wangyingying625.github.io/post/tong-tai-yu-tong-gou/</id>
        <link href="https://wangyingying625.github.io/post/tong-tai-yu-tong-gou/">
        </link>
        <updated>2021-03-14T13:54:04.000Z</updated>
        <content type="html"><![CDATA[<p>当研究一个新的代数系统时候,我们就想找到一个已经了解的代数系统,看看它们之间是否有相似的性质.<br>
那么两个代数系统之间的关系就被概括成同构和同态</p>
<h2 id="同态">同态</h2>
<p>V1=&lt;A,o,o1,o2...&gt;,V2=&lt;B,*,*1,*2...&gt;是同类型的代数系统,假设oi是r元的,*i也是r元的,若满足:<br>
f(oi(a1,a2,a3...))=*i(f(a1),f(a2),f(a3)...),其中a1,a2,a3都是A中的元素<br>
即先运算再映射的值与先映射再运算的值相等</p>
<h2 id="同构">同构</h2>
<p>同态按照映射类型可分为:<br>
单同态<br>
满同态<br>
同构</p>
<p>群 G和群H之间若建立了同构映射，那么不仅群 G 中的每个元素在群 H中都有一一对应，而且对于群 G中的两个元素a,b  ，在群运算 o下得到的元素aob 也在这个映射下保持一一对应<br>
同构的两个代数系统本质没有任何差别,只是用了不同的解读方式</p>
<p>但是两个代数系统同构要求比较高,于是我们尝试找弱一点的同态代数系统,同态与同构的不同在于映射的函数f不是双射的,可能是单射可能是满射.<br>
如果是单射,那么新的代数系统中只有一部分与已知代数系统同构<br>
如果是满射,那么新的代数系统只与已知代数系统的一部分同构</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[格和布尔代数]]></title>
        <id>https://wangyingying625.github.io/post/ge-he-bu-er-dai-shu/</id>
        <link href="https://wangyingying625.github.io/post/ge-he-bu-er-dai-shu/">
        </link>
        <updated>2021-03-14T10:58:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="格">格</h2>
<p>为了说明格的概念和性质需要有偏序关系的准备知识</p>
<ol>
<li>什么是关系呢?<br>
关系(2元关系):元素全是有序对的集合<br>
如:R1={&lt;1,2&gt;,&lt;2,3&gt;}就是一个二元关系;<br>
R2={&lt;1,2&gt;,3,4}不是二元关系,其中3,4不是有序对<br>
(我会理解为关系是一种把一个元素变为另一个元素的方法,就像R1就是把1变成2,2变成3 的方法)</li>
</ol>
<p>总结一下就是首先关系是一个集合,集合中放的是有序对,即&lt;a,b&gt;与&lt;b,a&gt;代表的含义不同</p>
<ol start="2">
<li>那么,什么又叫偏序关系呢?<br>
这就得先说一说关系的一些性质了.关系是有序对的集合,它可能有一些什么性质来让我们更愿意使用它呢?<br>
自反:设R是A上的一个二元关系,说R是自反的当且仅当任取x在集合A里那么&lt;x,x&gt;就是关系R的一个元素.集合中的每个元素自己都和自己有关系(全部x都得满足)<br>
也就是说通过关系R能让元素集合A里面的所有元素都能保持自己</li>
</ol>
<p>反自反:任何x,自己和自己都没有关系(所有X都不能和自己有关系R)</p>
<p>对称:任选x和y,如果&lt;x,y&gt;有关系R那么&lt;y,x&gt;也有关系R(相等关系)<br>
也就是说一旦通过关系R,x能变成y,那么关系R也一定有办法把y变成x</p>
<p>反对称:任何两个点之间只有一条有向边</p>
<p>传递:当X和Y有关系,并且Y和Z有关系时,X和Z有关系(R和R的合成是R的子集)<br>
也就是说通过关系R如果x能变成y ,y 又能变成z的话.R就一定能把x直接变成z</p>
<p>那么这些乏味的概念和偏序关系究竟有什么关系呢?</p>
<p>In fact,偏序关系就是一种关系呀,就可以当做是把一个元素变成另一个元素的一种办法,但是它的变换是有要求的,它要求这个关系满足 自反性,反对称性和传递性,一般记作≼,被举的最多的例子就整数集上的大于和小于关系.<br>
为了让偏序关系被表示的更加明显和更方便使用,用哈斯图来表示它,比如集合{1,2,4}上的偏序关系就可以用下面的哈斯图来表示<br>
<img src="https://wangyingying625.github.io/post-images/1615721390271.png" alt="" loading="lazy"></p>
<p>偏序的概念可以联系到权限:假设ABC三人权限由高到低分别为超级管理员,管理员和普通用户,首先自反性保证了自己的信息自己能看到,反对称性表示B能看到C的信息,但是C看不到B的.传递性表明A能看到B的,B又能看到C的那么A一定能看到C的啊</p>
<p>有了这些就可以看格了!</p>
<p>首先是概念:<br>
格有两种等价概念:</p>
<ol>
<li>假设&lt;L,≼&gt;是一个偏序集,对于集合L中的任何两个元素都有最大下界和最小上界,那么&lt;L,≼&gt;就是格<br>
还用上面的ABC来举例,也就是说A和B总能找到一个人(A),那个人是能看到AB信息的人里权限最小的,也存在一个人那个人是能被A和B都看的人里权限最大的(C)</li>
</ol>
<p>那么是不是所有的偏序集都有这样的性质呢,并不是!<br>
<img src="https://wangyingying625.github.io/post-images/1615723952406.jpg" alt="" loading="lazy"><br>
这个显然不是格,因为部门A管理员和部门B管理员没有最小上界<br>
<img src="https://wangyingying625.github.io/post-images/1615723964097.jpg" alt="" loading="lazy"><br>
那么这个呢?这个也不是,因为A管理员和B管理员没有最大下界即A,B小组长无法区分大小</p>
<ol start="2">
<li>
<p>设&lt;L,∧,∨&gt;是具有两个二元运算的代数系统,如果∧对∨满足交换结合和吸收律,则称&lt;L,∧,∨&gt;是格</p>
<p>这是什么意思呢?<br>
如果偏序关系中有a≤b,那么就意味着a∨b=b<br>
也意味着a∧b=a<br>
这就说明偏序关系是可以用∨∧这两个运算来等价表示的</p>
<p>那么既然偏序关系要求具备自反,反对称,传递等关系的性质,当然也要要求这两个二元运算满足一些二元运算的要求.即交换,结合,和吸收律<br>
交换:x∧y=y∧x<br>
结合:(x∧y)∧z=x∧(y∧z)<br>
吸收:x∧(y∨x)=x</p>
</li>
</ol>
<p>那么有这些要求的格有什么性质呢:<br>
对偶命题:<br>
若果把格中的≤换成≥,同时把∨和∧互换,格中成立的一切命题换后也成立</p>
<p>和群类似,格中也有一些元素,它们自己就能满足格的概念.于是这些元素构成的集合和偏序关系就构成了子格</p>
<p>此外还有一些格具有更加特殊和良好的性质:<br>
<img src="https://wangyingying625.github.io/post-images/1615727173636.png" alt="" loading="lazy"></p>
<ol>
<li>完全格:格的每个非空子集都有最大下界和最小上界---如下图<br>
<img src="https://wangyingying625.github.io/post-images/1615726747189.png" alt="" loading="lazy"></li>
<li>分配格:设&lt;L,∧,∨&gt;是格,若对L中任取a,b,c都满足<br>
a∧(b∨c)=(a∧b)∨(a∧c)<br>
a∨(b∧c)=(a∨b)∧(a∨c)<br>
<img src="https://wangyingying625.github.io/post-images/1615727076862.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615727218456.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615727266934.png" alt="" loading="lazy"><br>
没错,我偷懒了🤔</li>
<li>有界格:设&lt;L,∧,∨&gt;是格,存在一个元素a∈L,使得a≤L中所有元素,那么称a是全下界;同时也存在一个元素b∈L,使得使得b≥L中所有元素,那么称b是全上界. 一般把全上界记为1,全下界记为0,有界格也写成&lt;L, ≤, 0, 1&gt;<br>
<img src="https://wangyingying625.github.io/post-images/1615727566609.png" alt="" loading="lazy"></li>
<li>有补格:有补格的定义涉及到补元,首先摆出补元的概念:<br>
补元：有界格&lt;L, ≤, 0, 1&gt;中, 对任意元素a∈L, 若存在b∈L, 并且a∧b = 0, a∨b = 1, 则称b是a的补元，补元不一定唯一。<br>
有补格：每一个元素都有补元，则称为有补格。<br>
有界分配格的补元唯一<br>
有界格中全上界与全下界互补</li>
<li>布尔格:如果一个格是有补分配格，就称为布尔代数<br>
<img src="https://wangyingying625.github.io/post-images/1615727947869.png" alt="" loading="lazy"></li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615728235216.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>