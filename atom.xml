<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-24T10:31:10.604Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <subtitle>&lt;p style=&quot;font-size:13px&quot;&gt;这一天,到了你幻想的年纪,却没能成为你向往的自己&lt;/p&gt;</subtitle>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[c文件读写]]></title>
        <id>https://wangyingying625.github.io/post/c-wen-jian-du-xie/</id>
        <link href="https://wangyingying625.github.io/post/c-wen-jian-du-xie/">
        </link>
        <updated>2021-03-24T09:36:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="文件类型">文件类型:</h3>
<p>文件类型分为文本文件和二进制文件两种</p>
<h3 id="文件存取方式">文件存取方式:</h3>
<p>文件存取方式有顺序存取和随机存取两种方式<br>
顺序存取中把文件自上而下一行一行的读取,保存数据时候数据加在文件末尾.<br>
随机存取的文件大多是二进制文件,通常存储的单位是一个结构块</p>
<h3 id="文件操作">文件操作</h3>
<h4 id="打开文件">打开文件:</h4>
<ol>
<li>函数原型:fopen(&quot;文件路径&quot;,&quot;打开模式&quot;);</li>
<li>返回:打开成功时返回一个文件操作符指针,否则返回NULL</li>
<li>打开模式:<br>
r:只能读文件,若文件不存在打开失败<br>
w:只能写文件,如果操作文件本来不存在,就创建一个文件;如果被操作文件本来就存在则把它删掉重新创建<br>
a:向文件增加新数据,打开时文件指针默认移动到文件尾,如果要打开文件本来不存在就打开失败<br>
r+:可读可写,但是被打开文件需要存在,否则打开失败<br>
w+:可读可写<br>
a+:可读可写,原文件中内容不被删去,默认文件指针在末尾</li>
</ol>
<h4 id="关闭文件">关闭文件:</h4>
<ol>
<li>函数原型:fclose(文件描述符指针)</li>
<li>正常关闭时返回0,否则返回非零值</li>
</ol>
<h4 id="字符存取函数">字符存取函数:</h4>
<p>存取的单位是字符</p>
<ol>
<li>读文件:fgetc(文件描述符指针),从文件流中一次读取一个字符,然后读取指针移到下个字符,逐步读取文件内容;如果读取成功返回字符,失败返回EOF(通常表示文件的结尾);判断文件是否读完用feof(),未读完返回0,已读完返回非零.</li>
<li>写文件:fputc(写入字符,文件描述符指针),每次往文件里写一个字符</li>
</ol>
<h4 id="字符串存取函数">字符串存取函数:</h4>
<p>存取的单位是字符串</p>
<ol>
<li>读文件:fgets(读出的字符串需要被存储进去的变量,字符串长度n,文件描述符),从文件流中n个字符(最后一个是\0),如果还不到n个就遇到换行或者EOF那就不继续往下读</li>
<li>写文件:fputs(&quot;打算写入的字符串&quot;,文件描述符指针),若输出成功返回0否则返回EOF</li>
</ol>
<h4 id="格式化存取函数">格式化存取函数:</h4>
<ol>
<li>读文件:fscanf(fp,&quot;%d&quot;,&quot;%s&quot;,1,&quot;123ert&quot;);<br>
是从磁盘输入内容到终端(屏幕)</li>
<li>写文件:fprintf(fp,&quot;%d&quot;,1)<br>
向磁盘输入内容</li>
</ol>
<h4 id="指针重返函数">指针重返函数:</h4>
<p>rewind(FILE *)能使文件指针重新返回文件开头</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C问题版]]></title>
        <id>https://wangyingying625.github.io/post/c-wen-ti-ban/</id>
        <link href="https://wangyingying625.github.io/post/c-wen-ti-ban/">
        </link>
        <updated>2021-03-24T04:32:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="二维数组">二维数组:</h3>
<ol>
<li>将一个数组按下标是奇数或者偶数分类打成一个二维数组:<br>
实现方法:<br>
首先设这个方法名字叫classfy(int *a)<br>
定义一个变量i用来遍历数组a,整形变量j和k用来标识二维数组的第一行和第二行下标,并赋初值0<br>
如果i%2=0那就把b[0][j++]=a[i]<br>
如果i%2=1那就把b[1][k++]=a[i]</li>
</ol>
<h3 id="字符串">字符串</h3>
<ol>
<li>删除字符串S中从第k个字符开始的n个字符,若不足n个,删除到末尾即可<br>
实现方法:<br>
首先这个函数命名del(char *s,int k,int n){}<br>
定义一个int型变量i用来遍历字符数组s求出数组长复制给length;<br>
比较length-1与k+n的大小<br>
如果length大那么再去遍历数组,找到第k+n个字符和第k个位置,从k+n开始依次把字符前移到k,k+1...直到数组中遇到'\0'把第一个'\0'也移动过去.<br>
如果length小或者相等,那么把数组的第k个位置赋值'\0'</li>
</ol>
<h3 id="指针数组">指针数组</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(){
    char * p[]={&quot;hi&quot;,&quot;helo&quot;,&quot;java&quot;,&quot;C++&quot;};
    int i;
    for(i=0;i&lt;4;i++){
        printf(&quot;%c:&quot;,*p[i]);
        printf(&quot;%s\n&quot;,*(p+i));
    }
    return 0;
}
</code></pre>
<p><img src="https://wangyingying625.github.io/post-images/1616563723654.png" alt="" loading="lazy"><br>
指针数组程序解读:<br>
首先 char * p[]是一个指针数组,相当于一个二维数组(数组的每一个内容都是指针)<br>
p[0]是指向字符串hi的指针,p[1]是指向字符串helo的指针...<br>
但是p[0]的内容是所指向字符串的首字母<br>
(p+1)的内容才是字符串</p>
<h3 id="结构体数组">结构体数组</h3>
<ol>
<li>调用函数inputSTU输入30个学生的姓名和每个学生3门课成绩,调用函数namesort对名字进行排序<br>
调用函数getmaxmin计算每个学生的总成绩换人成绩的最大值最小值</li>
</ol>
<pre><code class="language-c">//
//  struct.c
//  test1
//
//  Created by mldwyy on 2021/3/24.
//

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
typedef struct stu{
    char name[20];
    int grade[3];
}Stu;
void inputSTU(Stu list[]){
    int i=0;
    int j=0;
    while (i&lt;3) {
        printf(&quot;input name&quot;);
        gets(list[i].name);
        for(j=0;j&lt;3;j++){
            scanf(&quot;%d&quot;,&amp;list[i].grade[j]);
        }
        getchar();
        i++;
    }
    
}
void nameSort(Stu l[]){
    int i,j;
    Stu t;
    printf(&quot;here\n&quot;);
    for(i=0;i&lt;2;i++){
        for(j=0;j&lt;2-i;j++){
            if(strcmp(l[j].name,l[j+1].name)&gt;0){
                t=l[j];
                l[j]=l[j+1];
                l[j+1]=t;
            }
        }
    }
}
int main(){
    Stu a[3];
    inputSTU(a);
    nameSort(a);
    printf(&quot;%s\n&quot;,a[0].name);
    return 0;
}
</code></pre>
<h3 id="链表">链表</h3>
<p>编写两个函数:NODE *createLink()分别创建男生和女生的身高非递减链表,返回链表首地址.<br>
NODE *merge(NODE *H1,NODE *h2)按照身高非递减合并两个列表,返回链表首地址.</p>
<pre><code class="language-c">//
//  node.c
//  test1
//
//  Created by mldwyy on 2021/3/24.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct node{
    int num;
    double height;
    struct node * next;
}NODE;
NODE * CreateLink(){
    NODE *head=NULL ;
    NODE *p,*q;
    while (1) {
        NODE * node =(NODE *)malloc(sizeof(NODE));
        scanf(&quot;%d&quot;,&amp;node-&gt;num);
        if(node-&gt;num==-1)
            break;
        printf(&quot;请输入shengao\n&quot;);
        scanf(&quot;%lf&quot;,&amp;node-&gt;height);
        node-&gt;next=NULL;
        
        if(head==NULL){
            head=node;
        }
        else{
            q=head;
            if(q&amp;&amp;q-&gt;height&gt;node-&gt;height){
                node-&gt;next=q;
                head=node;
            }
            else{
                while(q&amp;&amp;q-&gt;height&lt;node-&gt;height){
                    p=q;
                    q=q-&gt;next;
                }
                node-&gt;next=q;
                p-&gt;next=node;
            }
        }
    }
    return head;
};
NODE *MergeLink(NODE *w,NODE *m){
    NODE *head=NULL;
    NODE * node =(NODE *)malloc(sizeof(NODE));
    NODE *p,*q;
    p=w;
    q=m;
    while(p!=NULL || q!=NULL){
        if(p!=NULL&amp;&amp; q!=NULL &amp;&amp; (p-&gt;height)&lt;=(q-&gt;height)){
            if(head==NULL){
                node=p;
                head=node;
                p=p-&gt;next;
            }
            else{
                node-&gt;next=p;
                node=node-&gt;next;
                p=p-&gt;next;
            }
        }
        else if(p!=NULL&amp;&amp; q!=NULL &amp;&amp; p-&gt;height&gt;q-&gt;height){
            if(head==NULL){
                node=q;
                head=node;
                q=q-&gt;next;
            }
            else{
                node-&gt;next=q;
                node=node-&gt;next;
                q=q-&gt;next;
            }
        }
        else if(p==NULL&amp;&amp; q!=NULL){
            node-&gt;next=q;
            break;
        }
        else if(p!=NULL&amp;&amp; q==NULL){
            node-&gt;next=p;
            break;
        }
    }
    return head;
};
void output(NODE *h){
    while(h!=NULL){
        printf(&quot;%lf\n&quot;,h-&gt;height);
        h=h-&gt;next;
    }
}
int main(){
    NODE *H,*H_M,*H_F;
    printf(&quot;请输入男生信息\n&quot;);
    H_M = CreateLink();
    printf(&quot;请输入女生信息\n&quot;);
    H_F=CreateLink();
    H=MergeLink(H_M,H_F);
    output(H);
    return 0;
}


</code></pre>
<h3 id="文件">文件</h3>
<ol>
<li>输入员工信息,保存到文件empty.txt中,并从该文件读出数据.员工信息由编号,项目和薪资组成<pre><code class="language-c">
</code></pre>
</li>
</ol>
<h3 id="递归">递归</h3>
<h3 id="二叉树">二叉树</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据模型与数据模式]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-mo-xing-yu-shu-ju-mo-shi/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-mo-xing-yu-shu-ju-mo-shi/">
        </link>
        <updated>2021-03-22T11:28:55.000Z</updated>
        <content type="html"><![CDATA[<p>发现自己好像把这两个概念混起来了,我得仔细区分一下</p>
<h2 id="数据模型">数据模型:</h2>
<p>用来描述数据的一组定义.<br>
一般对数据的描述包括三个部分:数据结构+数据操作+完整性约束</p>
<p>首先数据模型是实现DBMS的基础,同时它还是对现实世界中数据的抽象.那就要求它既与现实贴近又要容易实现.<br>
于是采用了分层的方法,针对不同的用户使用不同的数据模型:</p>
<ol>
<li>概念模型:面向用户,与DBMS无关</li>
<li>逻辑模型:用户从数据库看到的数据模型.与DBMS有关,DBMS常用它所使用的逻辑模型来分类(如关系型数据库),用概念模型抽象的数据必须转化成逻辑模型才能在DBMS中实现.</li>
<li>物理模型:面向物理存储介质,用来反映数据在物理介质中的存储,与操作系统和硬件以及DBMS都有关</li>
</ol>
<h2 id="数据模式">数据模式:</h2>
<p>模式就是对数据结构的描述,也就是说模式是用来描述数据模型中的 <strong>数据结构</strong>那一部分的<br>
在DBMS中由于数据用多级模型描述,与之对应的数据模式也有多级</p>
<ol>
<li>外模式:面向用户的,用户能看到的数据,一般通过视图实现</li>
<li>模式:是对数据库全体数据结构的描述,一个数据库只有一个模式</li>
<li>内模式:是对数据库在物理介质中存储结构的描述,比如存储路径,存储方式和索引等</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表中的冒泡排序]]></title>
        <id>https://wangyingying625.github.io/post/lian-biao-zhong-de-mou-pao-pai-xu/</id>
        <link href="https://wangyingying625.github.io/post/lian-biao-zhong-de-mou-pao-pai-xu/">
        </link>
        <updated>2021-03-22T10:40:42.000Z</updated>
        <content type="html"><![CDATA[<p>对一组数的存储方法最常见的就是数组和链表,它们各自有优缺点,链表增删操作便捷,数组可以随机存取.也是因为这样的不同,导致一些排序算法无法在链表中使用.</p>
<p>在数组中的冒泡排序已经写了太多次了,今天想尝试一下链表中的排序:</p>
<p>首先,假设链表中存储的数据是这样的</p>
<p>3-&gt;5-&gt;1-&gt;9-&gt;2</p>
<p>数组中的排序代码如下</p>
<pre><code class="language-c">void sort(int *a,int length){
int i,j,t;
int flag;
for(i=0;i&lt;length;i++){
    flag=0;
    for(j=0;j&lt;i;j++){
        if(a[i]&lt;a[j]){
            t=a[i];
            a[i]=a[j];
            a[j]=t;
            flag=1;
        }
    }
    if(flag==0)
    return;
  }
}
</code></pre>
<p>在链表中因为没有了随机存取的优势</p>
<pre><code class="language-C">typedef struct node{
int data;
struct node * next;
}Node;
int t;
void sort(Node *head,){
Node *p=NULL;
Node *teil=NULL;
p=head-&gt;next;
while(p!=teil){
while(p-&gt;next!=teil){
        if(p-&gt;data  &gt; teil-&gt;data){
                t=p-&gt;data;
                p-&gt;data=teil-&gt;data;
                teil-&gt;data=t;
            }
            p=p-&gt;next;
        }
        teil=p;
        p=head-&gt;next;
    }
}









</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接纳负面的自己]]></title>
        <id>https://wangyingying625.github.io/post/jie-na-fu-mian-de-zi-ji/</id>
        <link href="https://wangyingying625.github.io/post/jie-na-fu-mian-de-zi-ji/">
        </link>
        <updated>2021-03-22T10:21:06.000Z</updated>
        <content type="html"><![CDATA[<p>我最终还是决定在我时间这么宝贵的现在来写下这篇文章.<br>
今天一天都处在一种很焦虑的状态,不断地想如果我失败了我该怎么办,也不断的强迫自己告诉自己说你别想了,多看一道题不比这强吗,但是似乎毫无作用,尽管播着很多温柔的歌曲,还是没有办法把自己从那种状态里抽离出来,还是眼睛做着眼睛的事,脑袋做着脑袋的事.但是越这样也就导致我的焦虑感更加严重.</p>
<p>意识到要想坦然面对未知的事情,就必须调节好自己的情绪.于是放下了手里的题尝试去看书,想通过里面的文字来让自己放松一点,来告诉自己我也很优秀.但是作用也微乎其微.</p>
<p>于是去搜索&quot;如何缓解焦虑&quot;尝试找到一个答案能让我放松.看到了这篇高赞回答,它对我有用,我打算记下来.以后,我可能还会用到.</p>
<blockquote></blockquote>
<p>你应该接纳自己的一切,爱自己的一切,不管是正面的自己还是负面的自己.当你获得了成功,你会激动会开心,这个时候你充满了自信,那是因为你给了自己肯定,你接纳了那个正面的自己.<br>
而当你失败的时候,你会悲伤,你会痛苦,那是因为你给了自己否定,你没有接纳这个负面的自己.<br>
其实人从一出生的时候,就被刻画了两个自己,一个是正面的一个是负面的.正面的出现的时候,你会开心,负面的出现的时候你也不该烦恼.因为那也是你自己,你唯一能做的就是包容和接纳.<br>
当你焦虑或者恐惧的时候,你什么也不要去想,坦然的接受.仔细去感受这个负面自己的到来.尝试去想&quot;原来这就是另一个我呀,原来她是这样的,我想看看她是怎样给我带来痛苦的.&quot;<br>
当对自己的一切进行接纳之后,其实对我来说各种痛苦也就被我同化成了朋友,也就很少有东西可以伤害到我了.<br>
学会接纳自己之后,你会尊重自己的每一个选择.因为那是你自己做出来的.不管你的选择导致了什么样的结果,都要去接受.因为你不再会去遗憾什么.<br>
即使外面的情况很糟糕了,只要我还活着,那么我就可以再次做出选择,再次去改变外界的世界.</p>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[与二叉树相关的算法]]></title>
        <id>https://wangyingying625.github.io/post/yu-er-cha-shu-xiang-guan-de-suan-fa/</id>
        <link href="https://wangyingying625.github.io/post/yu-er-cha-shu-xiang-guan-de-suan-fa/">
        </link>
        <updated>2021-03-22T08:35:56.000Z</updated>
        <content type="html"><![CDATA[<p>树应该算用的比较多的数据结构,但是几乎所有场景下的使用都离不开基础算法,比如二叉树遍历,树遍历,二叉树构造,今天就总结一下这些算法:<br>
<img src="https://wangyingying625.github.io/post-images/1616402444193.png" alt="" loading="lazy"></p>
<h3 id="二叉树存储">二叉树存储:</h3>
<p>要想遍历首先得了解二叉树的存储方法:<br>
链表法:结构体定义如下</p>
<pre><code class="language-c">typedef struct tree{
   struct * tree lchild;
   struct *tree rchild;
   char data;
}Tree;
</code></pre>
<ol>
<li>二叉树前序(根左右)递归遍历:<br>
ABDECFG</li>
</ol>
<pre><code class="language-C">void PreOrder(Tree t)
{
    if ( t )
    {
    printf(&quot;%c&quot;,t-&gt;data);
    PreOrder(t-&gt;lchild);
    PreOrder(t-&gt;rchild);
    }
</code></pre>
<ol start="2">
<li>二叉树前序非递归:<br>
需要借助栈实现</li>
</ol>
<pre><code class="language-c">void PreOrder1(Tree t)
{
    Tree p = t;
    Sqstack s;
    InitStack(s);//初始化一个栈
 
    while ( p || !StackEmpty(s) )
    {
    if ( p )
    {
        printf(&quot;%c&quot;,p-&gt;data);
        Push(s,p);
        p = p-&gt;lchild;    
    }
    else
    {
        Pop(s,p); 
        p = p-&gt;rchild;
    }
    }
 
}

</code></pre>
<ol start="3">
<li>二叉树中序递归:</li>
</ol>
<pre><code class="language-c">void order(Tree t){
    Tree p=t;
    if(p){
        p=p-&gt;lchild;
        printf(&quot;%c&quot;,p-&gt;data);
        p=p-&gt;rchild;
    }
}
</code></pre>
<ol start="4">
<li>二叉树中非递归:</li>
</ol>
<pre><code class="language-c">void order1(Tree t){
    Tree p=t;
     Sqstack s;
    InitStack(s);//初始化一个栈
while ( p || !StackEmpty(s) ){
    if(p){
        push(s,p);
        p=p-&gt;lchild;
    }
    else{
        pop(s,p);
        printf(&quot;%d&quot;,p-&gt;data);
        p=p-&gt;rchild;
    }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关系模式的分解]]></title>
        <id>https://wangyingying625.github.io/post/guan-xi-mo-shi-de-fen-jie/</id>
        <link href="https://wangyingying625.github.io/post/guan-xi-mo-shi-de-fen-jie/">
        </link>
        <updated>2021-03-19T13:10:16.000Z</updated>
        <content type="html"><![CDATA[<p>关系模式分解就是把一个关系模式分解成好多个关系模式<br>
判断分解后的关系模式们是否与分解前等价的方法是 判断是否无损连接和函数依赖</p>
<p>看了视频但是对属性集的闭包部分的理解还是有些不顺畅</p>
<hr>
<p>我决定用最通俗易懂的方式解释一些基本概念<br>
逻辑蕴涵:给定一个函数依赖集F(就是学号-&gt;姓名),如果能通过F证明其他函数依赖也成立(如学号-&gt;学院),那就认为其他函数依赖被F蕴涵</p>
<p>函数依赖集的闭包:现有一关系模式 R为student(Sno,Sname,Sage,Sdep),F为属性集上的函数依赖即<br>
(Sno-&gt;Sname,Sno-&gt;Sdep,Sname-&gt;Sage)<br>
那么F的闭包指的就是在R的属性集中所有可以由依赖集合F推导出的依赖集合,记作F+</p>
<p>属性集的闭包:对依赖集F，F+中所有X→A的A的集合称为X的闭包，记为XF+。可以理解为XF+表示所有X可以决定的属性。</p>
<p>最小函数依赖集(最小覆盖,极小函数依赖集):</p>
<ol>
<li>F中任意一个函数依赖右面仅有一个属性</li>
<li>F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</li>
<li>F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}U{Z→A}与F等价。</li>
</ol>
<p>Armstrong公理:(用来推导函数依赖的)</p>
<ol>
<li>自反律:B包含于A时,A-&gt;B</li>
<li>增广律:A-&gt;B那么AC-&gt;BC</li>
<li>传递律:A-&gt;B,B-&gt;C那么A-&gt;C</li>
</ol>
<hr>
<p>关系模式的分解方法:<br>
函数依赖投影求法:<br>
首先需要明白这个操作是在做什么,为了什么;</p>
<p>决定一个属性集是不是键的时候需要考虑第一它是否能决定属性集里所有元素,第二它是否具有最小性(即他的任何子集都不能决定属性集里的所有元素)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库中的函数依赖]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-zhong-de-han-shu-yi-lai/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-zhong-de-han-shu-yi-lai/">
        </link>
        <updated>2021-03-19T04:18:20.000Z</updated>
        <content type="html"><![CDATA[<p>数据库已经看完一遍了,但是发现函数依赖这块还是盲点,于是决定专门为它写一篇<br>
首先函数依赖出现在数据库设计中的原因是什么呢?<br>
很多时候我们设计的数据库往往会有很多问题,比如同一数据可能在两张表中出现,导致数据的不一致,<br>
还有当一张表中数据项过多时也会引起插入异常和删除异常.<br>
那么怎么来判断我的关系模式(数据库表)设计的是不是好呢<br>
这就涉及到函数依赖:</p>
<h2 id="函数依赖">函数依赖</h2>
<p>x中值相等时候Y中值也相等<br>
R是一个关系模式,且里面有属性α和β,如果对于R上任意的两条元组t1和t2都有当α上的值相同时β上的值也相同,那么就说β函数依赖于α.</p>
<h3 id="平凡的函数依赖">平凡的函数依赖</h3>
<p>β⊆α则α-&gt;β</p>
<h3 id="完全函数依赖">完全函数依赖</h3>
<p>如果x能决定Y,那么任意一个x的真子集都不能决定外,就说Y完全函数依赖于x</p>
<h3 id="部分函数依赖">部分函数依赖</h3>
<p>x能决定Y,但是其实x的某个真子集就能决定外,就说Y部分函数依赖于x</p>
<h3 id="传递函数依赖">传递函数依赖</h3>
<p>x能决定y,y能决定z,就说z对x有传递函数依赖</p>
<h3 id="确定集合的闭包">确定集合的闭包:</h3>
<p><img src="https://wangyingying625.github.io/post-images/1616133575272.png" alt="" loading="lazy"><br>
(BC)+=BCA   在关系中找由BC能确定谁,就加进去闭包里面,在用闭包里面的元素去集合中找还能不能确定其他元素,直到无其他元素能被新闭包中的元素确定</p>
<h3 id="找关系的候选码">找关系的候选码</h3>
<p><img src="https://wangyingying625.github.io/post-images/1616133692636.png" alt="" loading="lazy"><br>
(BC)+=BCA<br>
(AB)+=AB<br>
(AC)+=ABC<br>
即关系的候选码是BC和AC</p>
<h2 id="范式用来区分关系模式的优劣">范式(用来区分关系模式的优劣)</h2>
<h3 id="1nf">1NF</h3>
<p>表中所有的属性域都是原子的</p>
<h3 id="2nf">2NF</h3>
<p>消除了1NF中非主属性对主属性的部分函数依赖</p>
<h3 id="3nf">3NF</h3>
<p>消除了2NF中非主属性对码的传递函数依赖</p>
<h3 id="bcnf">BCNF</h3>
<p>消除了3NF中主属性对码的部分和传递函数依赖</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux的进程和相关的几个重要函数]]></title>
        <id>https://wangyingying625.github.io/post/linux-de-jin-cheng-he-xiang-guan-de-ji-ge-chong-yao-han-shu/</id>
        <link href="https://wangyingying625.github.io/post/linux-de-jin-cheng-he-xiang-guan-de-ji-ge-chong-yao-han-shu/">
        </link>
        <updated>2021-03-19T03:43:01.000Z</updated>
        <content type="html"><![CDATA[<p>在Linux系统中每个进程都有一个唯一的编号叫pid,除了init的根进程外任何一个进程都必须由父进程产生.<br>
一个系统中的所有父子进程连起来是一个树的关系,init的进程是根,其他进程是它的子孙<br>
由父进程产生子进程的方法有:</p>
<h2 id="fork">fork()</h2>
<p>这个方法会把父进程的所有数据复制一份给子进程,产生的子进程是和调用fork()方法时候的父进程一样的,父进程的fpid指向子进程的进程id,子进程因为它自己没有子进程所以fpid值为1,可以通过判断当前进程的fpid来让两个进程选择性的执行一些代码.<br>
接着可以通过返回值的不同来判断执行当前代码的是父进程还是子进程</p>
<p>在父进程中，fork返回新创建子进程的进程ID；<br>
在子进程中,fork返回值是0</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[看见你就会看见阳光]]></title>
        <id>https://wangyingying625.github.io/post/kan-jian-ni-jiu-hui-kan-jian-yang-guang/</id>
        <link href="https://wangyingying625.github.io/post/kan-jian-ni-jiu-hui-kan-jian-yang-guang/">
        </link>
        <updated>2021-03-19T03:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>我今天必须吐槽,gridea太不好用了,等我熬过这段忙碌又艰难的生活我一定第一件事就是换掉这个博客,再留你小子几天.<br>
好的正文开始!<br>
没错,是一个很温暖很阳光的标题,但是我最近的生活里充满了各种不顺利和无奈,我不知道是不是每个人都会有这样的一段时间,是不是我努力的熬过来我就会变得强,我其实不知道答案,但是我不断的告诉自己,是的!是的!是的!所以每次失望的放下电脑躺在床上放声大哭,然后再做起来再拿起电脑再去尝试.</p>
<p>今天是他生日,但是很戏剧性的是今天他被安排出差了.就一天,今天走明天就可能回来,本来应该觉得没关系的就一天而已嘛,但是就是觉得不舒服,哪哪都不舒服,甚至这种感觉从昨天前天就开始了.</p>
<p>这段时间我们的生活里充满了无奈和不顺利,他说这是因为我们对困难处境的记忆比对幸福的记忆深刻.我说因为我们能互相感受到彼此的情绪,所以一个人的困难被过成了两份.很多时候我也意识到如果没有他的陪伴,我也不能变成今天这样,虽然还是有很多缺点,还是很胆小但是确实多了些坚韧,这应该是几年前那个我想不到我会有的吧.</p>
<p>今天早晨我妈给我发微信我才意识到确实很久没有和她联系了,但是我过得不好的时候我真的不想和他们分享,不想他们那么无力的担心我,于是轻飘飘的回复了一个我自己都不知道到底有什么含义的表情,轻飘飘的假装这就是我的生活.是的,我宁愿在这里打出这一段段根本不会有人看的文字也不想告诉他们我在经历生活中必不可缺的属于困难的那一部分.</p>
<p>好在今天这里就只有我一个人,所以我还是可以擦干眼泪轻飘飘的假装这些事情对我都没有任何影响.<br>
然后接着打开视频,去一遍一遍的录制,去检查,去克服不自信.如果这是我要成长要进步就必经的道路的话,那我能撑过来,那没什么.我依然会坐在桌前去打开视频去模拟去录制.依然会在哭过一场之后告诉自己不过如此,这都没什么.<br>
<img src="https://wangyingying625.github.io/post-images/1616124377975.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>