<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-08T11:22:50.845Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[离散数学问题]]></title>
        <id>https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/</id>
        <link href="https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/">
        </link>
        <updated>2021-03-08T08:23:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="如何给集合下定义">如何给集合下定义</h2>
<h2 id="如何用集合定义关系函数和自然数">如何用集合定义关系,函数和自然数</h2>
<h2 id="如何比较集合的大小">如何比较集合的大小</h2>
<h2 id="有没有最大的集合">有没有最大的集合</h2>
<h2 id="能否把每个集合的元素依次列举">能否把每个集合的元素依次列举</h2>
<h2 id="什么是图">什么是图</h2>
<h2 id="有哪些图">有哪些图</h2>
<h2 id="图有什么性质">图有什么性质</h2>
<h2 id="什么是欧拉图">什么是欧拉图</h2>
<h2 id="什么是哈密顿图">什么是哈密顿图</h2>
<h2 id="什么是树">什么是树</h2>
<h2 id="如何用矩阵表示图">如何用矩阵表示图</h2>
<h2 id="什么是平面图">什么是平面图</h2>
<h2 id="什么是图的着色">什么是图的着色</h2>
<h2 id="什么是带权图">什么是带权图</h2>
<h2 id="什么是支配集">什么是支配集</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图论]]></title>
        <id>https://wangyingying625.github.io/post/tu-lun/</id>
        <link href="https://wangyingying625.github.io/post/tu-lun/">
        </link>
        <updated>2021-03-08T08:22:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="图">图</h1>
<h2 id="基本概念">基本概念</h2>
<h2 id="连通性">连通性</h2>
<h2 id="欧拉图与哈密顿图">欧拉图与哈密顿图</h2>
<h2 id="树">树</h2>
<h2 id="图的矩阵表示">图的矩阵表示</h2>
<h2 id="平面图">平面图</h2>
<h2 id="着色">着色</h2>
<h2 id="带权图">带权图</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合论]]></title>
        <id>https://wangyingying625.github.io/post/ji-he-lun/</id>
        <link href="https://wangyingying625.github.io/post/ji-he-lun/">
        </link>
        <updated>2021-03-08T08:18:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合">集合</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="命题公式">命题公式:</h3>
<h4 id="联结词">联结词:</h4>
<p>p,q,r...表示原子命题(简单命题,可当做逻辑变量即布尔变量);0表示假,1表示真</p>
<ol>
<li>否定联结词 ¬ :<br>
¬p称为p的否定式 :<br>
<img src="https://wangyingying625.github.io/post-images/1615192683283.png" alt="" loading="lazy"></li>
<li>合取联结词∧:<br>
p ∧q称为p与q的合取式<br>
<img src="https://wangyingying625.github.io/post-images/1615192963199.png" alt="" loading="lazy"></li>
<li>析取联结词∨:<br>
p∨q称为q与p的析取式<br>
<img src="https://wangyingying625.github.io/post-images/1615193105570.png" alt="" loading="lazy"></li>
<li>蕴涵联结词-&gt;:<br>
p-&gt;q的真假性与p&lt;=q一致<br>
<img src="https://wangyingying625.github.io/post-images/1615193176146.png" alt="" loading="lazy"></li>
<li>等价联结词&lt;-&gt;:<br>
p&lt;-&gt;q与p==q真假性一致<br>
<img src="https://wangyingying625.github.io/post-images/1615193661156.png" alt="" loading="lazy"><br>
优先级: ¬ ,∨ ∧,-&gt; &lt;-&gt;</li>
</ol>
<h3 id="命题公式-2">命题公式:</h3>
<h4 id="命题公式的组成">命题公式的组成:</h4>
<ol>
<li>单个命题变元就是命题公式</li>
<li>对命题变元进行有限次联结词连接得到的也是命题公式</li>
</ol>
<h4 id="命题公式的类型">命题公式的类型:</h4>
<ol>
<li>可满足式:当一个命题公式,其中的原子命题取不同的值时可能对应公式取值为真.</li>
<li>矛盾式(永假式):原子命题所有可能的取值组合(0,1组合)下,此公式的取值都为假</li>
<li>重言式(永真式):原子命题所有可能的取值组合(0,1组合)下,此公式的取值都为真(是可满足式的一种)</li>
</ol>
<h3 id="等值式">等值式:</h3>
<p>定义:两个命题公式满足A&lt;=&gt;B则A&lt;-&gt;B是永真式.即A与B可以互相代替</p>
<p>正确性的证明:两边列真值表,若在原子命题取不同值的时候两边的取值都一样,则验证正确</p>
<h4 id="常用等值式">常用等值式:</h4>
<ol>
<li>蕴涵等值式:p-&gt;q  &lt;=&gt;   ¬ p∨q  (蕴涵联结词是多余的,可被与或非表示)</li>
<li>幂等律：A∧A⇔A      ||||||||||        A∨A⇔A</li>
<li>交换律：A∨B⇔B∨A    ||||||||||||     A∧B⇔B∧A</li>
<li>结合律：<br>
（A∧B）∧C⇔A∧（B∧C）<br>
（A∨B）∨C⇔A∨（B∨C）</li>
<li>分配律：<br>
A∨（B∧C）⇔（A∨B）∧（A∨C）<br>
A∧（B∨C）⇔（A∧B）∨（A∧C）</li>
<li>德摩根律：<br>
┐（A∨B）⇔┐A∧┐B<br>
┐（A∧B）⇔┐A∨┐B</li>
<li>吸收律：<br>
A∨（A∧B）⇔A<br>
A∧（A∨B）⇔A</li>
<li>零律：<br>
A∨1⇔1<br>
A∧0⇔0</li>
<li>同一律：<br>
A∨0⇔A<br>
A∧1⇔A</li>
<li>排中律：A∨┐A⇔1(若A不对则非A一定对)</li>
<li>矛盾律：A∧┐A⇔0(若A对则非A一定不对)</li>
<li>双重否定律：┐┐A⇔A</li>
<li>等价等值式:A&lt;-&gt;B &lt;=&gt; (A -&gt; B)∧(B-&gt;A) (等价联结词是多余的,可被蕴含联结词和与或非表示)</li>
<li>等价否定等值式：A↔B⇔┐A↔┐B</li>
<li>归谬论：（A→B）∧（A→┐B）⇔┐A<br>
只涉及与或非时,与跟或换时0跟1也换</li>
</ol>
<h4 id="等值演算就是给一个命题公式通过等值式的转换得到另外一个命题公式他们俩是等价的可用真值表验证">等值演算:就是给一个命题公式通过等值式的转换得到另外一个命题公式,他们俩是等价的(可用真值表验证)</h4>
<p>判断两个公式是否相等的两种方法:等值演算;列真值表<br>
任何两个公式只要是相等的一定能通过等值演算证明</p>
<h3 id="推理">推理:</h3>
<p>由一个命题得出另外一个命题的过程</p>
<h4 id="推理的形式结构">推理的形式结构:</h4>
<p>前提:A1,A2,A3...<br>
结论:B<br>
形式结构:<br>
(A1 ∧ A2 ∧ A3 ∧ A4...)-&gt;B</p>
<h4 id="推理定律">推理定律</h4>
<p>A=&gt;B则A-&gt;B是永真式</p>
<ol>
<li>拒取式:(A-&gt;B)∧ ¬ B  =&gt;  A</li>
<li>附加律:A=&gt;(A∨B)</li>
<li>化简律:(A∧B)=&gt;A,(A∧B)=&gt;B</li>
<li>假言:(A-&gt;B)∧A=&gt;B(A能推出B,并且A是对的,那么B就是对的)</li>
<li>析取三段论:(A∨B)∧ ¬ A=&gt;B<br>
(AVB)∧ ¬ B=&gt;A<br>
A和B必有嫌疑人,排除A那B是嫌疑人</li>
<li>假言三段论:(A-&gt;B)∧(B-&gt;C) =&gt;(A-&gt;C)</li>
<li>等价三段论:(A&lt;-&gt;B)∧(B&lt;-&gt;C) =&gt;(A&lt;-&gt;C)</li>
<li>构造性两难:(A-&gt;B)∧(C-&gt;D)∧(AVC) =&gt; (BVD)</li>
</ol>
<h4 id="判断推理正确的方法">判断推理正确的方法</h4>
<p>前提:p-&gt;(q-&gt;r),p,q<br>
结论:r<br>
方法一:</p>
<ol>
<li>写出推理的形式结构</li>
<li>证明该形式结构永真<br>
<img src="https://wangyingying625.github.io/post-images/1615198910960.jpg" alt="" loading="lazy"><br>
方法二:从前提推演结论<br>
(P-&gt;(q-&gt;r))∧p∧q  =&gt;<br>
(q-&gt;r)∧q  =&gt;<br>
r</li>
</ol>
<h3 id="谓词逻辑">谓词逻辑:</h3>
<p>对命题再进行细分.命题是陈述句,再按照主语谓语分<br>
主语是个体,谓语是谓词</p>
<h4 id="基本概念-2">基本概念</h4>
<ol>
<li>个体:可以独立存在的客体,通常用a,b,c表示个体常元;用x,y,z表示个体变元</li>
<li>谓词:表示个体性质或者彼此之间联系的词,常用F,G,H..表示<br>
F(x)表示x具有性质F<br>
若F(x,y)表示x&gt;y则F(3,2)表示3大于2</li>
<li>量词:表示数量的词:<br>
全称量词:所有的⩝<br>
⩝x表示所有的x<br>
⩝xF(x)表示个体域里的所有x都有F(x)这个属性<br>
存在量词:存在∃<br>
∃xF(x)表示个体域中有x 有性质F</li>
</ol>
<h4 id="命题符号化">命题符号化:</h4>
<p><img src="https://wangyingying625.github.io/post-images/1615200644492.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615200651176.jpg" alt="" loading="lazy"></p>
<h4 id="一阶谓词逻辑公式">一阶谓词逻辑公式</h4>
<p>量词加在个体上,即任何X或者存在X<br>
<img src="https://wangyingying625.github.io/post-images/1615201094641.jpg" alt="" loading="lazy"><br>
如果逻辑公式A在任何解释下都为真,则它是永真式<br>
如果逻辑公式A在任何解释下都为真,则它是永假式<br>
如果逻辑公式A至少存在一个解释使其为真,则它是可满足式<br>
如果A&lt;-&gt;B是永真的,那么A与B等值,记为A&lt;=&gt;B</p>
<h5 id="基本等值式">基本等值式:</h5>
<ol>
<li>在有限个体域上消去量词:<br>
⩝xA(x)&lt;=&gt;A(x1)∧A(x2)∧A(x3)∧A(x4)∧A(x5)∧A(x6)...<br>
∃yB(y)&lt;=&gt;B(y1)∨B(y2)∨B(y3)∨B(y4)∨B(y5)∨B(y6)∨B(y7)...</li>
<li>量词否定等值式:<br>
¬ ⩝xA(x) &lt;=&gt; ∃x ¬ A(x)<br>
¬ ∃xB(x) &lt;=&gt; ⩝x ¬ B(x)</li>
<li>量词辖域收缩和扩张等值式:<br>
<img src="https://wangyingying625.github.io/post-images/1615201852622.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615202547661.png" alt="" loading="lazy"></li>
</ol>
<hr>
<h2 id="运算和性质">运算和性质</h2>
<h1 id="二元关系">二元关系</h1>
<h2 id="表示和性质">表示和性质</h2>
<h2 id="等价关系">等价关系</h2>
<h2 id="序关系">序关系</h2>
<h1 id="函数">函数</h1>
<h1 id="自然数">自然数</h1>
<h1 id="基数和序数">基数和序数</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库思维导图]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-si-wei-dao-tu/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-si-wei-dao-tu/">
        </link>
        <updated>2021-03-07T11:20:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据模型">数据模型</h2>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615116032962.png" alt="" loading="lazy"></figure>
<h2 id="数据库管理系统dbms">数据库管理系统DBMS</h2>
<figure data-type="image" tabindex="2"><img src="https://wangyingying625.github.io/post-images/1615129998237.png" alt="" loading="lazy"></figure>
<h2 id="关系数据库设计">关系数据库设计</h2>
<figure data-type="image" tabindex="3"><img src="https://wangyingying625.github.io/post-images/1615130073999.png" alt="" loading="lazy"></figure>
<h2 id="数据库安全性">数据库安全性</h2>
<figure data-type="image" tabindex="4"><img src="https://wangyingying625.github.io/post-images/1615182369785.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库问题]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-wen-ti/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-wen-ti/">
        </link>
        <updated>2021-03-07T09:16:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是数据库">什么是数据库?</h3>
<p>答:从本质上看,数据库就是信息的集合,这个集合能长期保存,可以共享并且有一定的数据结构</p>
<h3 id="什么是数据">什么是数据?</h3>
<p>答:数据是数据库中存储的基本对象.</p>
<h3 id="什么是数据库系统">什么是数据库系统:</h3>
<p>数据库系统是有数据库,数据,数据库管理系统和数据库管理员组成的系统</p>
<h3 id="什么是数据库管理系统dbms">什么是数据库管理系统(DBMS):</h3>
<h3 id="dbms有什么功能">DBMS有什么功能:</h3>
<ol>
<li>允许用户使用数据定义语言(DDL)建立新的数据库并定义它的模式(逻辑结构)</li>
<li>允许使用数据库操作语言(DML)和查询语言(QL)为用户提供查询和更新数据库的接口</li>
<li>控制多个用户的存取,一个用户对数据库的操作不影响另一个用户</li>
<li>支持大量数据的长期存储</li>
<li>在面对故障时能有恢复数据库的能力</li>
</ol>
<h3 id="dbms的功能要求dbms具备哪些结构">DBMS的功能要求DBMS具备哪些结构:</h3>
<ol>
<li>语法分析器:对用户提交的SQL语句进行语法分析</li>
<li>授权检查:检查尝试执行SQL语句的用户是否有权限执行它</li>
<li>查询分析和查询处理</li>
<li>访问管理:解决如何把表存储成磁盘中的文件流</li>
</ol>
<h3 id="什么是数据模型">什么是数据模型</h3>
<p>用来描述数据或者是信息的标记,一般由三部分组成</p>
<ol>
<li>数据结构</li>
<li>数据操作</li>
<li>完整性约束条件</li>
</ol>
<h3 id="关系数据模型有什么特点">关系数据模型有什么特点:</h3>
<p>关系数据模型把现实中的实体和实体间的联系都抽象成关系,即表.对关系操作的内容和结果都是表</p>
<h3 id="sql中的三种关系">SQL中的三种关系:</h3>
<ol>
<li>表:在物理磁盘中存储</li>
<li>视图:虚表,不在物理磁盘中存储其内容,只在数据库中存储其定义,需要内容时通过数据库中的表根据用户的需求映射</li>
<li>临时表:不在数据库中存储其内容也不在数据库中存储其定义,由SQL语句临时构造,在SQL语句执行完之后就被删除</li>
</ol>
<h3 id="如何建立一个关系型数据库">如何建立一个关系型数据库:</h3>
<p>建立数据库需要回答:存储什么信息;信息元素之间如何关联;需要有什么样的约束</p>
<ol>
<li>需求分析:考察数据库中可能涉及到的数据以及数据的特征,建立数据字典</li>
<li>概念设计:抽象实体,建立实体间联系,画出E-R图</li>
<li>逻辑设计:把E-R图转化为表</li>
<li>物理设计:设计数据库的存储结构及访问方法.考虑文件的存储形式和索引的建立.</li>
</ol>
<h3 id="什么是事务">什么是事务</h3>
<p>事务是对数据库操作的基本单位,本质上是一组SQL语句;<br>
事务具有原子性,原子性指的是SQL语句要么全部执行,要么一句也不执行<br>
事务具有一致性:数据库的一个状态经过一个事务运行到另外一个状态<br>
事务具有隔离性:并发执行的多个事务间互不干扰<br>
事务具有持久性:一个事务若成功执行,那它对数据库的影响就是永久的</p>
<p>引入事务的作用有:</p>
<ol>
<li>数据库异常时的恢复(根据数据库的更新策略不同采取的具体措施也不同,commit列表和active列表)</li>
<li>提供事务回滚,能让数据库从一个状态运行到另一个状态</li>
<li>多应用程序并发访问数据库时为这些程序提供隔离方法(加锁,两段锁协议能避免多用户并发访问数据库时发生冲突即事务可串行调度,加锁又可能让系统死锁,死锁的预防策略是一次封锁,等待死亡)</li>
</ol>
<h3 id="什么是死锁什么是活锁">什么是死锁,什么是活锁</h3>
<p>死锁:A申请B占有的排他锁;B也申请A占有的排他锁,导致两个事务都无法推进下去的情况<br>
活锁:A申请B占有的排他锁,B释放锁后给了C...A长期得不到锁</p>
<h3 id="预防死锁的策略">预防死锁的策略:</h3>
<ol>
<li>一次封锁发:任何事务执行前要求它获得所有需要的锁,如果不能获得全部需要的锁就不执行</li>
<li>等待死亡法:为每个事务增加一个时间戳属性,当事务A申请事务B的锁时,比较时间戳,若A比B年轻,事务A回滚,等待某一随机时间再用之前的时间戳申请;若A比B年老,事务A等待事务B释放锁</li>
</ol>
<h3 id="dbms查询优化的策略">DBMS查询优化的策略:</h3>
<ol>
<li>代数优化:DBMS对SQL语句形成的操作树进行处理:在查询结果不变的情况下尽量把一元操作往操作树的叶子部位压</li>
<li>操作优化:用最优的方式执行基本操作,最主要的是连接操作<br>
对连接操作的优化策略有:连接操作时每次从磁盘中取一个块的元组放进缓冲区,对被连接属性的比较在内存中计算,从而减少IO次数,减少连接操作耗时,本质上是用空间换时间.<br>
对连接属性添加B+树索引,有索引的表用做内循环,减少对连接属性的比较时间<br>
对连接属性按照hash映射存储,这样连接属性值相同的就在同一个hash块里,同样增加了对连接属性的比较时间</li>
</ol>
<h3 id="事务对数据库的更新策略有哪些">事务对数据库的更新策略有哪些</h3>
<ol>
<li>更改直接写进数据库:<br>
创建事务-&gt;将事务id写入active列表-&gt;把旧数据记入log-&gt;新数据把旧数据覆盖-&gt;事务id写入commit列表-&gt;事务id从active列表中删除<br>
重启动检查时,若发现事务id只在active列表中出现,那么对该事务进行undo(撤销)操作,回滚事务,然后从active列表删除其id;若事务id在active和commit列表都出现,说明该事务已经对数据库进行了修改,只是还没来得及从commit中删除其id就出了故障,那么只需从commit中删除其id;若只在commit中发现事务id证明事务已经顺利执行完,不做任何事.</li>
<li>更改在commit时写进数据库:<br>
创建事务-&gt;将事务id写入active列表-&gt;把新数据写入log-&gt;当数据写完需要commit时事务id写入commit-&gt;把log中数据写进数据库-&gt;事务id从active中删除<br>
重启检查时,若发现事务id只在active中,在active列表中删除其id<br>
若发现事务id在commit和active中,redo<br>
只在commit中找到,nothing to do</li>
<li>再新建一个进程,一旦磁盘空闲时,这个进程就开始搬数据<br>
创建事务-&gt;把其id写入active列表-&gt;把新数据写入log-&gt;同时如果磁盘空闲,同时把新数据写入数据库-&gt;事务id写入commit列表-&gt;commit事务前检查是否所有需要更爱的数据全部写入数据库-&gt;从active列表删除事务id<br>
重启检查时,若发现事务id只在active列表,undo并且删除active列表中的id<br>
若事务id同时出现在commit列表和active列表,redo<br>
事务id只在commit中,nothing to do</li>
</ol>
<h3 id="多事务并发时候可能会产生冲突这些冲突可能会造成什么影响">多事务并发时候可能会产生冲突,这些冲突可能会造成什么影响:</h3>
<ol>
<li>读写冲突--读脏数据:事务A改了数据1后事务B去读数据1,在事务B读完之后事务A执行异常回滚事务,导致事务B读取到了脏数据</li>
<li>读写冲突--不可重复读:事务A读完数据1后事务B对数据1进行了更改,事务A再次读数据1时和上次读到的不一致</li>
<li>写写冲突--丢失更新:事务A写了数据1还没来得及存回数据库时,事务B读取了数据1,也对其进行修改</li>
</ol>
<h3 id="如何解决这些冲突带来的影响如何让事务间的执行可串行化">如何解决这些冲突带来的影响(如何让事务间的执行可串行化):</h3>
<p>可串行化调度:计算机对并发执行事务的调度是随机的,在计算机中多个并发执行事务的结果是正确的当且仅当它的结果与按某一次序顺序执行时候的结果相同.<br>
加锁:</p>
<ol>
<li>X锁:X锁是排他锁,当对某一数据加了X锁之后其他事务无法再向该数据加锁</li>
<li>X+S锁:X锁排他,S锁不排他.当对某一数据加了S锁时,允许其他事务再对该数据加S锁,但不允许加X锁<br>
加了X锁的数据不允许其他事务对它加任何锁</li>
<li>X+S+U锁:U锁是考虑到对数据库的更改也分为读数据库和写数据库两步,当用户要修改数据库时先申请U锁,加了U锁的数据允许再加S锁,但不允许再加U和X锁</li>
</ol>
<h3 id="两段锁协议">两段锁协议:</h3>
<p>事务分为两个阶段:第一个阶段获得锁,在这个阶段事务可以申请获得任何数据上的任何锁<br>
第二个阶段是释放锁,在这个阶段事务不能再申请任何锁,只能释放锁<br>
若并发事务都遵守两段锁协议则对这些事务的任何并发调度都是可串行化的(是可串行化的策略,并不是避免死锁的)</p>
<h3 id="对数据库的安全性控制有哪些措施">对数据库的安全性控制有哪些措施:</h3>
<ol>
<li>用户身份鉴别:为用户设置密码</li>
<li>访问控制:对用户进行授权</li>
<li>数据加密:对敏感数据加密存储</li>
<li>审计追踪:对关键属性添加审计指令,这些数据就会被监视,当有操作在这些数据上时就会记录</li>
</ol>
<h3 id="为数据库定义约束的方法">为数据库定义约束的方法:</h3>
<ol>
<li>用断言定义: ASSERT ageRe on user:age&gt;0</li>
<li>定义表时用check子句:CREATE TABLE user(id INT,name VARCHAR(10),age INT)CHECK (age&gt;0)</li>
</ol>
<h3 id="常用的聚集函数">常用的聚集函数:</h3>
<ol>
<li>AVG</li>
<li>MIN</li>
<li>MAX</li>
<li>COUNT</li>
<li>SUM</li>
</ol>
<h3 id="group-by使用时的要求">GROUP BY使用时的要求:</h3>
<p>在select指定的字段要么要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中</p>
<h3 id="数据库设计中的各范式及其要求">数据库设计中的各范式及其要求:</h3>
<ol>
<li>1NF:强调列的原子性,即要求不能大表套小表</li>
<li>2NF:1NF+必须有主键+非主键的属性必须完全依赖于主键不能部分依赖</li>
<li>3NF:2NF+非主键必须直接依赖于主键不能传递依赖</li>
<li>BCNF:3NF+若属性A能决定属性B要求属性A必须是主键</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库设计]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-she-ji/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-she-ji/">
        </link>
        <updated>2021-03-07T03:34:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念:</h2>
<h3 id="函数依赖">函数依赖:</h3>
<p>数据库中一个属性的值可以决定其他属性的一个值(id决定名字)</p>
<h3 id="多值依赖">多值依赖:</h3>
<p>一个属性的值可以决定其他属性的一组值(老师的id 决定所上课程)</p>
<h3 id="连接依赖">连接依赖:</h3>
<h2 id="范式">范式:</h2>
<h3 id="1nf不允许大表套小表">1NF:不允许大表套小表</h3>
<h3 id="2nf1nf属性中没有任何元素对主键有部分函数依赖">2NF:1NF+属性中没有任何元素对主键有部分函数依赖</h3>
<p>student(sid,sname,sage,cid,cgrade)<br>
其中主键是(sid,cid),因为成绩cgrade只能由sid+cid唯一决定<br>
但是sname可仅仅用sid决定,即sname,sage对主键存在部分函数依赖</p>
<h4 id="不满足的影响">不满足的影响</h4>
<ol>
<li>插入异常:要插入学生就得插入课程</li>
<li>删除异常:如果学生的所有课需要删除,那么学生信息将被删除</li>
<li>更新异常:学生有五门课程,那么他的基本信息就需要插入五次</li>
</ol>
<h4 id="解决办法">解决办法:</h4>
<p>拆表,一张表只关注一个实体</p>
<h3 id="3nf2nf属性之间无传递依赖">3NF:2NF+属性之间无传递依赖</h3>
<p>1NF消除属性对主键的部分函数依赖-&gt;2NF消除属性间的传递依赖-&gt;3NF<br>
emp(eid,elevel,emoney)<br>
其中工资emoney依赖于elevel<br>
elevel依赖于eid<br>
之间存在传递依赖</p>
<h4 id="不满足的影响-2">不满足的影响:</h4>
<ol>
<li>插入异常:员工级别无法确定时候级别对应的工资无法录入</li>
<li>删除异常:三级的员工都被删掉后,对应的工资状况也就被删了</li>
<li>更新异常:三级的人有五个,则三级对应的工资信息就被重复五次,维护困难</li>
</ol>
<h3 id="bcnf">BCNF:</h3>
<p>A-&gt;B则要求A一定是主键(B函数依赖于A时,要求A一定是主键)</p>
<h4 id="解决办法-2">解决办法:</h4>
<p>拆表<br>
##数据库设计:</p>
<h3 id="面向过程的方法以业务流程为中心不分析数据之间的内在关系">面向过程的方法:以业务流程为中心,不分析数据之间的内在关系</h3>
<h3 id="面向数据的方法">面向数据的方法:</h3>
<h4 id="设计流程">设计流程:</h4>
<ol>
<li>需求分析:数据字典</li>
<li>概念设计:E-R图,独立于DBMS.抽象实体-&gt;定义实体间联系-&gt;画E-R图</li>
<li>逻辑设计:外模式设计,数据类型设计.建表,把E-R图生成表(命名规则,数据类型),必要时定义视图</li>
<li>物理设计:索引,文件结构(堆文件,簇集,hash文件)分区设计(大型数据库才有)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库安全及完整性约束]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-an-quan/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-an-quan/">
        </link>
        <updated>2021-03-06T13:42:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用手段">常用手段:</h2>
<h3 id="访问授权">访问授权</h3>
<h4 id="dba创建新用户并对新用户进行访问数据库的基本授权">DBA创建新用户并对新用户进行访问数据库的基本授权</h4>
<ol>
<li>
<p>对用户授权<br>
<code>SQL GRANT CONNECT TO WANGMING IDENTIFIED BY 123456;</code><br>
wangming用户可以用初始密码123456连接数据库<br>
<code>SQL GRANT SELECT ON TABLE USER TO WANGMING WITH GRANT OPTION</code><br>
用户WANGMING有查询user表的权利,并且可以把这个权利转售给其他人(WITH GRANT OPTION)</p>
</li>
<li>
<p>创建角色,然后为某用户直接给角色</p>
</li>
</ol>
<h3 id="数据加密">数据加密:</h3>
<p>对数据库的访问需要通过DBMS,不能直接在操作系统层访问<br>
对数据加密后存储进数据库</p>
<h3 id="审计追踪">审计追踪:</h3>
<p>由于不能保证数据库一定安全,设计审计追踪环节.<br>
在关注的数据上面添加审计指令,对所监视的表任何指令记录.</p>
<h3 id="完整性约束">完整性约束:</h3>
<p>对数据库中一些属性的约束条件(数据库中合法的实例必须满足这个要求)</p>
<h4 id="静态约束">静态约束:</h4>
<ol>
<li>
<p>数据模型固有的约束(1NF),关系模型要求的</p>
</li>
<li>
<p>隐含约束:<br>
如域完整性约束;<br>
主键约束(实体完整性约束);<br>
外键约束(引用完整性约束):若buy表中UID是user中ID的外键,则要求UID是ID的子集;删除时候级联删除或者不删;插入时候buy表中的UID必须在user中的id里存在</p>
</li>
<li>
<p>显示约束:<br>
定义方法一:用断言<br>
<code>SQL ASSERT ageRe ON user:age&gt;0;</code><br>
ageRe是我对断言取得名字,ageRe要求对user插入数据时候age必须&gt;0</p>
<p>定义方法二:定义表时用check<br>
<code>SQL CREATE TABLE user (id INTEGER, name CHAR(10), age INTEGER, rating INTEGER, PRIMARY KEY(id,name), CHECK (age&gt;0 AND rating&gt;0))</code><br>
定义方法三:定义CONSTRAINT<br>
<code>SQL CREATE TABLE buy (tname CHAR(10), tid INTEGER, uid INTEGER, day DATE, PRIMARY KEY(tid,day), CONSTRAINT noFood CHECK('food' &lt;&gt; (SELECT T.name FROM thing T WHERE T.id=tid)))</code><br>
定义了一个包含关联查询的约束noFood,其含义为当thing中name是food时候不允许其插入buy</p>
</li>
</ol>
<h4 id="动态约束">动态约束:</h4>
<p>数据库从一个状态到另一个状态时应该满足的约束(与触发器结合)</p>
<h5 id="触发器">触发器:</h5>
<p>数据库状态发生变化时应该遵守的规则<br>
数据库一般是被动执行某些SQL语句,然而我们希望当数据库中数据处于某一状态时数据能主动的发出一些动作.这就需要数据库去监视一些数据.支持触发器即支持ECA规则</p>
<h6 id="基本概念">基本概念:</h6>
<ol>
<li>事件E监视某一事件</li>
<li>条件C事件发生时是否满足条件</li>
<li>动作A若满足采取行动</li>
</ol>
<h6 id="基本语法">基本语法</h6>
<p>每当在user表里插入一条消息时候去查看其年龄是否满足年轻用户的条件,如果满足同时加入年轻用户表(保证在年轻用户表里的用户都在用户表)<br>
<code>SQL CREATE TRIGGER youngUser AFTER INSERT ON user REFERENCING NEW TABLE newUser FOR EACH STATEMENT INSERT INTO youngUser (id,name,age,rating) SELECT id,name,age,rating FROM newUser N WHERE N.age &lt;= 18</code><br>
AFTER BEFORE 都是监听的事件,以上是监听插入user表时候触发.<br>
REFERENCING NEW表示引用的是插入语句中的新值(也可用OLD)TABLE表示新插入的值被看作一张表并且为其取名newUser.整句含义为,对user表中新插入的语句我看作一张新表newUser,并且使用它的新值.<br>
FOR EACH STATEMENT 表示对每一条插入的语句(操作粒度也可以是一条元组,一个值或者一个表)做操作</p>
<h6 id="执行规则">执行规则:</h6>
<p>立即执行:当事件发生时候立即去检查是否满足条件</p>
<h6 id="连锁触发">连锁触发:</h6>
<p>当发生某个事件并满足条件导致触发触发器时候,被触发的语句也是SQL语句,SQL语句也可能触发其他的触发器,导致连锁触发<br>
方案:限制连锁触发的次数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库管理系统(DBMS)]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-guan-li-xi-tong-dbms/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-guan-li-xi-tong-dbms/">
        </link>
        <updated>2021-03-05T11:20:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据库管理系统的体系结构">数据库管理系统的体系结构:</h2>
<h3 id="dbms组成结构把用户的sql落实到对磁盘的操作">DBMS组成结构:(把用户的SQL落实到对磁盘的操作)</h3>
<ol>
<li>语法分析器:对用户提交的SQL语句进行语法分析</li>
<li>授权检查:检查某用户是否有权限执行该语句</li>
<li>语义分析和查询处理</li>
<li>访问管理:如何把表存储为磁盘中的文件流(实现关系模型,为上层提供表)<br>
因为其在最底层,所以这层提供的函数就是访问原语,实现关系模型的基本概念</li>
</ol>
<h3 id="文件存储类型">文件存储类型:</h3>
<ol>
<li>堆文件:只能顺序查询</li>
<li>哈希文件:如果用户经常按照某属性查询,则对该属性做哈希,哈希值就是存储地址</li>
<li>堆文件和B+树索引(有用节点都在叶子节点,中间节点都是路标):索引可以在不同属性上建多个</li>
</ol>
<h3 id="数据库系统中对底层操作系统的访问类型">数据库系统中对底层操作系统的访问类型:</h3>
<ol>
<li>查询大多数元组:堆文件</li>
<li>查询某个范围元组:B+树叶子节点的范围</li>
<li>查询某个特定元组:B+树</li>
</ol>
<h3 id="关系型数据库常用索引方式">关系型数据库常用索引方式:</h3>
<ol>
<li>B+树</li>
<li>簇集:向操作系统申请一块连续的内存空间,按照某个属性递增或者递减存储元组(要求该属性更新少)</li>
</ol>
<h3 id="编程语言中使用数据库的流程">编程语言中使用数据库的流程:</h3>
<p>连接数据库:向系统请求一个DBMS核心进程,建立一个通讯管道,应用与数据库管理系统间通过管道进行通信(两个pipe,一写一读)<br>
应用程序-----------------------------&gt;DBMS核心进程(发SQL)<br>
应用程序&lt;-----------------------------DBMS核心进程(返回结果)<br>
属于同一个进程空间的线程可以共享进程资源</p>
<h2 id="数据库管理系统的接口">数据库管理系统的接口:</h2>
<h2 id="查询优化">查询优化:</h2>
<h3 id="代数优化把用户提交的sql语句在执行结果不变的情况下转换为执行效率更高的模式">代数优化:把用户提交的SQL语句在执行结果不变的情况下转换为执行效率更高的模式</h3>
<p>相当于把  x²+xy+y²优化为(x+y)²;<br>
DBMS首先把SQL语句解析为关系操作树,然后对操作树中的操作进行转化<br>
对关系运算顺序和结构进行调整,尽量减小二元操作的被操作规模(即尽量使一元操作处于树的叶子部分或离叶子最近的部分)类似于哈弗曼树(代价最小的往树叶子方向放)<br>
基本原则:</p>
<ol>
<li>符合等价条件的基础上,尽可能使一元操作接近树的叶子</li>
<li>寻找合并多次使用的公共子表达式</li>
</ol>
<h3 id="操作优化找最有效的方法实现操作关键是连接操作">操作优化:找最有效的方法实现操作(关键是连接操作)</h3>
<p>对已经经过代数优化优化过的查询树上的操作进行优化,关键在于连接操作的优化<br>
连接操作:有两张表分别命名A和B,A与B有一列表示含义相同,当这一列中的值相等时,把A和B中的信息拼接</p>
<ol>
<li>嵌套循环(最基本的实现):遍历A表(A表做外循环),对每一条去扫描B一次,查询其对应属性是否相等,若相等则拼接</li>
<li>减少IO时间(用内存空间换时间):由于对磁盘进行一次IO操作读取到的是一个物理块,则对外循环取一个物理块进内存,内循环也分别取一个物理块进内存,然后在内存(缓冲区)里对每一个物理块的众多元组进行比较.<br>
效果:若一个物理块能放十条元组,则外循环减少1/10,外循环减少到1/100,共减少1/100</li>
<li>归并扫描:参与连接的两个关系按照各自连接属性的值在磁盘上做好外排序,只需要对内外表各扫描一次</li>
<li>在连接属性上建立B+树索引:让有索引的表用作内循环的表</li>
<li>利用hash文件:要求连接属性上很少有更新.把关系A与关系B分别按照连接属性散列到一个hash文件,则能够散列的元组分别在两个表的同一个hash值块内.</li>
<li>适用于用索引并不高效的情况(当一个值在元组中出现的次数过多时候):此时用B+树或者hash索引到的结果有好多个,再去磁盘中多次取这些值效率反而不如直接顺序扫描高</li>
</ol>
<h2 id="事务管理">事务管理:</h2>
<h3 id="事务transaction对数据库的基本操作单位">事务(transaction):对数据库的基本操作单位</h3>
<p>是对数据库一组基础操作的集合(一组SQL语句)满足如下性质(ACID):</p>
<ol>
<li>原子性:这些SQL语句要么全部执行成功,要么一条也不做</li>
<li>一致性:从数据库的一个一致状态经过一个事务的运行达到另外一个一致状态</li>
<li>隔离性:在一个多用户的数据库系统里有很多并发事务在同时运行,要求并发的事务之间不能互相干扰,让每个人感觉像是独占数据库一样.(操作系统的分时系统,仿佛每个进程独占CPU.Windows系统中一个进程故障有时候会引起整个系统卡死;电脑不能长期不关机等都是由于进程间隔离不够好.)</li>
<li>持久性:一个事务只要完成,它对数据库产生的影响应该长久反映在数据库里,即使出现故障也必须是可以恢复的</li>
</ol>
<p>实现机制:<br>
有两个事务列表:commit列表和active列表.其中active列表存放正在进行的事务,commit列表存放已经执行完的事务<br>
事务作用:</p>
<ol>
<li>回滚rollback:如果回滚,则这个事务对数据库产生不了任何的影响.转账过程定义成事务</li>
<li>提交commit:事务正常终止,</li>
</ol>
<p>如果不显式定义事务,系统默认把一条SQL语句当做一个事务</p>
<h3 id="恢复">恢复:</h3>
<h4 id="减少出故障的可能性防">减少出故障的可能性(防):</h4>
<h4 id="从故障中恢复治">从故障中恢复(治):</h4>
<h5 id="基本方法">基本方法:</h5>
<ol>
<li>长时间进行定时数据库备份(dumping)</li>
<li>短时间进行增量转储(只对数据库中变化部分进行记录)   可能会丢失部分更新</li>
<li>备份+日志:日志是对自从上次备份数据库以来用户对数据库的全部操作的记录---&gt;change的old value(BI)和new value(AI);当故障时候通过备份恢复数据库,然后使用日志文件对恢复的数据库进行操作,恢复到离故障最近的位置.对发生故障时候进行到一半的操作能恢复到之前状态(old value),已经进行完的恢复到(new value)</li>
</ol>
<h5 id="更新策略">更新策略:</h5>
<h6 id="对数据的更改直接写入数据库">对数据的更改直接写入数据库:</h6>
<ol>
<li>流程:<br>
创建事务并把事务id写入active列表-&gt;把旧数据计入log-&gt;用新的数据覆盖数据库中的旧数据-&gt;事务id写入commit列表-&gt;从active中删除事务id</li>
<li>恢复:(可能undo)<br>
重启动恢复模块:在每次数据库启动时候去检查上一次操作结果.对数据库系统中曾经运行过的每个事务id检查两张事务列表:<br>
若发现某事务id只在active列表未在commit列表说明这个事务是进行一半的事务,对其结果进行还原(undo),然后从active列表中删除其id.<br>
若某事务的id在两个列表都查到了意味着该事务对数据库的操作已经完成,只是还没来得及从active列表中删除自己的id就出现故障,那么就帮它在active中删掉其id<br>
若在commit中找到在active中未找到,nothing to do.<br>
然而从事务运行开始会有成千上万的事务,总不能让数据库系统每次打开时候都去从头开始检查他们吧,为此,提出来检查点(check point)的概念,有了检查点,数据库系统只需检查从上个检查点处之后的事务进行检查</li>
</ol>
<h6 id="等事务进行到commit阶段时候再去更新数据库在这之前不改数据库只改log并发度更高加排他锁的时间可以更靠后ux锁">等事务进行到commit阶段时候再去更新数据库,在这之前不改数据库只改log(并发度更高,加排他锁的时间可以更靠后)(UX锁)</h6>
<ol>
<li>流程:<br>
创建事务并把其id写入active列表-&gt;把新数据写入log-&gt;当把所有要更新的数据都写入log时(遇到commit语句)把新数据放入数据库-&gt;从active中删除事务id</li>
<li>恢复:(可能redo)<br>
对从上个检查点以来的事务去查两张事务id列表:<br>
在active列表找到commit未找到:从active中删掉id<br>
在两个列表都找到:redo该事务<br>
只在commit列表找到:nothing to do</li>
</ol>
<h6 id="同时并发进行">同时并发进行</h6>
<ol>
<li>流程:<br>
创建事务并把其id写入active列表-&gt;新数据与旧数据都写入log-&gt;同时如果磁盘空闲则同步进行新数据写入数据库的进程-&gt;事务id写入commit列表-&gt;当新旧数据写入log的操作执行完毕时候再去检查是否所有新数据都写入了数据库-&gt;从commit列表删除事务id</li>
<li>恢复:(可能undo也可能redo)<br>
active中有id:undo,并且从active中删除其id<br>
两张表中都查到:redo,从active中删除其id<br>
只在nothing中查到:nothing to do</li>
</ol>
<h3 id="多事务并发控制并发事务的可串行化">多事务并发控制(并发事务的可串行化):</h3>
<p>要求两个并发执行的事务对数据库产生的结果不因事务调度次序的不同而不同,即结果和一系列事务按某一特定顺序执行的结果一致.</p>
<h4 id="产生条件">产生条件:</h4>
<ol>
<li>改善系统利用率</li>
<li>不同的事务可能访问数据库的不同部分(两事物间可能没有冲突)</li>
</ol>
<h4 id="事务冲突当两个或者以上事务同时对同一部分处理时">事务冲突(当两个或者以上事务同时对同一部分处理时):</h4>
<h5 id="可能影响">可能影响:</h5>
<ol>
<li>丢失更新(写写冲突)<br>
<img src="https://wangyingying625.github.io/post-images/1615031827200.png" alt="" loading="lazy"><br>
如图所示,丢掉T1对数据的更改</li>
<li>读脏数据(读写冲突)<br>
<img src="https://wangyingying625.github.io/post-images/1615032143699.png" alt="" loading="lazy"><br>
T2读到T1正在改的脏数据</li>
<li>不可重复读(读写冲突)<br>
<img src="https://wangyingying625.github.io/post-images/1615032347784.png" alt="" loading="lazy"><br>
T1连续两次读的值不一样</li>
</ol>
<h5 id="解决方案">解决方案:</h5>
<p>可串行化:多个事务的调度次序无论是什么样都不改变最终结果<br>
<img src="https://wangyingying625.github.io/post-images/1615032951751.png" alt="" loading="lazy"><br>
如图:T1和T2在X2上有冲突;T2和T3在X1上有冲突</p>
<h6 id="加锁">加锁:</h6>
<p>要求每个事务对数据库中的数据读写操作时候需申请锁,并发执行的结果到底等于怎样的次序执行的序列完全取决于哪个事务先抢到锁<br>
####### 两段锁协议:</p>
<ol>
<li>申请要求<br>
-----------------------------------|某没有锁的数据|有X锁的数据<br>
没有锁的事务申请-----------|----允许------------|---允许<br>
有X锁的事务申请------------|----允许------------|---不允许<br>
X锁排他,一个数据有事务申请了他的X锁时候不允许别的事务申请</li>
<li>版本变化:<br>
两段加锁协议:2PL+serializable+well-fromed<br>
<img src="https://wangyingying625.github.io/post-images/1615034491383.png" alt="" loading="lazy"><br>
即某一事务只在某一阶段申请锁,另一阶段只释放锁,一旦释放再不申请新锁<br>
仍然会有rollback时候产生多米诺效应的读脏数据<br>
原因在于过早释放写锁<br>
推迟修改锁的释放:<br>
在事务commit时候再释放修改锁<br>
所有锁都在commit时候释放(严格的两段锁)<br>
####### (S,X)锁协议:<br>
排他锁和共享锁,事务如果只读申请S(共享)锁,如果有更新申请X(排他)锁</li>
<li>申请要求<br>
-----------------------------------|某没有锁的数据|有S锁的数据|有X锁的数据<br>
没有锁的事务申请----------|----允许------------|---允许----------|允许<br>
有S锁的事务申请------------|----允许------------|---允许---------|不允许<br>
有X锁的事务申请------------|----允许------------|----不允许-----|不允许<br>
X锁排他,只要申请的数据之前有锁那就申请不到;比起上个版本读效率更高<br>
####### (S,U,X)锁<br>
写数据时候是先申请数据,再改,为了缩短排他锁的时间增加U锁<br>
当更新数据时候先申请U锁真正改数据时候才把U锁换为X锁</li>
<li>申请要求(相容矩阵)<br>
-----------------------------------|某没有锁的数据|有S锁的数据|有U锁的数据|有X锁的数据<br>
没有锁的事务申请----------|----允许------------|---允许----------|----允许-------|允许<br>
有S锁的事务申请------------|----允许------------|---允许---------|----允许--------|不允许<br>
有U锁的事务申请------------|----允许------------|----允许-------|------不允许----|不允许<br>
有X锁的事务申请------------|----允许------------|----不允许-----|-----不允许----|不允许</li>
</ol>
<h6 id="死锁">死锁:</h6>
<p>只要事务等待某一锁的时间超过一个限定那就认为产生了死锁<br>
解决办法:<br>
为每个事务建立一个时间戳</p>
<ol>
<li>等待死亡法:<br>
T1若想要申请一个锁,但是此锁被T2占有,则T1比较它与T2的时间戳,谁更老,如果它更老就等待T2释放锁,否则就回滚自己,等一个随机事件再次申请(时间戳不改还是上次的)<br>
采用这种方法,等待关系只可能是年老的等年轻的,方向是单向的;并且由于比该事务年老的事务总是有限的所以它总能等到想要的锁</li>
<li>被伤等待法:<br>
遇到比自己年老的就会被人家kill</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker使用笔记]]></title>
        <id>https://wangyingying625.github.io/post/docker-shi-yong-bi-ji/</id>
        <link href="https://wangyingying625.github.io/post/docker-shi-yong-bi-ji/">
        </link>
        <updated>2021-03-05T03:12:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用命令">常用命令</h2>
<ol>
<li>查找容器id:docker ps</li>
<li>启动docker-compose:docker-compose up -d</li>
<li>进入容器:</li>
<li>docker images</li>
</ol>
<h2 id="零碎知识">零碎知识</h2>
<ol>
<li>docker不用进文件夹</li>
<li>docker-compose需要进文件夹</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语言]]></title>
        <id>https://wangyingying625.github.io/post/sql-yu-yan/</id>
        <link href="https://wangyingying625.github.io/post/sql-yu-yan/">
        </link>
        <updated>2021-03-04T11:48:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="sql语言一种非过程化的关系演算语言">SQL语言(一种非过程化的关系演算语言):</h1>
<h2 id="常用名词">常用名词</h2>
<ol>
<li>基表:存在于物理磁盘内的一张表</li>
<li>视图:虚表,根据用户的需要映射出的表,并不真正存在于物理磁盘</li>
<li>保留字:<br>
NULL:空值<br>
UNIQUE:说明表的某一属性值是否允许重复<br>
DEFAUIT:为某一属性指定缺省值<br>
PRIMARY KEY:用来指定某一属性为主键<br>
FOREIGN KEY:用来指明某一属性是外键<br>
CHECK:定义表时为某一属性进行检查是否符合某要求</li>
</ol>
<h2 id="sql的四种子语言">SQL的四种子语言:</h2>
<ol>
<li>DDL:(Data Definition Language):用来定义删除维护数据模式(表的创建与删除,视图的创建与删除,修改表的模式),多用图形化工具操作</li>
<li>QL(Query Language):查询语言,对数据库里的数据进行查询,查询出满足条件的数据</li>
<li>DML(Data Manipulation Language):数据操作语言,对数据库里已经存在的数据进行增删改</li>
<li>DCL(Data Control Language):管理数据库的用户权限(授权,创建用户,完整性约束,审计)</li>
</ol>
<h2 id="sql语言的基本模式">SQL语言的基本模式</h2>
<p>SELECT [DISTINCT] 目标列 FROM 表名 WHERE 查询条件 GROUP BY 分组属性 HAVING 分组条件</p>
<h2 id="sql语言的执行策略">SQL语言的执行策略:</h2>
<ol>
<li>根据FROM后的表名做笛卡尔乘积得到表A</li>
<li>用WHERE后面的条件对表A进行筛选得到符合条件的表B</li>
<li>对表B中的信息按照GROUP BY后的分组属性分组,对属性相同的元组分成一组</li>
<li>对分好组的表按照HAVING后的分组条件再次筛选,筛选出符合条件的组</li>
<li>在选好的组中根据SELECT后的信息进行投影,每个组出一条元组<br>
SELECT的属性和HAVING属性必须是分组属性集的子集</li>
</ol>
<p><img src="https://wangyingying625.github.io/post-images/1614835018824.png" alt="" loading="lazy"><br>
表名为table1,其中id自增为主键<br>
<img src="https://wangyingying625.github.io/post-images/1614835029464.png" alt="" loading="lazy"><br>
表名为shop,其中id自增为主键</p>
<p>执行SQL语句:<br>
<code>SQL SELECT T.name FROM table1 T,shop S WHERE T.id=S.id</code><br>
执行结果如下图:<br>
<img src="https://wangyingying625.github.io/post-images/1614835041033.png" alt="" loading="lazy"></p>
<h2 id="ql语言">QL语言</h2>
<h3 id="模糊查询like">模糊查询like:</h3>
<ol>
<li>_(下划线)表示匹配任意字符</li>
<li>%表示匹配任意0 到多个字符<br>
<code>SQL SELECT T.name FROM table1 T WHERE T.name LIKE 'w_%i'</code><br>
执行结果如下图:<br>
<img src="https://wangyingying625.github.io/post-images/1614835904286.png" alt="" loading="lazy"></li>
</ol>
<h3 id="起别名as">起别名AS:</h3>
<p><code>SQL SELECT T.id+1 AS id1 FROM table1 T WHERE T.name LIKE 'w_%i'</code><br>
结果如下<br>
<img src="https://wangyingying625.github.io/post-images/1614836268735.png" alt="" loading="lazy"></p>
<h3 id="连接union">连接UNION:</h3>
<p>union是关系代数中的并(∪)操作扩展而来的,所以要满足并操作的条件<br>
并操作:把两个关系模式相同的元组组合<br>
即要求UNION前后两句sql查询到的表列数相同<br>
<code>SQL SELECT name FROM table1 WHERE id=1 UNION SELECT number FROM shop WHERE name='food'</code><br>
结果如下<br>
<img src="https://wangyingying625.github.io/post-images/1614836988247.png" alt="" loading="lazy"></p>
<h3 id="自连接">自连接:</h3>
<p>新建一张购买表buy,信息如下:<br>
<img src="https://wangyingying625.github.io/post-images/1614838025350.png" alt="" loading="lazy"><br>
若要查询既买了food又买了cloth的用户名<br>
<code>SQL SELECT T.name FROM table1 T,buy B1,buy B2 WHERE B1.uid=B2.uid AND (B1.sid=1 AND B2.sid=2) AND T.id=B1.uid</code><br>
<img src="https://wangyingying625.github.io/post-images/1614838719827.png" alt="" loading="lazy"></p>
<h3 id="交intersect部分数据库支持">交INTERSECT(部分数据库支持):</h3>
<p>实现查询既买了food又买了cloth的用户名<br>
<code>SQL SELECT T.name FROM table1 T,buy B WHERE B.uid=T.id AND B.sid=1 INTERSECT SELECT T.name FROM table1 T,buy B WHERE B.uid=T.id AND B.sid=2</code></p>
<h3 id="嵌套查询">嵌套查询:</h3>
<ol>
<li>非关联嵌套(子查询的条件与父查询无关):<br>
查询买了food的用户名<br>
<code>SQL SELECT T.name FROM table1 T WHERE T.id IN(SELECT B.uid FROM buy B WHERE B.sid=1)</code><br>
对每个用户扫描,查看其id是否在买过food的表的id里面,若在返回id对应的姓名</li>
<li>关联嵌套查询(嵌套的子查询条件与父查询相关):<br>
例1. 查询买过food用户的名称:<br>
<code>SQL SELECT T.name FROM table1 T WHERE EXISTS (SELECT * FROM buy B WHERE B.uid=T.id AND B.sid=1)</code><br>
如果某用户买过food,那么在buy表中必然存在一条记录,其uid等于该用户id且sid等于1<br>
对table1中的每个用户遍历,查看是否在buy表中存在符合上述条件的元组<br>
相当于二重循环,对外层循环中的每条元组都做一次内层循环</li>
</ol>
<p>例2. 查只有一个人买的商品<br>
<code>SQL SELECT B.sid FROM buy B WHERE B.sid NOT IN (SELECT B1.sid FROM buy B1 WHERE B.uid!=B1.uid)</code><br>
查出表中除用户1 外其他用户买的商品,如果用户1买的商品不在其他用户买的商品列表里,则用户1买的商品就是只有一人买的<br>
对buy表扫描,查看当前这条购买的这个人,除他以外其他人都买了什么,如果他买的东西不在其他人买的东西的列表那就满足条件<br>
构造步骤:<br>
查询只有除我外其他人购买了的商品:SELECT 商品 FROM 购物表 WHERE 购买者!=我<br>
查出我只有我买的商品:SELECT 商品 FROM 购物表1 WHERE 商品 NOT IN (SELECT 商品 FROM 购物表 2 WHERE 购买者!=我)<br>
遍历到所有人:SELECT 商品 FROM 购物表1 WHERE 商品 NOT IN (SELECT 商品 FROM 购物表 2 WHERE 购买者!=购物表1中对应购买者)</p>
<h3 id="聚集函数">聚集函数</h3>
<ol>
<li>COUNT(*)某表的元组数</li>
<li>COUNT([DISTINCT] A)某表中属性值A的不同值个数,属性A的值不一样时候加一</li>
<li>SUM([DISTINCT] A)对属性A进行累计求和</li>
<li>AVG([DISTINCT] A)属性A的平均值</li>
<li>MAX(A)</li>
<li>MIN(A)</li>
</ol>
<h3 id="分组group-by">分组GROUP BY</h3>
<ol>
<li>模式:GROUP BY( )</li>
<li>功能:对表中信息按照条件分组,条件相同即为一组</li>
<li>要求对分组得到的每个组它的属性在SELECT上必须是单一的(因为每个组最终只出一条信息,若不单一就无法继续)简单来说就是要求SELECT和HAVING后的属性都必须是GROUP BY后的属性的子集</li>
</ol>
<h3 id="having">HAVING</h3>
<p>SELECT的属性和HAVING属性必须是分组属性集的子集</p>
<ol>
<li>模式:HAVING</li>
<li>功能:对分好组后的信息按照条件筛选<br>
例1:<br>
定义user表如下<br>
<img src="https://wangyingying625.github.io/post-images/1614859980796.png" alt="" loading="lazy"><br>
查询年龄大于25的用户里每个级别最年轻用户的年龄并且每个级别里用户数要大于1<br>
<code>SQL SELECT U.rating,MIN(U.age) AS minAge FROM user U WHERE U.age &gt;25 GROUP BY U.rating HAVING COUNT(*)&gt;1</code><br>
结果如下:<br>
<img src="https://wangyingying625.github.io/post-images/1614860466747.png" alt="" loading="lazy"><br>
执行过程<br>
对表中信息按照rating属性排序,得到:<br>
rating   age<br>
3         33<br>
5          34<br>
7           45<br>
7           36<br>
8           45<br>
10          33<br>
分出5组<br>
再根据HAVING的条件进行筛选组,得到<br>
7           45<br>
7           36<br>
对SELECT后的条件进行映射<br>
得到<br>
7           36<br>
查询平均年龄最小的等级<br>
<code>SQL SELECT Temp.rating FROM ( SELECT S.rating ,AVG(S.age) AS avgage FROM user S GROUP BY S.rating ) AS Temp WHERE temp.avgage=(SELECT MIN (Temp.avgage))</code><br>
生成了临时表Temp</li>
</ol>
<h3 id="case表达式">CASE表达式</h3>
<p><code>SQL SELECT name,CASE status WHEN 1 THEN 'admin' WHEN 2 THEN 'user' ELSE 'unknow' END AS status FROM user</code><br>
在user表中查询用户姓名和状态,当查到状态为1 时候替换显示admin</p>
<h3 id="cast表达式">CAST表达式:</h3>
<p>定义一个新的列(补列): ** 多用于做UNION并时添加新的列 **<br>
CAST(NULL AS Varchar(20))</p>
<h3 id="定义视图view">定义视图view</h3>
<p>student(name,school)<br>
soldiers(name,service)<br>
<code>SQL CREATE VIEW prospects (name,school,service) AS SELECT name,school,CAST(NULL AS Varchar(20)) FROM Students UNION SELECT name,CAST(NULL AS Varchar(20)),service FROM Soldiers</code><br>
prospects(name,school,service)定义的视图及其结构<br>
CAST(NULL AS Varchar(20))由于student表中没有service信息,创建一列为空的信息补到student的school后充当service,使得student表有三列<br>
CAST(NULL AS Varchar(20))同上</p>
<h3 id="子查询">子查询:</h3>
<h4 id="标量子查询查询结果是属性值">标量子查询:查询结果是属性值</h4>
<p>凡是可以出现某个值的地方都可以放一个变量子查询</p>
<h4 id="表表达式查询结果是表">表表达式:查询结果是表</h4>
<h4 id="公共表表达式一个子表达式使用多次时对它定义">公共表表达式:一个子表达式使用多次时对它定义</h4>
<p>公共表就是一个临时视图<br>
<code>SQL WITH payroll(rate,avgage) AS (SELECT rating,avg(age) FROM user GROUP BY rating) SELECT avgage FROM payroll WHERE rate=10</code></p>
<h2 id="dml语句">DML语句:</h2>
<h3 id="insert语句">INSERT语句:</h3>
<p>一条INSERT语句就是向数据库插入一条元组<br>
<code>SQL INSERT INTO user VALUES('wangHua',10,12)</code></p>
<h3 id="delete语句">DELETE语句:</h3>
<p>删除满足条件元组(可能多条)<br>
<code>SQL DELETE FROM user WHERE id=1</code></p>
<h3 id="update语句">UPDATE语句:</h3>
<p><code>SQL UPDATE user SET name='liHua',rating=2 WHERE id=1</code></p>
<h3 id="view">VIEW</h3>
<p>利用视图实现外模式,通过外模式与模式的映射实现逻辑独立性<br>
在数据库中只存储其定义,不存储其对应数据,在需要数据时通过对表的映射得到<br>
使用时可当做表使用,但是虚表,视图中内容并不存,定义被存储在数据库的自动生成的默认表中(只存储定义不存储内容)<br>
<code>SQL CREATE VIEW youngUser AS SELECT id,name,rating,age FROM user WHERE age&lt;18</code><br>
视图的修改:<br>
有的数据库支持有的不支持,当视图中的某一属性能唯一映射到原表中时,可支持,此时修改视图实际修改的是表中信息</p>
<p><code>SQL CREATE VIEW youngUser AS SELECT id,name,rating,age FROM user WHERE age&lt;18</code><br>
垂直方向做了投影,水平方向做了筛选,可修改</p>
<p><code>SQL CREATE VIEW youngUser AS SELECT rating,AVG(age) FROM user GROUP BY rating</code><br>
不支持修改,因为修改视图中某一条属性无法返回到基表中的某个属性值</p>
<p>WITH子句定义的临时表定义也不在数据库中存储</p>
<h2 id="sql嵌入编程语言">SQL嵌入编程语言:</h2>
<h3 id="面临问题">面临问题:</h3>
<ol>
<li>SQL支持的数据类型与编程语言不匹配</li>
<li>SQL语言执行(关系型数据库查询结果)结果是表,编程语言想要的是变量</li>
<li>SQL中有空值NULL,如何对其处理</li>
</ol>
<h3 id="解决方案">解决方案:</h3>
<ol>
<li>嵌入式SQL</li>
<li>API(JDBC):用户直接利用接口调用SQL语句</li>
<li>类封装</li>
</ol>
<h3 id="嵌入式sql的解决思路">嵌入式SQL的解决思路:</h3>
<ol>
<li>以 EXEC SQL开头,以';'结尾的会被c语言识别为SQL语句;</li>
<li>引入 <strong>宿主变量</strong> 在C语言和数据库之间传递信息,其中在C语言中宿主变量与普通变量并无区别,在SQL中使用宿主变量时要在变量前加':',通过在C语言中赋值,在SQL中引用(或者相反)在他们俩之间传递信息</li>
<li>使用indicator(short int)变量来标记是否是空值</li>
</ol>
<h3 id="使用步骤">使用步骤:</h3>
<ol>
<li>连接数据库</li>
<li>在C语言中以EXEC SQL BEGIN DECLARE SECTION开头 EXEC SQL END DECLARE SECTION结尾标记宿主变量的定义</li>
<li>游标机制:游标定义对应的是一句SQL语句,返回这条语句执行的结果,结果类似于文件,有一个读写指针,指针指向一条元组,每读一条元组就向下走到下一条元组</li>
<li>需要预编译,得到纯C代码</li>
</ol>
]]></content>
    </entry>
</feed>