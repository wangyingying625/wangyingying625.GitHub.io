<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-10T06:23:27.823Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[爱读书的大肥兔]]></title>
        <id>https://wangyingying625.github.io/post/ai-du-shu-de-da-fei-tu/</id>
        <link href="https://wangyingying625.github.io/post/ai-du-shu-de-da-fei-tu/">
        </link>
        <updated>2021-03-10T04:38:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="被人讨厌的勇气">被人讨厌的勇气</h3>
<ol>
<li>既没有自卑感也不必炫耀优越性,能够保持一种平静而自然的状态.真正的爱应该是这样的.</li>
<li>过于希望得到别人的认可,就会按照别人的期待去生活.也就是舍弃真正的自己,活在别人的人生中.</li>
<li>假如说你不是为了满足别人的期待而活,那么他人也不是为了满足你的期待而活,当别人的行为不符合自己的想法时也不可发怒.</li>
<li>想要取得别人的认可的时候,几乎所有人都会采取&quot;满足别人的期待&quot;这一手段,这其实都是受&quot;如果做了恰当的事情就能够得到表扬&quot;这种赏罚教育的影响.但是,若果工作的主要目标变成了&quot;满足别人的期待&quot;,那工作就会变得相当痛苦.因为那样就会一味的在意别人的实现,害怕别人的评价,根本无法做真正的自己.</li>
<li>基本上,一切人际关系矛盾都起因于对别人的课题王加干涉或者自己的课题被别人妄加干涉.</li>
<li>时尚的父母总是说&quot;为你着想&quot;之类的话,但是,父母的行为有时候很明显是为了满足自己的目的--面子和虚荣又或者是支配欲.正因为察觉到了这种欺骗行为,孩子才会反抗.</li>
<li>关于自己的人生你能够做的就只有&quot;选择自己认为最好的道路&quot;.另一方面,别人如何评价你的选择,那是别人的课题,你根本无法左右.</li>
<li>没有学会直面困难的孩子最终会想要逃避一切困难.<br>
<img src="https://wangyingying625.github.io/post-images/1615352619902.jpg" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合论]]></title>
        <id>https://wangyingying625.github.io/post/ji-he/</id>
        <link href="https://wangyingying625.github.io/post/ji-he/">
        </link>
        <updated>2021-03-09T05:52:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="集合论">集合论:</h2>
<p>用集合论作为描述工具<br>
集合中的元素要各不相同<br>
集合中的元素不规定顺序<br>
集合的两种表示法可以互相转换</p>
<h3 id="集合基本概念">集合基本概念</h3>
<h4 id="集合的表示">集合的表示:</h4>
<ol>
<li>列举法 A={1,2,3}</li>
<li>描述法</li>
</ol>
<h3 id="常用术语">常用术语:</h3>
<ol>
<li>子集⊆:若B是A的子集,要求B中元素都是A中元素,也叫B包含于A,A包含B.空集是一切集合的子集</li>
<li>相等:A包含B且B包含A</li>
<li>真子集⊂:A是B的子集且A不等于B,则A⊂于B</li>
<li>幂集:设A是一个集合,则由A的全体子集组成的集合是A的幂集,记为P(A)</li>
<li>集合的元素个数:|A|表示集合A中的元素个数<br>
若|A|=n,则|P(A)|=2ⁿ</li>
<li>定义域:dom R</li>
<li>值域:ran R</li>
<li>域:ran R U dom R</li>
</ol>
<h3 id="集合的运算">集合的运算:</h3>
<ol>
<li>并集∪:设A与B为两个集合,由A和B中所有元素组成的集合是A和B的并集AUB</li>
<li>交集∩</li>
<li>不相交:设A和B为两个集合,若A∩B=∅,则A与B不相交</li>
<li>相对补:A-B,属于集合A而不属于集合B的全体元素</li>
<li>绝对补:任意集合A对全集E的绝对补,记为~A</li>
<li>对称差⨁:属于A不属于B的和属于B但不属于A的全体元素组成的集合</li>
<li>文氏图:集合与集合之间的关系以及一些运算的结果可以用文氏图直观表示.其中矩阵表示全集,圆或者其他封闭的曲线可以表示E的子集,运算结果得到的集合用阴影表示.<br>
<img src="https://wangyingying625.github.io/post-images/1615262997178.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="基本的集合恒等式">基本的集合恒等式:</h3>
<p>设E是全集,A,B,C是E的任意子集:</p>
<ol>
<li>幂等律:A ∪ A=A ,  A∩A=A</li>
<li>交换律:AUB=BUA ,A ∩B=B∩A</li>
<li>结合律:(AUB)UC=AU(BUC) , (A∩B)∩C=A∩(B∩C)</li>
<li>分配律:AU(B∩C)=(AUB)∩(AUC) , A∩(BUC)=(A∩B)U(A∩C)</li>
<li>德摩根律:<sub>(AUB)=</sub> A∩~B , <sub>(A∩B)=</sub>AU~B</li>
<li>吸收率:AU(A∩B)=A , A∩（AUB）= A</li>
<li>零律:AUE=E , A∩∅=∅</li>
<li>同一律:AU∅=A , A∩E=A</li>
<li>排中律:AU~A=E</li>
<li>矛盾律:A∩~A=∅</li>
<li>余补律:~∅=E , ~E=∅</li>
<li>双重否定率:<sub>(</sub>A)=A</li>
<li>补交转换率:A-B=A∩~B<br>
优先级:绝对补 幂集 广义交 广义并,并 交 相对补 对称差<br>
集合等式的证明可以用命题演算证明<br>
<img src="https://wangyingying625.github.io/post-images/1615269104056.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="有序对">有序对:</h3>
<p>&lt;a,b&gt;={{a},{a,b}},其中a是第一元素,b是第二元素.<br>
&lt;a,b,c&gt;=&lt;&lt;a,b&gt;,c&gt;  有序三元组</p>
<h3 id="卡式积笛卡尔积">卡式积(笛卡尔积):</h3>
<p>A与B是两个集合,他们的卡式积是一个新的集合.集合中的元素都是有序对,有序对中第一元素都在A中,第二元素都在B中,所有这样的有序对构成卡式积.</p>
<h4 id="卡式积性质">卡式积性质:</h4>
<ol>
<li>非交换(除非A=B或者A=∅或者B=∅)Ax∅=∅</li>
<li>非结合:(AxB)xc≠Ax(Bxc)甚至(AxA)xA≠Ax(AxA)</li>
<li>分配律:Ax(B∪C)=(AxB)∪(AxC)</li>
<li>AxB=∅ &lt;=&gt; A=∅∪B=∅两非空集合卡式积一定非空</li>
<li>无零因子</li>
</ol>
<p>性质证明:<br>
设A,B,C是任意集合:证明若A≠∅,则AxB ⊆ AxC &lt;=&gt; B ⊆ C<br>
<img src="https://wangyingying625.github.io/post-images/1615272819895.jpg" alt="" loading="lazy"></p>
<h2 id="二元关系与关系数据库相关">二元关系(与关系数据库相关)</h2>
<p>元素都是有序n元素的集合叫n元关系<br>
F1={&lt;1,2,3&gt;,&lt;你,我,他&gt;}是一个三元关系</p>
<h3 id="基本概念">基本概念</h3>
<ol>
<li>
<p>关系(2元关系):元素全是有序对的集合<br>
F1={&lt;1,2&gt;,&lt;2,3&gt;}<br>
F2={&lt;1,2&gt;,3,4}不是二元关系,其中3,4不是有序对</p>
</li>
<li>
<p>A到B的二元关系:AxB的任意子集(A对B的笛卡尔乘积都是A到B的二元关系)<br>
若|A|=m,|B|=n,则|AxB|=mn,|P(AxB)|=2nm次方<br>
即A到B的不同二元关系有2nm次方个</p>
<p>例1:设A={a1,a2},B={b1}<br>
则A到B的二元关系有:<br>
R1=∅,R2={&lt;a1,b1&gt;},R3={<a2>,<b1>},R4={&lt;a1,b1&gt;,&lt;a2,b1&gt;}<br>
B到A的二元关系有:<br>
R1=∅,R2={&lt;b1,a1&gt;},R3={<b1>,<a2>},R4={&lt;b1,a1&gt;,&lt;b1,a2&gt;}</p>
</li>
<li>
<p>恒等关系:A中每个元素自己和自己有关系的那种关系</p>
</li>
</ol>
<h3 id="基本运算">基本运算:</h3>
<ol>
<li>逆</li>
<li>合成(复合函数)</li>
<li>限制⨡:关系F和集合A,关系F对A的限制就是一些关系的集合,这些关系满足第一元素来自于A</li>
<li>象F[{a}]:关系F在集合A上的象就是F中第一个元素在A里面的第二个元素的集合(类似于H(A))</li>
<li>单根:F是单根的意味着在关系F=&lt;x,y&gt;中,<strong>任意</strong>一个y都对应<strong>唯一</strong>的x</li>
<li>单值:F是单值的意味着F中<strong>任意</strong>一个x都唯一对应一个y</li>
<li>(FoG)的逆=G-1oF-1</li>
</ol>
<p><img src="https://wangyingying625.github.io/post-images/1615276477548.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615277275790.jpg" alt="" loading="lazy"></p>
<h3 id="表示和性质">表示和性质</h3>
<h4 id="表示">表示:</h4>
<ol>
<li>集合</li>
<li>关系矩阵</li>
<li>关系图</li>
</ol>
<h4 id="性质">性质:</h4>
<ol>
<li>自反:设R是A上的一个二元关系,说R是自反的当且仅当任取x在集合A里那么&lt;x,x&gt;就有关系R.集合中的每个元素自己都和自己有关系(全部x都得满足)[关系矩阵主对角线元素都是1,关系图每个顶点都有环]</li>
<li>反自反:任何x,自己和自己都没有关系(所有X都不能和自己有关系R)[要求每个点都没有环,主对角线全为0]</li>
<li>非自反:存在x属于A那么&lt;x,x&gt;必不属于关系R(只要有一个不属于就行)</li>
<li>对称:任选x和y,如果&lt;x,y&gt;有关系R那么&lt;y,x&gt;也有关系R(相等关系)[关系图中不同两点间必然是双箭头,矩阵中必然是对称矩阵]任何两个点间都没有边的关系既是对称的也是反对称的</li>
<li>反对称:任何两个点之间只有一条有向边</li>
<li>非对称:只有有一个&lt;x,y&gt;不对称[存在两个点间只有一条边]</li>
<li>传递:当X和Y有关系,并且Y和Z有关系时,X和Z有关系(R和R的合成是R的子集)</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615280969332.jpg" alt="" loading="lazy"></figure>
<h3 id="闭包">闭包:</h3>
<p>关系的幂:<br>
<img src="https://wangyingying625.github.io/post-images/1615283212083.jpg" alt="" loading="lazy"><br>
包含给定的元素并且具有给定性质的最小集合</p>
<ol>
<li>自反闭包:要求都包含关系R,结果的二元关系是自反的(原来的R可能不自反,加一些元素使其自反),并且是最小的,R的自反闭包用r(R)表示</li>
<li>对称闭包:...结果的二元关系是对称的...,R的对称闭包用s(R)表示(任意两个结点都是对称的)</li>
<li>传递闭包:...结果的二元关系是传递的...R的传递闭包用t(R)表示(任意两个结点都是传递的)<br>
r(R1UR2)=r(R1)Ur(R2)并起来并不会增加环的数量<br>
s(R1UR2)=s(R1)Us(R2)两点之间本来就都有两条边,并起来并不会增加双向边的数量<br>
t(R1UR2)⊇t(R1)Ut(R2)并了以后长度为2 的路径会更多</li>
</ol>
<h4 id="求法">求法:</h4>
<p>r(R)=RUIA(恒等关系);矩阵上就是把对角线元素都改为1;图上就是每个点都加环<br>
s(R)=RUR逆;矩阵上变为对称阵;原来无边的不用加,原来有一条半的加反向边<br>
t(R)=RUR²UR³U...<br>
<img src="https://wangyingying625.github.io/post-images/1615287920816.jpg" alt="" loading="lazy"><br>
sr(R)=rs(R) , tr(R)=rt(R) , st(R)不一定对称⊆ts(R)</p>
<h3 id="等价关系用来分类">等价关系(用来分类)</h3>
<p>设A≠∅,且R⊆AxA,若R是自反的对称的传递的,则R是等价关系</p>
<h4 id="性质-2">性质:</h4>
<p>设R是A≠∅上的等价关系,则⩝x,y∈A有</p>
<ol>
<li>[x]≠∅(必定有x自己)</li>
<li>xRy=&gt;[x]=<a href="x%E5%92%8Cy%E6%9C%89%E5%85%B3%E7%B3%BB,y%E4%B9%9F%E5%92%8Cx%E6%9C%89%E5%85%B3%E7%B3%BB,y%E8%BF%98%E5%92%8C%E5%AE%83%E6%89%80%E5%9C%A8%E7%AD%89%E4%BB%B7%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0%E6%9C%89%E5%85%B3%E7%B3%BB,%E9%82%A3x%E4%B9%9F%E5%92%8Cy%E7%9A%84%E7%AD%89%E4%BB%B7%E7%B1%BB%E6%9C%89%E5%85%B3%E7%B3%BB">y</a></li>
<li>¬ xRy=&gt;[x]∩[y]≠∅当两元素没关系时他们的等价类一定不相交</li>
<li>所有等价类并起来就是原集合A</li>
</ol>
<h3 id="商集分类结果">商集:分类结果</h3>
<h3 id="序关系用来在一个类里排序">序关系(用来在一个类里排序)</h3>
<h1 id="函数">函数</h1>
<h1 id="自然数">自然数</h1>
<h1 id="基数和序数">基数和序数</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OWASP问题版]]></title>
        <id>https://wangyingying625.github.io/post/owasp-wen-ti-ban/</id>
        <link href="https://wangyingying625.github.io/post/owasp-wen-ti-ban/">
        </link>
        <updated>2021-03-08T13:31:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sql">SQL</h2>
<h3 id="什么情况下会产生sql注入漏洞">什么情况下会产生SQL注入漏洞</h3>
<p>SQL注入漏洞的产生是由于程序将用户的输入当做SQL语句的一部分,拼接在程序写好的那部分SQL语句后面执行了.那么当用户在输入时,利用UNION连接符拼接恶意的SQL语句,这些语句也将会被执行.</p>
<h3 id="如何测试某个功能点是否存在sql注入漏洞">如何测试某个功能点是否存在SQL注入漏洞</h3>
<p>如果是int型并且插入位置在WHERE后面:可在输入的位置添加 AND 1=2,看执行结果是否 (如果是字符型需要考虑括号的闭合)<br>
可用#屏蔽后面的SQL代码</p>
<h3 id="预防">预防:</h3>
<ol>
<li>对SQL语句预编译</li>
<li>对单引号进行转义</li>
<li>强制类型转换为数字</li>
</ol>
<h2 id=""></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散数学问题]]></title>
        <id>https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/</id>
        <link href="https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/">
        </link>
        <updated>2021-03-08T08:23:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="如何给集合下定义">如何给集合下定义</h2>
<h2 id="如何用集合定义关系函数和自然数">如何用集合定义关系,函数和自然数</h2>
<h2 id="如何比较集合的大小">如何比较集合的大小</h2>
<h2 id="有没有最大的集合">有没有最大的集合</h2>
<h2 id="能否把每个集合的元素依次列举">能否把每个集合的元素依次列举</h2>
<h2 id="什么是图">什么是图</h2>
<h2 id="有哪些图">有哪些图</h2>
<h2 id="图有什么性质">图有什么性质</h2>
<h2 id="什么是欧拉图">什么是欧拉图</h2>
<h2 id="什么是哈密顿图">什么是哈密顿图</h2>
<h2 id="什么是树">什么是树</h2>
<h2 id="如何用矩阵表示图">如何用矩阵表示图</h2>
<h2 id="什么是平面图">什么是平面图</h2>
<h2 id="什么是图的着色">什么是图的着色</h2>
<h2 id="什么是带权图">什么是带权图</h2>
<h2 id="什么是支配集">什么是支配集</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图论]]></title>
        <id>https://wangyingying625.github.io/post/tu-lun/</id>
        <link href="https://wangyingying625.github.io/post/tu-lun/">
        </link>
        <updated>2021-03-08T08:22:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="图">图</h1>
<h2 id="基本概念">基本概念</h2>
<h2 id="连通性">连通性</h2>
<h2 id="欧拉图与哈密顿图">欧拉图与哈密顿图</h2>
<h2 id="树">树</h2>
<h2 id="图的矩阵表示">图的矩阵表示</h2>
<h2 id="平面图">平面图</h2>
<h2 id="着色">着色</h2>
<h2 id="带权图">带权图</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命题和谓词逻辑]]></title>
        <id>https://wangyingying625.github.io/post/ji-he-lun/</id>
        <link href="https://wangyingying625.github.io/post/ji-he-lun/">
        </link>
        <updated>2021-03-08T08:18:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2>
<h3 id="命题公式">命题公式:</h3>
<h4 id="联结词">联结词:</h4>
<p>p,q,r...表示原子命题(简单命题,可当做逻辑变量即布尔变量);0表示假,1表示真</p>
<ol>
<li>否定联结词 ¬ :<br>
¬p称为p的否定式 :<br>
<img src="https://wangyingying625.github.io/post-images/1615192683283.png" alt="" loading="lazy"></li>
<li>合取联结词∧:<br>
p ∧q称为p与q的合取式<br>
<img src="https://wangyingying625.github.io/post-images/1615192963199.png" alt="" loading="lazy"></li>
<li>析取联结词∨:<br>
p∨q称为q与p的析取式<br>
<img src="https://wangyingying625.github.io/post-images/1615193105570.png" alt="" loading="lazy"></li>
<li>蕴涵联结词-&gt;:<br>
p-&gt;q的真假性与p&lt;=q一致<br>
<img src="https://wangyingying625.github.io/post-images/1615193176146.png" alt="" loading="lazy"></li>
<li>等价联结词&lt;-&gt;:<br>
p&lt;-&gt;q与p==q真假性一致<br>
<img src="https://wangyingying625.github.io/post-images/1615193661156.png" alt="" loading="lazy"><br>
优先级: ¬ ,∨ ∧,-&gt; &lt;-&gt;</li>
</ol>
<h3 id="命题公式-2">命题公式:</h3>
<h4 id="命题公式的组成">命题公式的组成:</h4>
<ol>
<li>单个命题变元就是命题公式</li>
<li>对命题变元进行有限次联结词连接得到的也是命题公式</li>
</ol>
<h4 id="命题公式的类型">命题公式的类型:</h4>
<ol>
<li>可满足式:当一个命题公式,其中的原子命题取不同的值时可能对应公式取值为真.</li>
<li>矛盾式(永假式):原子命题所有可能的取值组合(0,1组合)下,此公式的取值都为假</li>
<li>重言式(永真式):原子命题所有可能的取值组合(0,1组合)下,此公式的取值都为真(是可满足式的一种)</li>
</ol>
<h3 id="等值式">等值式:</h3>
<p>定义:两个命题公式满足A&lt;=&gt;B则A&lt;-&gt;B是永真式.即A与B可以互相代替</p>
<p>正确性的证明:两边列真值表,若在原子命题取不同值的时候两边的取值都一样,则验证正确</p>
<h4 id="常用等值式">常用等值式:</h4>
<ol>
<li>蕴涵等值式:p-&gt;q  &lt;=&gt;   ¬ p∨q  (蕴涵联结词是多余的,可被与或非表示)</li>
<li>幂等律：A∧A⇔A      ||||||||||        A∨A⇔A</li>
<li>交换律：A∨B⇔B∨A    ||||||||||||     A∧B⇔B∧A</li>
<li>结合律：<br>
（A∧B）∧C⇔A∧（B∧C）<br>
（A∨B）∨C⇔A∨（B∨C）</li>
<li>分配律：<br>
A∨（B∧C）⇔（A∨B）∧（A∨C）<br>
A∧（B∨C）⇔（A∧B）∨（A∧C）</li>
<li>德摩根律：<br>
┐（A∨B）⇔┐A∧┐B<br>
┐（A∧B）⇔┐A∨┐B</li>
<li>吸收律：<br>
A∨（A∧B）⇔A<br>
A∧（A∨B）⇔A</li>
<li>零律：<br>
A∨1⇔1<br>
A∧0⇔0</li>
<li>同一律：<br>
A∨0⇔A<br>
A∧1⇔A</li>
<li>排中律：A∨┐A⇔1(若A不对则非A一定对)</li>
<li>矛盾律：A∧┐A⇔0(若A对则非A一定不对)</li>
<li>双重否定律：┐┐A⇔A</li>
<li>等价等值式:A&lt;-&gt;B &lt;=&gt; (A -&gt; B)∧(B-&gt;A) (等价联结词是多余的,可被蕴含联结词和与或非表示)</li>
<li>等价否定等值式：A↔B⇔┐A↔┐B</li>
<li>归谬论：（A→B）∧（A→┐B）⇔┐A<br>
只涉及与或非时,与跟或换时0跟1也换</li>
</ol>
<h4 id="等值演算就是给一个命题公式通过等值式的转换得到另外一个命题公式他们俩是等价的可用真值表验证">等值演算:就是给一个命题公式通过等值式的转换得到另外一个命题公式,他们俩是等价的(可用真值表验证)</h4>
<p>判断两个公式是否相等的两种方法:等值演算;列真值表<br>
任何两个公式只要是相等的一定能通过等值演算证明</p>
<h3 id="推理">推理:</h3>
<p>由一个命题得出另外一个命题的过程</p>
<h4 id="推理的形式结构">推理的形式结构:</h4>
<p>前提:A1,A2,A3...<br>
结论:B<br>
形式结构:<br>
(A1 ∧ A2 ∧ A3 ∧ A4...)-&gt;B</p>
<h4 id="推理定律">推理定律</h4>
<p>A=&gt;B则A-&gt;B是永真式</p>
<ol>
<li>拒取式:(A-&gt;B)∧ ¬ B  =&gt;  A</li>
<li>附加律:A=&gt;(A∨B)</li>
<li>化简律:(A∧B)=&gt;A,(A∧B)=&gt;B</li>
<li>假言:(A-&gt;B)∧A=&gt;B(A能推出B,并且A是对的,那么B就是对的)</li>
<li>析取三段论:(A∨B)∧ ¬ A=&gt;B<br>
(AVB)∧ ¬ B=&gt;A<br>
A和B必有嫌疑人,排除A那B是嫌疑人</li>
<li>假言三段论:(A-&gt;B)∧(B-&gt;C) =&gt;(A-&gt;C)</li>
<li>等价三段论:(A&lt;-&gt;B)∧(B&lt;-&gt;C) =&gt;(A&lt;-&gt;C)</li>
<li>构造性两难:(A-&gt;B)∧(C-&gt;D)∧(AVC) =&gt; (BVD)</li>
</ol>
<h4 id="判断推理正确的方法">判断推理正确的方法</h4>
<p>前提:p-&gt;(q-&gt;r),p,q<br>
结论:r<br>
方法一:</p>
<ol>
<li>写出推理的形式结构</li>
<li>证明该形式结构永真<br>
<img src="https://wangyingying625.github.io/post-images/1615198910960.jpg" alt="" loading="lazy"><br>
方法二:从前提推演结论<br>
(P-&gt;(q-&gt;r))∧p∧q  =&gt;<br>
(q-&gt;r)∧q  =&gt;<br>
r</li>
</ol>
<h3 id="谓词逻辑">谓词逻辑:</h3>
<p>对命题再进行细分.命题是陈述句,再按照主语谓语分<br>
主语是个体,谓语是谓词</p>
<h4 id="基本概念-2">基本概念</h4>
<ol>
<li>个体:可以独立存在的客体,通常用a,b,c表示个体常元;用x,y,z表示个体变元</li>
<li>谓词:表示个体性质或者彼此之间联系的词,常用F,G,H..表示<br>
F(x)表示x具有性质F<br>
若F(x,y)表示x&gt;y则F(3,2)表示3大于2</li>
<li>量词:表示数量的词:<br>
全称量词:所有的⩝<br>
⩝x表示所有的x<br>
⩝xF(x)表示个体域里的所有x都有F(x)这个属性<br>
存在量词:存在∃<br>
∃xF(x)表示个体域中有x 有性质F</li>
</ol>
<h4 id="命题符号化">命题符号化:</h4>
<p><img src="https://wangyingying625.github.io/post-images/1615200644492.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615200651176.jpg" alt="" loading="lazy"></p>
<h4 id="一阶谓词逻辑公式">一阶谓词逻辑公式</h4>
<p>量词加在个体上,即任何X或者存在X<br>
<img src="https://wangyingying625.github.io/post-images/1615201094641.jpg" alt="" loading="lazy"><br>
如果逻辑公式A在任何解释下都为真,则它是永真式<br>
如果逻辑公式A在任何解释下都为真,则它是永假式<br>
如果逻辑公式A至少存在一个解释使其为真,则它是可满足式<br>
如果A&lt;-&gt;B是永真的,那么A与B等值,记为A&lt;=&gt;B</p>
<h5 id="基本等值式">基本等值式:</h5>
<ol>
<li>在有限个体域上消去量词:<br>
⩝xA(x)&lt;=&gt;A(x1)∧A(x2)∧A(x3)∧A(x4)∧A(x5)∧A(x6)...<br>
∃yB(y)&lt;=&gt;B(y1)∨B(y2)∨B(y3)∨B(y4)∨B(y5)∨B(y6)∨B(y7)...</li>
<li>量词否定等值式:<br>
¬ ⩝xA(x) &lt;=&gt; ∃x ¬ A(x)<br>
¬ ∃xB(x) &lt;=&gt; ⩝x ¬ B(x)</li>
<li>量词辖域收缩和扩张等值式:<br>
<img src="https://wangyingying625.github.io/post-images/1615201852622.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615202547661.png" alt="" loading="lazy"></li>
</ol>
<h4 id="前束范式">前束范式:</h4>
<p>若公式A满足:其一切量词都未被否定地处于公式的最前端且其辖域都延伸至公式的末端的谓词演算公式。<br>
可用基本等值式求前束范式<br>
<img src="https://wangyingying625.github.io/post-images/1615203809312.jpg" alt="" loading="lazy"></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库思维导图]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-si-wei-dao-tu/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-si-wei-dao-tu/">
        </link>
        <updated>2021-03-07T11:20:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据模型">数据模型</h2>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615116032962.png" alt="" loading="lazy"></figure>
<h2 id="数据库管理系统dbms">数据库管理系统DBMS</h2>
<figure data-type="image" tabindex="2"><img src="https://wangyingying625.github.io/post-images/1615129998237.png" alt="" loading="lazy"></figure>
<h2 id="关系数据库设计">关系数据库设计</h2>
<figure data-type="image" tabindex="3"><img src="https://wangyingying625.github.io/post-images/1615130073999.png" alt="" loading="lazy"></figure>
<h2 id="数据库安全性">数据库安全性</h2>
<figure data-type="image" tabindex="4"><img src="https://wangyingying625.github.io/post-images/1615182369785.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库问题]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-wen-ti/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-wen-ti/">
        </link>
        <updated>2021-03-07T09:16:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是数据库">什么是数据库?</h3>
<p>答:从本质上看,数据库就是信息的集合,这个集合能长期保存,可以共享并且有一定的数据结构</p>
<h3 id="什么是数据">什么是数据?</h3>
<p>答:数据是数据库中存储的基本对象.</p>
<h3 id="什么是数据库系统">什么是数据库系统:</h3>
<p>数据库系统是有数据库,数据,数据库管理系统和数据库管理员组成的系统</p>
<h3 id="什么是数据库管理系统dbms">什么是数据库管理系统(DBMS):</h3>
<h3 id="dbms有什么功能">DBMS有什么功能:</h3>
<ol>
<li>允许用户使用数据定义语言(DDL)建立新的数据库并定义它的模式(逻辑结构)</li>
<li>允许使用数据库操作语言(DML)和查询语言(QL)为用户提供查询和更新数据库的接口</li>
<li>控制多个用户的存取,一个用户对数据库的操作不影响另一个用户</li>
<li>支持大量数据的长期存储</li>
<li>在面对故障时能有恢复数据库的能力</li>
</ol>
<h3 id="dbms的功能要求dbms具备哪些结构">DBMS的功能要求DBMS具备哪些结构:</h3>
<ol>
<li>语法分析器:对用户提交的SQL语句进行语法分析</li>
<li>授权检查:检查尝试执行SQL语句的用户是否有权限执行它</li>
<li>查询分析和查询处理</li>
<li>访问管理:解决如何把表存储成磁盘中的文件流</li>
</ol>
<h3 id="什么是数据模型">什么是数据模型</h3>
<p>用来描述数据或者是信息的标记,一般由三部分组成</p>
<ol>
<li>数据结构</li>
<li>数据操作</li>
<li>完整性约束条件</li>
</ol>
<h3 id="关系数据模型有什么特点">关系数据模型有什么特点:</h3>
<p>关系数据模型把现实中的实体和实体间的联系都抽象成关系,即表.对关系操作的内容和结果都是表</p>
<h3 id="sql中的三种关系">SQL中的三种关系:</h3>
<ol>
<li>表:在物理磁盘中存储</li>
<li>视图:虚表,不在物理磁盘中存储其内容,只在数据库中存储其定义,需要内容时通过数据库中的表根据用户的需求映射</li>
<li>临时表:不在数据库中存储其内容也不在数据库中存储其定义,由SQL语句临时构造,在SQL语句执行完之后就被删除</li>
</ol>
<h3 id="如何建立一个关系型数据库">如何建立一个关系型数据库:</h3>
<p>建立数据库需要回答:存储什么信息;信息元素之间如何关联;需要有什么样的约束</p>
<ol>
<li>需求分析:考察数据库中可能涉及到的数据以及数据的特征,建立数据字典</li>
<li>概念设计:抽象实体,建立实体间联系,画出E-R图</li>
<li>逻辑设计:把E-R图转化为表</li>
<li>物理设计:设计数据库的存储结构及访问方法.考虑文件的存储形式和索引的建立.</li>
</ol>
<h3 id="什么是事务">什么是事务</h3>
<p>事务是对数据库操作的基本单位,本质上是一组SQL语句;<br>
事务具有原子性,原子性指的是SQL语句要么全部执行,要么一句也不执行<br>
事务具有一致性:数据库的一个状态经过一个事务运行到另外一个状态<br>
事务具有隔离性:并发执行的多个事务间互不干扰<br>
事务具有持久性:一个事务若成功执行,那它对数据库的影响就是永久的</p>
<p>引入事务的作用有:</p>
<ol>
<li>数据库异常时的恢复(根据数据库的更新策略不同采取的具体措施也不同,commit列表和active列表)</li>
<li>提供事务回滚,能让数据库从一个状态运行到另一个状态</li>
<li>多应用程序并发访问数据库时为这些程序提供隔离方法(加锁,两段锁协议能避免多用户并发访问数据库时发生冲突即事务可串行调度,加锁又可能让系统死锁,死锁的预防策略是一次封锁,等待死亡)</li>
</ol>
<h3 id="什么是死锁什么是活锁">什么是死锁,什么是活锁</h3>
<p>死锁:A申请B占有的排他锁;B也申请A占有的排他锁,导致两个事务都无法推进下去的情况<br>
活锁:A申请B占有的排他锁,B释放锁后给了C...A长期得不到锁</p>
<h3 id="预防死锁的策略">预防死锁的策略:</h3>
<ol>
<li>一次封锁发:任何事务执行前要求它获得所有需要的锁,如果不能获得全部需要的锁就不执行</li>
<li>等待死亡法:为每个事务增加一个时间戳属性,当事务A申请事务B的锁时,比较时间戳,若A比B年轻,事务A回滚,等待某一随机时间再用之前的时间戳申请;若A比B年老,事务A等待事务B释放锁</li>
</ol>
<h3 id="dbms查询优化的策略">DBMS查询优化的策略:</h3>
<ol>
<li>代数优化:DBMS对SQL语句形成的操作树进行处理:在查询结果不变的情况下尽量把一元操作往操作树的叶子部位压</li>
<li>操作优化:用最优的方式执行基本操作,最主要的是连接操作<br>
对连接操作的优化策略有:连接操作时每次从磁盘中取一个块的元组放进缓冲区,对被连接属性的比较在内存中计算,从而减少IO次数,减少连接操作耗时,本质上是用空间换时间.<br>
对连接属性添加B+树索引,有索引的表用做内循环,减少对连接属性的比较时间<br>
对连接属性按照hash映射存储,这样连接属性值相同的就在同一个hash块里,同样增加了对连接属性的比较时间</li>
</ol>
<h3 id="事务对数据库的更新策略有哪些">事务对数据库的更新策略有哪些</h3>
<ol>
<li>更改直接写进数据库:<br>
创建事务-&gt;将事务id写入active列表-&gt;把旧数据记入log-&gt;新数据把旧数据覆盖-&gt;事务id写入commit列表-&gt;事务id从active列表中删除<br>
重启动检查时,若发现事务id只在active列表中出现,那么对该事务进行undo(撤销)操作,回滚事务,然后从active列表删除其id;若事务id在active和commit列表都出现,说明该事务已经对数据库进行了修改,只是还没来得及从commit中删除其id就出了故障,那么只需从commit中删除其id;若只在commit中发现事务id证明事务已经顺利执行完,不做任何事.</li>
<li>更改在commit时写进数据库:<br>
创建事务-&gt;将事务id写入active列表-&gt;把新数据写入log-&gt;当数据写完需要commit时事务id写入commit-&gt;把log中数据写进数据库-&gt;事务id从active中删除<br>
重启检查时,若发现事务id只在active中,在active列表中删除其id<br>
若发现事务id在commit和active中,redo<br>
只在commit中找到,nothing to do</li>
<li>再新建一个进程,一旦磁盘空闲时,这个进程就开始搬数据<br>
创建事务-&gt;把其id写入active列表-&gt;把新数据写入log-&gt;同时如果磁盘空闲,同时把新数据写入数据库-&gt;事务id写入commit列表-&gt;commit事务前检查是否所有需要更爱的数据全部写入数据库-&gt;从active列表删除事务id<br>
重启检查时,若发现事务id只在active列表,undo并且删除active列表中的id<br>
若事务id同时出现在commit列表和active列表,redo<br>
事务id只在commit中,nothing to do</li>
</ol>
<h3 id="多事务并发时候可能会产生冲突这些冲突可能会造成什么影响">多事务并发时候可能会产生冲突,这些冲突可能会造成什么影响:</h3>
<ol>
<li>读写冲突--读脏数据:事务A改了数据1后事务B去读数据1,在事务B读完之后事务A执行异常回滚事务,导致事务B读取到了脏数据</li>
<li>读写冲突--不可重复读:事务A读完数据1后事务B对数据1进行了更改,事务A再次读数据1时和上次读到的不一致</li>
<li>写写冲突--丢失更新:事务A写了数据1还没来得及存回数据库时,事务B读取了数据1,也对其进行修改</li>
</ol>
<h3 id="如何解决这些冲突带来的影响如何让事务间的执行可串行化">如何解决这些冲突带来的影响(如何让事务间的执行可串行化):</h3>
<p>可串行化调度:计算机对并发执行事务的调度是随机的,在计算机中多个并发执行事务的结果是正确的当且仅当它的结果与按某一次序顺序执行时候的结果相同.<br>
加锁:</p>
<ol>
<li>X锁:X锁是排他锁,当对某一数据加了X锁之后其他事务无法再向该数据加锁</li>
<li>X+S锁:X锁排他,S锁不排他.当对某一数据加了S锁时,允许其他事务再对该数据加S锁,但不允许加X锁<br>
加了X锁的数据不允许其他事务对它加任何锁</li>
<li>X+S+U锁:U锁是考虑到对数据库的更改也分为读数据库和写数据库两步,当用户要修改数据库时先申请U锁,加了U锁的数据允许再加S锁,但不允许再加U和X锁</li>
</ol>
<h3 id="两段锁协议">两段锁协议:</h3>
<p>事务分为两个阶段:第一个阶段获得锁,在这个阶段事务可以申请获得任何数据上的任何锁<br>
第二个阶段是释放锁,在这个阶段事务不能再申请任何锁,只能释放锁<br>
若并发事务都遵守两段锁协议则对这些事务的任何并发调度都是可串行化的(是可串行化的策略,并不是避免死锁的)</p>
<h3 id="对数据库的安全性控制有哪些措施">对数据库的安全性控制有哪些措施:</h3>
<ol>
<li>用户身份鉴别:为用户设置密码</li>
<li>访问控制:对用户进行授权</li>
<li>数据加密:对敏感数据加密存储</li>
<li>审计追踪:对关键属性添加审计指令,这些数据就会被监视,当有操作在这些数据上时就会记录</li>
</ol>
<h3 id="为数据库定义约束的方法">为数据库定义约束的方法:</h3>
<ol>
<li>用断言定义: ASSERT ageRe on user:age&gt;0</li>
<li>定义表时用check子句:CREATE TABLE user(id INT,name VARCHAR(10),age INT)CHECK (age&gt;0)</li>
</ol>
<h3 id="常用的聚集函数">常用的聚集函数:</h3>
<ol>
<li>AVG</li>
<li>MIN</li>
<li>MAX</li>
<li>COUNT</li>
<li>SUM</li>
</ol>
<h3 id="group-by使用时的要求">GROUP BY使用时的要求:</h3>
<p>在select指定的字段要么要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中</p>
<h3 id="数据库设计中的各范式及其要求">数据库设计中的各范式及其要求:</h3>
<ol>
<li>1NF:强调列的原子性,即要求不能大表套小表</li>
<li>2NF:1NF+必须有主键+非主键的属性必须完全依赖于主键不能部分依赖</li>
<li>3NF:2NF+非主键必须直接依赖于主键不能传递依赖</li>
<li>BCNF:3NF+若属性A能决定属性B要求属性A必须是主键</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库设计]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-she-ji/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-she-ji/">
        </link>
        <updated>2021-03-07T03:34:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念:</h2>
<h3 id="函数依赖">函数依赖:</h3>
<p>数据库中一个属性的值可以决定其他属性的一个值(id决定名字)</p>
<h3 id="多值依赖">多值依赖:</h3>
<p>一个属性的值可以决定其他属性的一组值(老师的id 决定所上课程)</p>
<h3 id="连接依赖">连接依赖:</h3>
<h2 id="范式">范式:</h2>
<h3 id="1nf不允许大表套小表">1NF:不允许大表套小表</h3>
<h3 id="2nf1nf属性中没有任何元素对主键有部分函数依赖">2NF:1NF+属性中没有任何元素对主键有部分函数依赖</h3>
<p>student(sid,sname,sage,cid,cgrade)<br>
其中主键是(sid,cid),因为成绩cgrade只能由sid+cid唯一决定<br>
但是sname可仅仅用sid决定,即sname,sage对主键存在部分函数依赖</p>
<h4 id="不满足的影响">不满足的影响</h4>
<ol>
<li>插入异常:要插入学生就得插入课程</li>
<li>删除异常:如果学生的所有课需要删除,那么学生信息将被删除</li>
<li>更新异常:学生有五门课程,那么他的基本信息就需要插入五次</li>
</ol>
<h4 id="解决办法">解决办法:</h4>
<p>拆表,一张表只关注一个实体</p>
<h3 id="3nf2nf属性之间无传递依赖">3NF:2NF+属性之间无传递依赖</h3>
<p>1NF消除属性对主键的部分函数依赖-&gt;2NF消除属性间的传递依赖-&gt;3NF<br>
emp(eid,elevel,emoney)<br>
其中工资emoney依赖于elevel<br>
elevel依赖于eid<br>
之间存在传递依赖</p>
<h4 id="不满足的影响-2">不满足的影响:</h4>
<ol>
<li>插入异常:员工级别无法确定时候级别对应的工资无法录入</li>
<li>删除异常:三级的员工都被删掉后,对应的工资状况也就被删了</li>
<li>更新异常:三级的人有五个,则三级对应的工资信息就被重复五次,维护困难</li>
</ol>
<h3 id="bcnf">BCNF:</h3>
<p>A-&gt;B则要求A一定是主键(B函数依赖于A时,要求A一定是主键)</p>
<h4 id="解决办法-2">解决办法:</h4>
<p>拆表<br>
##数据库设计:</p>
<h3 id="面向过程的方法以业务流程为中心不分析数据之间的内在关系">面向过程的方法:以业务流程为中心,不分析数据之间的内在关系</h3>
<h3 id="面向数据的方法">面向数据的方法:</h3>
<h4 id="设计流程">设计流程:</h4>
<ol>
<li>需求分析:数据字典</li>
<li>概念设计:E-R图,独立于DBMS.抽象实体-&gt;定义实体间联系-&gt;画E-R图</li>
<li>逻辑设计:外模式设计,数据类型设计.建表,把E-R图生成表(命名规则,数据类型),必要时定义视图</li>
<li>物理设计:索引,文件结构(堆文件,簇集,hash文件)分区设计(大型数据库才有)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库安全及完整性约束]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-an-quan/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-an-quan/">
        </link>
        <updated>2021-03-06T13:42:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用手段">常用手段:</h2>
<h3 id="访问授权">访问授权</h3>
<h4 id="dba创建新用户并对新用户进行访问数据库的基本授权">DBA创建新用户并对新用户进行访问数据库的基本授权</h4>
<ol>
<li>
<p>对用户授权<br>
<code>SQL GRANT CONNECT TO WANGMING IDENTIFIED BY 123456;</code><br>
wangming用户可以用初始密码123456连接数据库<br>
<code>SQL GRANT SELECT ON TABLE USER TO WANGMING WITH GRANT OPTION</code><br>
用户WANGMING有查询user表的权利,并且可以把这个权利转售给其他人(WITH GRANT OPTION)</p>
</li>
<li>
<p>创建角色,然后为某用户直接给角色</p>
</li>
</ol>
<h3 id="数据加密">数据加密:</h3>
<p>对数据库的访问需要通过DBMS,不能直接在操作系统层访问<br>
对数据加密后存储进数据库</p>
<h3 id="审计追踪">审计追踪:</h3>
<p>由于不能保证数据库一定安全,设计审计追踪环节.<br>
在关注的数据上面添加审计指令,对所监视的表任何指令记录.</p>
<h3 id="完整性约束">完整性约束:</h3>
<p>对数据库中一些属性的约束条件(数据库中合法的实例必须满足这个要求)</p>
<h4 id="静态约束">静态约束:</h4>
<ol>
<li>
<p>数据模型固有的约束(1NF),关系模型要求的</p>
</li>
<li>
<p>隐含约束:<br>
如域完整性约束;<br>
主键约束(实体完整性约束);<br>
外键约束(引用完整性约束):若buy表中UID是user中ID的外键,则要求UID是ID的子集;删除时候级联删除或者不删;插入时候buy表中的UID必须在user中的id里存在</p>
</li>
<li>
<p>显示约束:<br>
定义方法一:用断言<br>
<code>SQL ASSERT ageRe ON user:age&gt;0;</code><br>
ageRe是我对断言取得名字,ageRe要求对user插入数据时候age必须&gt;0</p>
<p>定义方法二:定义表时用check<br>
<code>SQL CREATE TABLE user (id INTEGER, name CHAR(10), age INTEGER, rating INTEGER, PRIMARY KEY(id,name), CHECK (age&gt;0 AND rating&gt;0))</code><br>
定义方法三:定义CONSTRAINT<br>
<code>SQL CREATE TABLE buy (tname CHAR(10), tid INTEGER, uid INTEGER, day DATE, PRIMARY KEY(tid,day), CONSTRAINT noFood CHECK('food' &lt;&gt; (SELECT T.name FROM thing T WHERE T.id=tid)))</code><br>
定义了一个包含关联查询的约束noFood,其含义为当thing中name是food时候不允许其插入buy</p>
</li>
</ol>
<h4 id="动态约束">动态约束:</h4>
<p>数据库从一个状态到另一个状态时应该满足的约束(与触发器结合)</p>
<h5 id="触发器">触发器:</h5>
<p>数据库状态发生变化时应该遵守的规则<br>
数据库一般是被动执行某些SQL语句,然而我们希望当数据库中数据处于某一状态时数据能主动的发出一些动作.这就需要数据库去监视一些数据.支持触发器即支持ECA规则</p>
<h6 id="基本概念">基本概念:</h6>
<ol>
<li>事件E监视某一事件</li>
<li>条件C事件发生时是否满足条件</li>
<li>动作A若满足采取行动</li>
</ol>
<h6 id="基本语法">基本语法</h6>
<p>每当在user表里插入一条消息时候去查看其年龄是否满足年轻用户的条件,如果满足同时加入年轻用户表(保证在年轻用户表里的用户都在用户表)<br>
<code>SQL CREATE TRIGGER youngUser AFTER INSERT ON user REFERENCING NEW TABLE newUser FOR EACH STATEMENT INSERT INTO youngUser (id,name,age,rating) SELECT id,name,age,rating FROM newUser N WHERE N.age &lt;= 18</code><br>
AFTER BEFORE 都是监听的事件,以上是监听插入user表时候触发.<br>
REFERENCING NEW表示引用的是插入语句中的新值(也可用OLD)TABLE表示新插入的值被看作一张表并且为其取名newUser.整句含义为,对user表中新插入的语句我看作一张新表newUser,并且使用它的新值.<br>
FOR EACH STATEMENT 表示对每一条插入的语句(操作粒度也可以是一条元组,一个值或者一个表)做操作</p>
<h6 id="执行规则">执行规则:</h6>
<p>立即执行:当事件发生时候立即去检查是否满足条件</p>
<h6 id="连锁触发">连锁触发:</h6>
<p>当发生某个事件并满足条件导致触发触发器时候,被触发的语句也是SQL语句,SQL语句也可能触发其他的触发器,导致连锁触发<br>
方案:限制连锁触发的次数</p>
]]></content>
    </entry>
</feed>