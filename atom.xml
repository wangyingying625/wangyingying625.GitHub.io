<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-07T08:47:48.321Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[数据库设计]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-she-ji/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-she-ji/">
        </link>
        <updated>2021-03-07T03:34:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念:</h2>
<h3 id="函数依赖">函数依赖:</h3>
<p>数据库中一个属性的值可以决定其他属性的一个值(id决定名字)</p>
<h3 id="多值依赖">多值依赖:</h3>
<p>一个属性的值可以决定其他属性的一组值(老师的id 决定所上课程)</p>
<h3 id="连接依赖">连接依赖:</h3>
<h2 id="范式">范式:</h2>
<h3 id="1nf不允许大表套小表">1NF:不允许大表套小表</h3>
<h3 id="2nf1nf属性中没有任何元素对主键有部分函数依赖">2NF:1NF+属性中没有任何元素对主键有部分函数依赖</h3>
<p>student(sid,sname,sage,cid,cgrade)<br>
其中主键是(sid,cid),因为成绩cgrade只能由sid+cid唯一决定<br>
但是sname可仅仅用sid决定,即sname,sage对主键存在部分函数依赖</p>
<h4 id="不满足的影响">不满足的影响</h4>
<ol>
<li>插入异常:要插入学生就得插入课程</li>
<li>删除异常:如果学生的所有课需要删除,那么学生信息将被删除</li>
<li>更新异常:学生有五门课程,那么他的基本信息就需要插入五次</li>
</ol>
<h4 id="解决办法">解决办法:</h4>
<p>拆表,一张表只关注一个实体</p>
<h3 id="3nf2nf属性之间无传递依赖">3NF:2NF+属性之间无传递依赖</h3>
<p>1NF消除属性对主键的部分函数依赖-&gt;2NF消除属性间的传递依赖-&gt;3NF<br>
emp(eid,elevel,emoney)<br>
其中工资emoney依赖于elevel<br>
elevel依赖于eid<br>
之间存在传递依赖</p>
<h4 id="不满足的影响-2">不满足的影响:</h4>
<ol>
<li>插入异常:员工级别无法确定时候级别对应的工资无法录入</li>
<li>删除异常:三级的员工都被删掉后,对应的工资状况也就被删了</li>
<li>更新异常:三级的人有五个,则三级对应的工资信息就被重复五次,维护困难</li>
</ol>
<h3 id="bcnf">BCNF:</h3>
<p>A-&gt;B则要求A一定是主键(B函数依赖于A时,要求A一定是主键)</p>
<h4 id="解决办法-2">解决办法:</h4>
<p>拆表<br>
##数据库设计:</p>
<h3 id="面向过程的方法以业务流程为中心不分析数据之间的内在关系">面向过程的方法:以业务流程为中心,不分析数据之间的内在关系</h3>
<h3 id="面向数据的方法">面向数据的方法:</h3>
<h4 id="设计流程">设计流程:</h4>
<ol>
<li>需求分析:数据字典</li>
<li>概念设计:E-R图,独立于DBMS.抽象实体-&gt;定义实体间联系-&gt;画E-R图</li>
<li>逻辑设计:外模式设计,数据类型设计.建表,把E-R图生成表(命名规则,数据类型),必要时定义视图</li>
<li>物理设计:索引,文件结构(堆文件,簇集,hash文件)分区设计(大型数据库才有)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库安全及完整性约束]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-an-quan/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-an-quan/">
        </link>
        <updated>2021-03-06T13:42:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用手段">常用手段:</h2>
<h3 id="访问授权">访问授权</h3>
<h4 id="dba创建新用户并对新用户进行访问数据库的基本授权">DBA创建新用户并对新用户进行访问数据库的基本授权</h4>
<ol>
<li>
<p>对用户授权<br>
<code>SQL GRANT CONNECT TO WANGMING IDENTIFIED BY 123456;</code><br>
wangming用户可以用初始密码123456连接数据库<br>
<code>SQL GRANT SELECT ON TABLE USER TO WANGMING WITH GRANT OPTION</code><br>
用户WANGMING有查询user表的权利,并且可以把这个权利转售给其他人(WITH GRANT OPTION)</p>
</li>
<li>
<p>创建角色,然后为某用户直接给角色</p>
</li>
</ol>
<h3 id="数据加密">数据加密:</h3>
<p>对数据库的访问需要通过DBMS,不能直接在操作系统层访问<br>
对数据加密后存储进数据库</p>
<h3 id="审计追踪">审计追踪:</h3>
<p>由于不能保证数据库一定安全,设计审计追踪环节.<br>
在关注的数据上面添加审计指令,对所监视的表任何指令记录.</p>
<h3 id="完整性约束">完整性约束:</h3>
<p>对数据库中一些属性的约束条件(数据库中合法的实例必须满足这个要求)</p>
<h4 id="静态约束">静态约束:</h4>
<ol>
<li>
<p>数据模型固有的约束(1NF),关系模型要求的</p>
</li>
<li>
<p>隐含约束:<br>
如域完整性约束;<br>
主键约束(实体完整性约束);<br>
外键约束(引用完整性约束):若buy表中UID是user中ID的外键,则要求UID是ID的子集;删除时候级联删除或者不删;插入时候buy表中的UID必须在user中的id里存在</p>
</li>
<li>
<p>显示约束:<br>
定义方法一:用断言<br>
<code>SQL ASSERT ageRe ON user:age&gt;0;</code><br>
ageRe是我对断言取得名字,ageRe要求对user插入数据时候age必须&gt;0</p>
<p>定义方法二:定义表时用check<br>
<code>SQL CREATE TABLE user (id INTEGER, name CHAR(10), age INTEGER, rating INTEGER, PRIMARY KEY(id,name), CHECK (age&gt;0 AND rating&gt;0))</code><br>
定义方法三:定义CONSTRAINT<br>
<code>SQL CREATE TABLE buy (tname CHAR(10), tid INTEGER, uid INTEGER, day DATE, PRIMARY KEY(tid,day), CONSTRAINT noFood CHECK('food' &lt;&gt; (SELECT T.name FROM thing T WHERE T.id=tid)))</code><br>
定义了一个包含关联查询的约束noFood,其含义为当thing中name是food时候不允许其插入buy</p>
</li>
</ol>
<h4 id="动态约束">动态约束:</h4>
<p>数据库从一个状态到另一个状态时应该满足的约束(与触发器结合)</p>
<h5 id="触发器">触发器:</h5>
<p>数据库状态发生变化时应该遵守的规则<br>
数据库一般是被动执行某些SQL语句,然而我们希望当数据库中数据处于某一状态时数据能主动的发出一些动作.这就需要数据库去监视一些数据.支持触发器即支持ECA规则</p>
<h6 id="基本概念">基本概念:</h6>
<ol>
<li>事件E监视某一事件</li>
<li>条件C事件发生时是否满足条件</li>
<li>动作A若满足采取行动</li>
</ol>
<h6 id="基本语法">基本语法</h6>
<p>每当在user表里插入一条消息时候去查看其年龄是否满足年轻用户的条件,如果满足同时加入年轻用户表(保证在年轻用户表里的用户都在用户表)<br>
<code>SQL CREATE TRIGGER youngUser AFTER INSERT ON user REFERENCING NEW TABLE newUser FOR EACH STATEMENT INSERT INTO youngUser (id,name,age,rating) SELECT id,name,age,rating FROM newUser N WHERE N.age &lt;= 18</code><br>
AFTER BEFORE 都是监听的事件,以上是监听插入user表时候触发.<br>
REFERENCING NEW表示引用的是插入语句中的新值(也可用OLD)TABLE表示新插入的值被看作一张表并且为其取名newUser.整句含义为,对user表中新插入的语句我看作一张新表newUser,并且使用它的新值.<br>
FOR EACH STATEMENT 表示对每一条插入的语句(操作粒度也可以是一条元组,一个值或者一个表)做操作</p>
<h6 id="执行规则">执行规则:</h6>
<p>立即执行:当事件发生时候立即去检查是否满足条件</p>
<h6 id="连锁触发">连锁触发:</h6>
<p>当发生某个事件并满足条件导致触发触发器时候,被触发的语句也是SQL语句,SQL语句也可能触发其他的触发器,导致连锁触发<br>
方案:限制连锁触发的次数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库管理系统(DBMS)]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-guan-li-xi-tong-dbms/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-guan-li-xi-tong-dbms/">
        </link>
        <updated>2021-03-05T11:20:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据库管理系统的体系结构">数据库管理系统的体系结构:</h2>
<h3 id="dbms组成结构把用户的sql落实到对磁盘的操作">DBMS组成结构:(把用户的SQL落实到对磁盘的操作)</h3>
<ol>
<li>语法分析器:对用户提交的SQL语句进行语法分析</li>
<li>授权检查:检查某用户是否有权限执行该语句</li>
<li>语义分析和查询处理</li>
<li>访问管理:如何把表存储为磁盘中的文件流(实现关系模型,为上层提供表)<br>
因为其在最底层,所以这层提供的函数就是访问原语,实现关系模型的基本概念</li>
</ol>
<h3 id="文件存储类型">文件存储类型:</h3>
<ol>
<li>堆文件:只能顺序查询</li>
<li>哈希文件:如果用户经常按照某属性查询,则对该属性做哈希,哈希值就是存储地址</li>
<li>堆文件和B+树索引(有用节点都在叶子节点,中间节点都是路标):索引可以在不同属性上建多个</li>
</ol>
<h3 id="数据库系统中对底层操作系统的访问类型">数据库系统中对底层操作系统的访问类型:</h3>
<ol>
<li>查询大多数元组:堆文件</li>
<li>查询某个范围元组:B+树叶子节点的范围</li>
<li>查询某个特定元组:B+树</li>
</ol>
<h3 id="关系型数据库常用索引方式">关系型数据库常用索引方式:</h3>
<ol>
<li>B+树</li>
<li>簇集:向操作系统申请一块连续的内存空间,按照某个属性递增或者递减存储元组(要求该属性更新少)</li>
</ol>
<h3 id="编程语言中使用数据库的流程">编程语言中使用数据库的流程:</h3>
<p>连接数据库:向系统请求一个DBMS核心进程,建立一个通讯管道,应用与数据库管理系统间通过管道进行通信(两个pipe,一写一读)<br>
应用程序-----------------------------&gt;DBMS核心进程(发SQL)<br>
应用程序&lt;-----------------------------DBMS核心进程(返回结果)<br>
属于同一个进程空间的线程可以共享进程资源</p>
<h2 id="数据库管理系统的接口">数据库管理系统的接口:</h2>
<h2 id="查询优化">查询优化:</h2>
<h3 id="代数优化把用户提交的sql语句在执行结果不变的情况下转换为执行效率更高的模式">代数优化:把用户提交的SQL语句在执行结果不变的情况下转换为执行效率更高的模式</h3>
<p>相当于把  x²+xy+y²优化为(x+y)²;<br>
DBMS首先把SQL语句解析为关系操作树,然后对操作树中的操作进行转化<br>
对关系运算顺序和结构进行调整,尽量减小二元操作的被操作规模(即尽量使一元操作处于树的叶子部分或离叶子最近的部分)类似于哈弗曼树(代价最小的往树叶子方向放)<br>
基本原则:</p>
<ol>
<li>符合等价条件的基础上,尽可能使一元操作接近树的叶子</li>
<li>寻找合并多次使用的公共子表达式</li>
</ol>
<h3 id="操作优化找最有效的方法实现操作关键是连接操作">操作优化:找最有效的方法实现操作(关键是连接操作)</h3>
<p>对已经经过代数优化优化过的查询树上的操作进行优化,关键在于连接操作的优化<br>
连接操作:有两张表分别命名A和B,A与B有一列表示含义相同,当这一列中的值相等时,把A和B中的信息拼接</p>
<ol>
<li>嵌套循环(最基本的实现):遍历A表(A表做外循环),对每一条去扫描B一次,查询其对应属性是否相等,若相等则拼接</li>
<li>减少IO时间(用内存空间换时间):由于对磁盘进行一次IO操作读取到的是一个物理块,则对外循环取一个物理块进内存,内循环也分别取一个物理块进内存,然后在内存(缓冲区)里对每一个物理块的众多元组进行比较.<br>
效果:若一个物理块能放十条元组,则外循环减少1/10,外循环减少到1/100,共减少1/100</li>
<li>归并扫描:参与连接的两个关系按照各自连接属性的值在磁盘上做好外排序,只需要对内外表各扫描一次</li>
<li>在连接属性上建立B+树索引:让有索引的表用作内循环的表</li>
<li>利用hash文件:要求连接属性上很少有更新.把关系A与关系B分别按照连接属性散列到一个hash文件,则能够散列的元组分别在两个表的同一个hash值块内.</li>
<li>适用于用索引并不高效的情况(当一个值在元组中出现的次数过多时候):此时用B+树或者hash索引到的结果有好多个,再去磁盘中多次取这些值效率反而不如直接顺序扫描高</li>
</ol>
<h2 id="事务管理">事务管理:</h2>
<h3 id="事务transaction对数据库的基本操作单位">事务(transaction):对数据库的基本操作单位</h3>
<p>是对数据库一组基础操作的集合(一组SQL语句)满足如下性质(ACID):</p>
<ol>
<li>原子性:这些SQL语句要么全部执行成功,要么一条也不做</li>
<li>一致性:从数据库的一个一致状态经过一个事务的运行达到另外一个一致状态</li>
<li>隔离性:在一个多用户的数据库系统里有很多并发事务在同时运行,要求并发的事务之间不能互相干扰,让每个人感觉像是独占数据库一样.(操作系统的分时系统,仿佛每个进程独占CPU.Windows系统中一个进程故障有时候会引起整个系统卡死;电脑不能长期不关机等都是由于进程间隔离不够好.)</li>
<li>持久性:一个事务只要完成,它对数据库产生的影响应该长久反映在数据库里,即使出现故障也必须是可以恢复的</li>
</ol>
<p>实现机制:<br>
有两个事务列表:commit列表和active列表.其中active列表存放正在进行的事务,commit列表存放已经执行完的事务<br>
事务作用:</p>
<ol>
<li>回滚rollback:如果回滚,则这个事务对数据库产生不了任何的影响.转账过程定义成事务</li>
<li>提交commit:事务正常终止,</li>
</ol>
<p>如果不显式定义事务,系统默认把一条SQL语句当做一个事务</p>
<h3 id="恢复">恢复:</h3>
<h4 id="减少出故障的可能性防">减少出故障的可能性(防):</h4>
<h4 id="从故障中恢复治">从故障中恢复(治):</h4>
<h5 id="基本方法">基本方法:</h5>
<ol>
<li>长时间进行定时数据库备份(dumping)</li>
<li>短时间进行增量转储(只对数据库中变化部分进行记录)   可能会丢失部分更新</li>
<li>备份+日志:日志是对自从上次备份数据库以来用户对数据库的全部操作的记录---&gt;change的old value(BI)和new value(AI);当故障时候通过备份恢复数据库,然后使用日志文件对恢复的数据库进行操作,恢复到离故障最近的位置.对发生故障时候进行到一半的操作能恢复到之前状态(old value),已经进行完的恢复到(new value)</li>
</ol>
<h5 id="更新策略">更新策略:</h5>
<h6 id="对数据的更改直接写入数据库">对数据的更改直接写入数据库:</h6>
<ol>
<li>流程:<br>
创建事务并把事务id写入active列表-&gt;把旧数据计入log-&gt;用新的数据覆盖数据库中的旧数据-&gt;事务id写入commit列表-&gt;从active中删除事务id</li>
<li>恢复:(可能undo)<br>
重启动恢复模块:在每次数据库启动时候去检查上一次操作结果.对数据库系统中曾经运行过的每个事务id检查两张事务列表:<br>
若发现某事务id只在active列表未在commit列表说明这个事务是进行一半的事务,对其结果进行还原(undo),然后从active列表中删除其id.<br>
若某事务的id在两个列表都查到了意味着该事务对数据库的操作已经完成,只是还没来得及从active列表中删除自己的id就出现故障,那么就帮它在active中删掉其id<br>
若在commit中找到在active中未找到,nothing to do.<br>
然而从事务运行开始会有成千上万的事务,总不能让数据库系统每次打开时候都去从头开始检查他们吧,为此,提出来检查点(check point)的概念,有了检查点,数据库系统只需检查从上个检查点处之后的事务进行检查</li>
</ol>
<h6 id="等事务进行到commit阶段时候再去更新数据库在这之前不改数据库只改log并发度更高加排他锁的时间可以更靠后ux锁">等事务进行到commit阶段时候再去更新数据库,在这之前不改数据库只改log(并发度更高,加排他锁的时间可以更靠后)(UX锁)</h6>
<ol>
<li>流程:<br>
创建事务并把其id写入active列表-&gt;把新数据写入log-&gt;当把所有要更新的数据都写入log时(遇到commit语句)把新数据放入数据库-&gt;从active中删除事务id</li>
<li>恢复:(可能redo)<br>
对从上个检查点以来的事务去查两张事务id列表:<br>
在active列表找到commit未找到:从active中删掉id<br>
在两个列表都找到:redo该事务<br>
只在commit列表找到:nothing to do</li>
</ol>
<h6 id="同时并发进行">同时并发进行</h6>
<ol>
<li>流程:<br>
创建事务并把其id写入active列表-&gt;新数据与旧数据都写入log-&gt;同时如果磁盘空闲则同步进行新数据写入数据库的进程-&gt;事务id写入commit列表-&gt;当新旧数据写入log的操作执行完毕时候再去检查是否所有新数据都写入了数据库-&gt;从commit列表删除事务id</li>
<li>恢复:(可能undo也可能redo)<br>
active中有id:undo,并且从active中删除其id<br>
两张表中都查到:redo,从active中删除其id<br>
只在nothing中查到:nothing to do</li>
</ol>
<h3 id="多事务并发控制并发事务的可串行化">多事务并发控制(并发事务的可串行化):</h3>
<p>要求两个并发执行的事务对数据库产生的结果不因事务调度次序的不同而不同,即结果和一系列事务按某一特定顺序执行的结果一致.</p>
<h4 id="产生条件">产生条件:</h4>
<ol>
<li>改善系统利用率</li>
<li>不同的事务可能访问数据库的不同部分(两事物间可能没有冲突)</li>
</ol>
<h4 id="事务冲突当两个或者以上事务同时对同一部分处理时">事务冲突(当两个或者以上事务同时对同一部分处理时):</h4>
<h5 id="可能影响">可能影响:</h5>
<ol>
<li>丢失更新(写写冲突)<br>
<img src="https://wangyingying625.github.io/post-images/1615031827200.png" alt="" loading="lazy"><br>
如图所示,丢掉T1对数据的更改</li>
<li>读脏数据(读写冲突)<br>
<img src="https://wangyingying625.github.io/post-images/1615032143699.png" alt="" loading="lazy"><br>
T2读到T1正在改的脏数据</li>
<li>不可重复读(读写冲突)<br>
<img src="https://wangyingying625.github.io/post-images/1615032347784.png" alt="" loading="lazy"><br>
T1连续两次读的值不一样</li>
</ol>
<h5 id="解决方案">解决方案:</h5>
<p>可串行化:多个事务的调度次序无论是什么样都不改变最终结果<br>
<img src="https://wangyingying625.github.io/post-images/1615032951751.png" alt="" loading="lazy"><br>
如图:T1和T2在X2上有冲突;T2和T3在X1上有冲突</p>
<h6 id="加锁">加锁:</h6>
<p>要求每个事务对数据库中的数据读写操作时候需申请锁,并发执行的结果到底等于怎样的次序执行的序列完全取决于哪个事务先抢到锁<br>
####### 两段锁协议:</p>
<ol>
<li>申请要求<br>
-----------------------------------|某没有锁的数据|有X锁的数据<br>
没有锁的事务申请-----------|----允许------------|---允许<br>
有X锁的事务申请------------|----允许------------|---不允许<br>
X锁排他,一个数据有事务申请了他的X锁时候不允许别的事务申请</li>
<li>版本变化:<br>
两段加锁协议:2PL+serializable+well-fromed<br>
<img src="https://wangyingying625.github.io/post-images/1615034491383.png" alt="" loading="lazy"><br>
即某一事务只在某一阶段申请锁,另一阶段只释放锁,一旦释放再不申请新锁<br>
仍然会有rollback时候产生多米诺效应的读脏数据<br>
原因在于过早释放写锁<br>
推迟修改锁的释放:<br>
在事务commit时候再释放修改锁<br>
所有锁都在commit时候释放(严格的两段锁)<br>
####### (S,X)锁协议:<br>
排他锁和共享锁,事务如果只读申请S(共享)锁,如果有更新申请X(排他)锁</li>
<li>申请要求<br>
-----------------------------------|某没有锁的数据|有S锁的数据|有X锁的数据<br>
没有锁的事务申请----------|----允许------------|---允许----------|允许<br>
有S锁的事务申请------------|----允许------------|---允许---------|不允许<br>
有X锁的事务申请------------|----允许------------|----不允许-----|不允许<br>
X锁排他,只要申请的数据之前有锁那就申请不到;比起上个版本读效率更高<br>
####### (S,U,X)锁<br>
写数据时候是先申请数据,再改,为了缩短排他锁的时间增加U锁<br>
当更新数据时候先申请U锁真正改数据时候才把U锁换为X锁</li>
<li>申请要求(相容矩阵)<br>
-----------------------------------|某没有锁的数据|有S锁的数据|有U锁的数据|有X锁的数据<br>
没有锁的事务申请----------|----允许------------|---允许----------|----允许-------|允许<br>
有S锁的事务申请------------|----允许------------|---允许---------|----允许--------|不允许<br>
有U锁的事务申请------------|----允许------------|----允许-------|------不允许----|不允许<br>
有X锁的事务申请------------|----允许------------|----不允许-----|-----不允许----|不允许</li>
</ol>
<h6 id="死锁">死锁:</h6>
<p>只要事务等待某一锁的时间超过一个限定那就认为产生了死锁<br>
解决办法:<br>
为每个事务建立一个时间戳</p>
<ol>
<li>等待死亡法:<br>
T1若想要申请一个锁,但是此锁被T2占有,则T1比较它与T2的时间戳,谁更老,如果它更老就等待T2释放锁,否则就回滚自己,等一个随机事件再次申请(时间戳不改还是上次的)<br>
采用这种方法,等待关系只可能是年老的等年轻的,方向是单向的;并且由于比该事务年老的事务总是有限的所以它总能等到想要的锁</li>
<li>被伤等待法:<br>
遇到比自己年老的就会被人家kill</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker使用笔记]]></title>
        <id>https://wangyingying625.github.io/post/docker-shi-yong-bi-ji/</id>
        <link href="https://wangyingying625.github.io/post/docker-shi-yong-bi-ji/">
        </link>
        <updated>2021-03-05T03:12:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用命令">常用命令</h2>
<ol>
<li>查找容器id:docker ps</li>
<li>启动docker-compose:docker-compose up -d</li>
<li>进入容器:</li>
<li>docker images</li>
</ol>
<h2 id="零碎知识">零碎知识</h2>
<ol>
<li>docker不用进文件夹</li>
<li>docker-compose需要进文件夹</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语言]]></title>
        <id>https://wangyingying625.github.io/post/sql-yu-yan/</id>
        <link href="https://wangyingying625.github.io/post/sql-yu-yan/">
        </link>
        <updated>2021-03-04T11:48:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="sql语言一种非过程化的关系演算语言">SQL语言(一种非过程化的关系演算语言):</h1>
<h2 id="常用名词">常用名词</h2>
<ol>
<li>基表:存在于物理磁盘内的一张表</li>
<li>视图:虚表,根据用户的需要映射出的表,并不真正存在于物理磁盘</li>
<li>保留字:<br>
NULL:空值<br>
UNIQUE:说明表的某一属性值是否允许重复<br>
DEFAUIT:为某一属性指定缺省值<br>
PRIMARY KEY:用来指定某一属性为主键<br>
FOREIGN KEY:用来指明某一属性是外键<br>
CHECK:定义表时为某一属性进行检查是否符合某要求</li>
</ol>
<h2 id="sql的四种子语言">SQL的四种子语言:</h2>
<ol>
<li>DDL:(Data Definition Language):用来定义删除维护数据模式(表的创建与删除,视图的创建与删除,修改表的模式),多用图形化工具操作</li>
<li>QL(Query Language):查询语言,对数据库里的数据进行查询,查询出满足条件的数据</li>
<li>DML(Data Manipulation Language):数据操作语言,对数据库里已经存在的数据进行增删改</li>
<li>DCL(Data Control Language):管理数据库的用户权限(授权,创建用户,完整性约束,审计)</li>
</ol>
<h2 id="sql语言的基本模式">SQL语言的基本模式</h2>
<p>SELECT [DISTINCT] 目标列 FROM 表名 WHERE 查询条件 GROUP BY 分组属性 HAVING 分组条件</p>
<h2 id="sql语言的执行策略">SQL语言的执行策略:</h2>
<ol>
<li>根据FROM后的表名做笛卡尔乘积得到表A</li>
<li>用WHERE后面的条件对表A进行筛选得到符合条件的表B</li>
<li>对表B中的信息按照GROUP BY后的分组属性分组,对属性相同的元组分成一组</li>
<li>对分好组的表按照HAVING后的分组条件再次筛选,筛选出符合条件的组</li>
<li>在选好的组中根据SELECT后的信息进行投影,每个组出一条元组<br>
SELECT的属性和HAVING属性必须是分组属性集的子集</li>
</ol>
<p><img src="https://wangyingying625.github.io/post-images/1614835018824.png" alt="" loading="lazy"><br>
表名为table1,其中id自增为主键<br>
<img src="https://wangyingying625.github.io/post-images/1614835029464.png" alt="" loading="lazy"><br>
表名为shop,其中id自增为主键</p>
<p>执行SQL语句:<br>
<code>SQL SELECT T.name FROM table1 T,shop S WHERE T.id=S.id</code><br>
执行结果如下图:<br>
<img src="https://wangyingying625.github.io/post-images/1614835041033.png" alt="" loading="lazy"></p>
<h2 id="ql语言">QL语言</h2>
<h3 id="模糊查询like">模糊查询like:</h3>
<ol>
<li>_(下划线)表示匹配任意字符</li>
<li>%表示匹配任意0 到多个字符<br>
<code>SQL SELECT T.name FROM table1 T WHERE T.name LIKE 'w_%i'</code><br>
执行结果如下图:<br>
<img src="https://wangyingying625.github.io/post-images/1614835904286.png" alt="" loading="lazy"></li>
</ol>
<h3 id="起别名as">起别名AS:</h3>
<p><code>SQL SELECT T.id+1 AS id1 FROM table1 T WHERE T.name LIKE 'w_%i'</code><br>
结果如下<br>
<img src="https://wangyingying625.github.io/post-images/1614836268735.png" alt="" loading="lazy"></p>
<h3 id="连接union">连接UNION:</h3>
<p>union是关系代数中的并(∪)操作扩展而来的,所以要满足并操作的条件<br>
并操作:把两个关系模式相同的元组组合<br>
即要求UNION前后两句sql查询到的表列数相同<br>
<code>SQL SELECT name FROM table1 WHERE id=1 UNION SELECT number FROM shop WHERE name='food'</code><br>
结果如下<br>
<img src="https://wangyingying625.github.io/post-images/1614836988247.png" alt="" loading="lazy"></p>
<h3 id="自连接">自连接:</h3>
<p>新建一张购买表buy,信息如下:<br>
<img src="https://wangyingying625.github.io/post-images/1614838025350.png" alt="" loading="lazy"><br>
若要查询既买了food又买了cloth的用户名<br>
<code>SQL SELECT T.name FROM table1 T,buy B1,buy B2 WHERE B1.uid=B2.uid AND (B1.sid=1 AND B2.sid=2) AND T.id=B1.uid</code><br>
<img src="https://wangyingying625.github.io/post-images/1614838719827.png" alt="" loading="lazy"></p>
<h3 id="交intersect部分数据库支持">交INTERSECT(部分数据库支持):</h3>
<p>实现查询既买了food又买了cloth的用户名<br>
<code>SQL SELECT T.name FROM table1 T,buy B WHERE B.uid=T.id AND B.sid=1 INTERSECT SELECT T.name FROM table1 T,buy B WHERE B.uid=T.id AND B.sid=2</code></p>
<h3 id="嵌套查询">嵌套查询:</h3>
<ol>
<li>非关联嵌套(子查询的条件与父查询无关):<br>
查询买了food的用户名<br>
<code>SQL SELECT T.name FROM table1 T WHERE T.id IN(SELECT B.uid FROM buy B WHERE B.sid=1)</code><br>
对每个用户扫描,查看其id是否在买过food的表的id里面,若在返回id对应的姓名</li>
<li>关联嵌套查询(嵌套的子查询条件与父查询相关):<br>
例1. 查询买过food用户的名称:<br>
<code>SQL SELECT T.name FROM table1 T WHERE EXISTS (SELECT * FROM buy B WHERE B.uid=T.id AND B.sid=1)</code><br>
如果某用户买过food,那么在buy表中必然存在一条记录,其uid等于该用户id且sid等于1<br>
对table1中的每个用户遍历,查看是否在buy表中存在符合上述条件的元组<br>
相当于二重循环,对外层循环中的每条元组都做一次内层循环</li>
</ol>
<p>例2. 查只有一个人买的商品<br>
<code>SQL SELECT B.sid FROM buy B WHERE B.sid NOT IN (SELECT B1.sid FROM buy B1 WHERE B.uid!=B1.uid)</code><br>
查出表中除用户1 外其他用户买的商品,如果用户1买的商品不在其他用户买的商品列表里,则用户1买的商品就是只有一人买的<br>
对buy表扫描,查看当前这条购买的这个人,除他以外其他人都买了什么,如果他买的东西不在其他人买的东西的列表那就满足条件<br>
构造步骤:<br>
查询只有除我外其他人购买了的商品:SELECT 商品 FROM 购物表 WHERE 购买者!=我<br>
查出我只有我买的商品:SELECT 商品 FROM 购物表1 WHERE 商品 NOT IN (SELECT 商品 FROM 购物表 2 WHERE 购买者!=我)<br>
遍历到所有人:SELECT 商品 FROM 购物表1 WHERE 商品 NOT IN (SELECT 商品 FROM 购物表 2 WHERE 购买者!=购物表1中对应购买者)</p>
<h3 id="聚集函数">聚集函数</h3>
<ol>
<li>COUNT(*)某表的元组数</li>
<li>COUNT([DISTINCT] A)某表中属性值A的不同值个数,属性A的值不一样时候加一</li>
<li>SUM([DISTINCT] A)对属性A进行累计求和</li>
<li>AVG([DISTINCT] A)属性A的平均值</li>
<li>MAX(A)</li>
<li>MIN(A)</li>
</ol>
<h3 id="分组group-by">分组GROUP BY</h3>
<ol>
<li>模式:GROUP BY( )</li>
<li>功能:对表中信息按照条件分组,条件相同即为一组</li>
<li>要求对分组得到的每个组它的属性在SELECT上必须是单一的(因为每个组最终只出一条信息,若不单一就无法继续)简单来说就是要求SELECT和HAVING后的属性都必须是GROUP BY后的属性的子集</li>
</ol>
<h3 id="having">HAVING</h3>
<p>SELECT的属性和HAVING属性必须是分组属性集的子集</p>
<ol>
<li>模式:HAVING</li>
<li>功能:对分好组后的信息按照条件筛选<br>
例1:<br>
定义user表如下<br>
<img src="https://wangyingying625.github.io/post-images/1614859980796.png" alt="" loading="lazy"><br>
查询年龄大于25的用户里每个级别最年轻用户的年龄并且每个级别里用户数要大于1<br>
<code>SQL SELECT U.rating,MIN(U.age) AS minAge FROM user U WHERE U.age &gt;25 GROUP BY U.rating HAVING COUNT(*)&gt;1</code><br>
结果如下:<br>
<img src="https://wangyingying625.github.io/post-images/1614860466747.png" alt="" loading="lazy"><br>
执行过程<br>
对表中信息按照rating属性排序,得到:<br>
rating   age<br>
3         33<br>
5          34<br>
7           45<br>
7           36<br>
8           45<br>
10          33<br>
分出5组<br>
再根据HAVING的条件进行筛选组,得到<br>
7           45<br>
7           36<br>
对SELECT后的条件进行映射<br>
得到<br>
7           36<br>
查询平均年龄最小的等级<br>
<code>SQL SELECT Temp.rating FROM ( SELECT S.rating ,AVG(S.age) AS avgage FROM user S GROUP BY S.rating ) AS Temp WHERE temp.avgage=(SELECT MIN (Temp.avgage))</code><br>
生成了临时表Temp</li>
</ol>
<h3 id="case表达式">CASE表达式</h3>
<p><code>SQL SELECT name,CASE status WHEN 1 THEN 'admin' WHEN 2 THEN 'user' ELSE 'unknow' END AS status FROM user</code><br>
在user表中查询用户姓名和状态,当查到状态为1 时候替换显示admin</p>
<h3 id="cast表达式">CAST表达式:</h3>
<p>定义一个新的列(补列): ** 多用于做UNION并时添加新的列 **<br>
CAST(NULL AS Varchar(20))</p>
<h3 id="定义视图view">定义视图view</h3>
<p>student(name,school)<br>
soldiers(name,service)<br>
<code>SQL CREATE VIEW prospects (name,school,service) AS SELECT name,school,CAST(NULL AS Varchar(20)) FROM Students UNION SELECT name,CAST(NULL AS Varchar(20)),service FROM Soldiers</code><br>
prospects(name,school,service)定义的视图及其结构<br>
CAST(NULL AS Varchar(20))由于student表中没有service信息,创建一列为空的信息补到student的school后充当service,使得student表有三列<br>
CAST(NULL AS Varchar(20))同上</p>
<h3 id="子查询">子查询:</h3>
<h4 id="标量子查询查询结果是属性值">标量子查询:查询结果是属性值</h4>
<p>凡是可以出现某个值的地方都可以放一个变量子查询</p>
<h4 id="表表达式查询结果是表">表表达式:查询结果是表</h4>
<h4 id="公共表表达式一个子表达式使用多次时对它定义">公共表表达式:一个子表达式使用多次时对它定义</h4>
<p>公共表就是一个临时视图<br>
<code>SQL WITH payroll(rate,avgage) AS (SELECT rating,avg(age) FROM user GROUP BY rating) SELECT avgage FROM payroll WHERE rate=10</code></p>
<h2 id="dml语句">DML语句:</h2>
<h3 id="insert语句">INSERT语句:</h3>
<p>一条INSERT语句就是向数据库插入一条元组<br>
<code>SQL INSERT INTO user VALUES('wangHua',10,12)</code></p>
<h3 id="delete语句">DELETE语句:</h3>
<p>删除满足条件元组(可能多条)<br>
<code>SQL DELETE FROM user WHERE id=1</code></p>
<h3 id="update语句">UPDATE语句:</h3>
<p><code>SQL UPDATE user SET name='liHua',rating=2 WHERE id=1</code></p>
<h3 id="view">VIEW</h3>
<p>利用视图实现外模式,通过外模式与模式的映射实现逻辑独立性<br>
在数据库中只存储其定义,不存储其对应数据,在需要数据时通过对表的映射得到<br>
使用时可当做表使用,但是虚表,视图中内容并不存,定义被存储在数据库的自动生成的默认表中(只存储定义不存储内容)<br>
<code>SQL CREATE VIEW youngUser AS SELECT id,name,rating,age FROM user WHERE age&lt;18</code><br>
视图的修改:<br>
有的数据库支持有的不支持,当视图中的某一属性能唯一映射到原表中时,可支持,此时修改视图实际修改的是表中信息</p>
<p><code>SQL CREATE VIEW youngUser AS SELECT id,name,rating,age FROM user WHERE age&lt;18</code><br>
垂直方向做了投影,水平方向做了筛选,可修改</p>
<p><code>SQL CREATE VIEW youngUser AS SELECT rating,AVG(age) FROM user GROUP BY rating</code><br>
不支持修改,因为修改视图中某一条属性无法返回到基表中的某个属性值</p>
<p>WITH子句定义的临时表定义也不在数据库中存储</p>
<h2 id="sql嵌入编程语言">SQL嵌入编程语言:</h2>
<h3 id="面临问题">面临问题:</h3>
<ol>
<li>SQL支持的数据类型与编程语言不匹配</li>
<li>SQL语言执行(关系型数据库查询结果)结果是表,编程语言想要的是变量</li>
<li>SQL中有空值NULL,如何对其处理</li>
</ol>
<h3 id="解决方案">解决方案:</h3>
<ol>
<li>嵌入式SQL</li>
<li>API(JDBC):用户直接利用接口调用SQL语句</li>
<li>类封装</li>
</ol>
<h3 id="嵌入式sql的解决思路">嵌入式SQL的解决思路:</h3>
<ol>
<li>以 EXEC SQL开头,以';'结尾的会被c语言识别为SQL语句;</li>
<li>引入 <strong>宿主变量</strong> 在C语言和数据库之间传递信息,其中在C语言中宿主变量与普通变量并无区别,在SQL中使用宿主变量时要在变量前加':',通过在C语言中赋值,在SQL中引用(或者相反)在他们俩之间传递信息</li>
<li>使用indicator(short int)变量来标记是否是空值</li>
</ol>
<h3 id="使用步骤">使用步骤:</h3>
<ol>
<li>连接数据库</li>
<li>在C语言中以EXEC SQL BEGIN DECLARE SECTION开头 EXEC SQL END DECLARE SECTION结尾标记宿主变量的定义</li>
<li>游标机制:游标定义对应的是一句SQL语句,返回这条语句执行的结果,结果类似于文件,有一个读写指针,指针指向一条元组,每读一条元组就向下走到下一条元组</li>
<li>需要预编译,得到纯C代码</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 使用代理]]></title>
        <id>https://wangyingying625.github.io/post/git-shi-yong-dai-li/</id>
        <link href="https://wangyingying625.github.io/post/git-shi-yong-dai-li/">
        </link>
        <updated>2021-03-04T05:19:28.000Z</updated>
        <content type="html"><![CDATA[<p>GRidea 的更新总是失败，需要手动给git增加一个全局代理。</p>
<p>设置代理<br>
git config --global https.proxy http://127.0.0.1:1087</p>
<p>git config --global https.proxy https://127.0.0.1:1087<br>
取消代理<br>
git config --global --unset http.proxy</p>
<p>git config --global --unset https.proxy</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OWASP TOP 10 漏洞笔记]]></title>
        <id>https://wangyingying625.github.io/post/owasp-top-10-lou-dong-bi-ji/</id>
        <link href="https://wangyingying625.github.io/post/owasp-top-10-lou-dong-bi-ji/">
        </link>
        <updated>2021-03-04T05:18:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="注入">注入</h1>
<h2 id="sql-注入">SQL 注入</h2>
<ol>
<li>产生条件:网站执行的sql代码需要结合用户输入<br>
用户输入恶意的sql代码<br>
使用order by 1检测出正常被执行的代码查询结果列数<br>
使用union拼接恶意查询语句(union查询结果列数需要与前面执行的sql语句查询列数相同)</li>
<li>测试方法:<br>
2.1 数字型:SELECT * from user WHERE id= 1 and 1=2;即可以用and永假式看是否异常测试;<br>
2.2 字符型:SELECT * from user WHERE name='name1' and '1'='1'</li>
<li>可能危害:执行SQL代码,获取数据库信息</li>
<li>注意点:union并时要求返回元组有相同的属性数目,需要提前用order by 1/2/3...测试前面语句的返回属性数</li>
</ol>
<p>mysql 可以写文件, 但是要求,绝对路径 --&gt; 写入文件</p>
<h2 id="命令注入">命令注入</h2>
<p>提交的命令注入到原始的命令中</p>
<ol>
<li>基础知识:管道符|能把前面命令的输出当做后面命令的输入<br>
; 分号后的命令能被直接执行<br>
&amp;&amp;符号如果前面命令执行成功就接着执行后面命令<br>
|| 如果前面命令执行失败就执行后面命令<br>
php的exec函数会把参数当做命令执行</li>
<li>可能危害:get shell</li>
</ol>
<h2 id="失效的身份认证">失效的身份认证</h2>
<ol>
<li>
<p>弱口令&amp;口令破解<br>
使用burpsuit抓包:<br>
send to intruder-&gt;options选择爆破点-&gt;payloads-&gt;payload Type -&gt;start attack</p>
</li>
<li>
<p>cookie伪造&amp;cookie绕过<br>
Admin=1</p>
</li>
</ol>
<h2 id="xml-外部实体xxe-xml-external-entity">XML 外部实体(XXE--XML External Entity)</h2>
<h3 id="基础知识">基础知识:</h3>
<ol>
<li>xml可扩展标记语言,用来传输和存储数据,标记电子文件使其具有结构性</li>
<li>xml包括xml声明+DTD(文档类型定义)+文档元素<br>
其中DTD内容可以用户自己声明也可以引用外部链接地址</li>
</ol>
<h3 id="xxe">XXE</h3>
<p>攻击原理:在文档类型定义处引用外部链接时,恶意用户可以引入一个可执行文件</p>
<p>Doc , Excel , 配置文件</p>
<h1 id="失效的访问控制">失效的访问控制</h1>
<h2 id="越权访问逻辑漏洞">越权访问(逻辑漏洞)</h2>
<ol>
<li>
<p>水平越权<br>
userA 修改/查看和他同一级别的用户userB隐秘属性</p>
</li>
<li>
<p>垂直越权<br>
userA 获取到比他高级的用户admin权限</p>
</li>
</ol>
<h1 id="安全配置错误">安全配置错误</h1>
<h2 id="不安全的默认配置">不安全的默认配置</h2>
<p>开启debug模式,如PHP框架(larvael)开启了debuger会显示出所有变量内容(包括数据库密码)<br>
开了php报错,会显示错误信息: 网站绝对路径</p>
<h1 id="跨站脚本xss">跨站脚本(XSS)</h1>
<ol>
<li>产生条件:网站对用户输入提交的信息未进行处理<br>
恶意用户在表单部分输入恶意js代码</li>
<li>测试方法:<br>
在表单部分输入代码<br>
<code>&lt;details open ontoggle=prompt('hello')&gt;</code></li>
<li>可能危害:<br>
获取用户cookie<br>
破坏网页结构</li>
</ol>
<h1 id="不安全的反序列化对象注入">不安全的反序列化(对象注入)</h1>
<p>序列化 : 变量 (对象) --&gt; 字符串<br>
反序列化 :字符串 --&gt; 变量 (对象)</p>
<h2 id="php中的魔术方法">php中的魔术方法:</h2>
<ol>
<li></li>
</ol>
<p>127.0.0.1/a.php<br>
User<br>
user: name :yy id: 3 lasttime: 2021.xxx<br>
序列化成字符串<br>
127.0.0.1/b.php<br>
字符串反序列化成对象</p>
<p>php : __wake()</p>
<h1 id="使用含有已知漏洞的组件">使用含有已知漏洞的组件</h1>
<p>struct2<br>
fastjson<br>
weblogic<br>
shiro</p>
<p>中国: cnvd<br>
国际: cve</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[src漏洞总结]]></title>
        <id>https://wangyingying625.github.io/post/src-lou-dong-zong-jie/</id>
        <link href="https://wangyingying625.github.io/post/src-lou-dong-zong-jie/">
        </link>
        <updated>2021-03-04T05:17:41.000Z</updated>
        <content type="html"><![CDATA[<p>漏洞1:<br>
1.可能危害:获取用户cookie,修改HTML代码<br>
2.复现过程:登录-&gt;留言板留言写入HTML标签及js代码<br>
3.复现结果:留言板处写入的代码被存进数据库,插入到原来的HTML内,破坏原来页面结构;当其他用户查看这个页面时候执行恶意插入的js代码获取用户cookie</p>
<p>反序列化漏洞:<br>
绕过认证:<br>
漏洞1(修改get参数绕过验证):<br>
1.危害:修改用户密码,登录并用该身份查看信息<br>
2.复现过程:登录时选择忘记密码-&gt;试用户名-&gt;选择找回密码-&gt;选择手机验证码验证-&gt;修改get部分参数绕过手机验证-&gt;密码修改成功<br>
3.复现结果:用户密码修改成功</p>
<p>漏洞2(修改参数userId绕过认证):<br>
1.危害:登录用户账号获取用户用户名和密码信息<br>
2.复现过程:登录已知用户-&gt;修改用户ID-&gt;返回用户信息(包括用户密码)</p>
<p>文件上传:<br>
一句话木马:</p>
<?php
eval($_POST['cmd']);
? 绕过 :

<?php 
if ((
    ($_FILES["file"]["type"] == "image/gif")
        || ($_FILES["file"]["type"] == "image/jpeg")
        || ($_FILES["file"]["type"] == "image/jpg")
        || ($_FILES["file"]["type"] == "image/pjpeg")
        || ($_FILES["file"]["type"] == "image/x-png")
        || ($_FILES["file"]["type"] == "image/png"))
path : /var/www/html
uid : server/upload/

/var/www/html/server/upload/ 不可解析 !
uid : server/upload/../a.php = server/a.php
waf:

任意文件下载(包含):
下载任意文件
执行代码
漏洞1:
注入:
漏洞1(SQL注入):
1.危害:无密码登录
2.复现过程:登录时用户名部分填入admin' or '1'='1 密码任意->无密码登录成功]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库基本概念]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-bi-ji/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-bi-ji/">
        </link>
        <updated>2021-03-04T05:13:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据库系统">数据库系统:</h2>
<p>数据库系统包括:数据库(存储数据),数据库管理系统(对数据库进行管理),数据和数据库管理员💑</p>
<h3 id="数据库管理系统提供给用户访问数据库的接口">数据库管理系统提供给用户访问数据库的接口:</h3>
<ol>
<li>SQL语言:使用这种语言访问数据库(不是编程语言,不是功能完备的语言,不能进行复杂的编程)</li>
<li>访问数据库的工具(GUI):提供给用户图形化界面</li>
<li>API:应用程序里访问数据库(JDBC)</li>
<li>把访问数据库接口封装成类(php框架laravel)</li>
</ol>
<h2 id="关系模型">关系模型:</h2>
<p>把实体和实体间的联系都抽象成关系,一个关系对应一张表,对数据库的操作内容和操作结果都是关系.对应的还有层次模型,网状模型等</p>
<h2 id="关系型数据库采用关系模型来组织和构建的数据库">关系型数据库(采用关系模型来组织和构建的数据库):</h2>
<p>常用的关系型数据库:oracle,MySQL,SQL server,DB2<br>
每种数据库支持的具体类型可能不同</p>
<h3 id="关系型数据库查询语言的形式化基础">关系型数据库查询语言的形式化基础:</h3>
<ol>
<li>
<p>关系代数(过程化)</p>
</li>
<li>
<p>关系演算(非过程化,查询时不需要具体描述查询的步骤,只需描述要查询的结果需满足条件)</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用命令]]></title>
        <id>https://wangyingying625.github.io/post/chang-yong-ming-ling/</id>
        <link href="https://wangyingying625.github.io/post/chang-yong-ming-ling/">
        </link>
        <updated>2021-03-04T04:48:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.打开文件夹  open 路径</p>
]]></content>
    </entry>
</feed>