<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-05T11:15:06.336Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[docker使用笔记]]></title>
        <id>https://wangyingying625.github.io/post/docker-shi-yong-bi-ji/</id>
        <link href="https://wangyingying625.github.io/post/docker-shi-yong-bi-ji/">
        </link>
        <updated>2021-03-05T03:12:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用命令">常用命令</h2>
<ol>
<li>查找容器id:docker ps</li>
<li>启动docker-compose:docker-compose up -d</li>
<li>进入容器:</li>
<li>docker images</li>
</ol>
<h2 id="零碎知识">零碎知识</h2>
<ol>
<li>docker不用进文件夹</li>
<li>docker-compose需要进文件夹</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[英语介绍]]></title>
        <id>https://wangyingying625.github.io/post/ying-yu-jie-shao/</id>
        <link href="https://wangyingying625.github.io/post/ying-yu-jie-shao/">
        </link>
        <updated>2021-03-05T02:51:09.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>I should further my studies because what i have learned is not enough</li>
<li>I like the school's academic atmosphere  so much</li>
<li></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL语言]]></title>
        <id>https://wangyingying625.github.io/post/sql-yu-yan/</id>
        <link href="https://wangyingying625.github.io/post/sql-yu-yan/">
        </link>
        <updated>2021-03-04T11:48:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="sql语言一种非过程化的关系演算语言">SQL语言(一种非过程化的关系演算语言):</h1>
<h2 id="常用名词">常用名词</h2>
<ol>
<li>基表:存在于物理磁盘内的一张表</li>
<li>视图:虚表,根据用户的需要映射出的表,并不真正存在于物理磁盘</li>
<li>保留字:<br>
NULL:空值<br>
UNIQUE:说明表的某一属性值是否允许重复<br>
DEFAUIT:为某一属性指定缺省值<br>
PRIMARY KEY:用来指定某一属性为主键<br>
FOREIGN KEY:用来指明某一属性是外键<br>
CHECK:定义表时为某一属性进行检查是否符合某要求</li>
</ol>
<h2 id="sql的四种子语言">SQL的四种子语言:</h2>
<ol>
<li>DDL:(Data Definition Language):用来定义删除维护数据模式(表的创建与删除,视图的创建与删除,修改表的模式),多用图形化工具操作</li>
<li>QL(Query Language):查询语言,对数据库里的数据进行查询,查询出满足条件的数据</li>
<li>DML(Data Manipulation Language):数据操作语言,对数据库里已经存在的数据进行增删改</li>
<li>DCL(Data Control Language):管理数据库的用户权限(授权,创建用户,完整性约束,审计)</li>
</ol>
<h2 id="sql语言的基本模式">SQL语言的基本模式</h2>
<p>SELECT [DISTINCT] 目标列 FROM 表名 WHERE 查询条件 GROUP BY 分组属性 HAVING 分组条件</p>
<h2 id="sql语言的执行策略">SQL语言的执行策略:</h2>
<ol>
<li>根据FROM后的表名做笛卡尔乘积得到表A</li>
<li>用WHERE后面的条件对表A进行筛选得到符合条件的表B</li>
<li>对表B中的信息按照GROUP BY后的分组属性分组,对属性相同的元组分成一组</li>
<li>对分好组的表按照HAVING后的分组条件再次筛选,筛选出符合条件的组</li>
<li>在选好的组中根据SELECT后的信息进行投影,每个组出一条元组<br>
SELECT的属性和HAVING属性必须是分组属性集的子集</li>
</ol>
<p><img src="https://wangyingying625.github.io/post-images/1614835018824.png" alt="" loading="lazy"><br>
表名为table1,其中id自增为主键<br>
<img src="https://wangyingying625.github.io/post-images/1614835029464.png" alt="" loading="lazy"><br>
表名为shop,其中id自增为主键</p>
<p>执行SQL语句:<br>
<code>SQL SELECT T.name FROM table1 T,shop S WHERE T.id=S.id</code><br>
执行结果如下图:<br>
<img src="https://wangyingying625.github.io/post-images/1614835041033.png" alt="" loading="lazy"></p>
<h2 id="ql语言">QL语言</h2>
<h3 id="模糊查询like">模糊查询like:</h3>
<ol>
<li>_(下划线)表示匹配任意字符</li>
<li>%表示匹配任意0 到多个字符<br>
<code>SQL SELECT T.name FROM table1 T WHERE T.name LIKE 'w_%i'</code><br>
执行结果如下图:<br>
<img src="https://wangyingying625.github.io/post-images/1614835904286.png" alt="" loading="lazy"></li>
</ol>
<h3 id="起别名as">起别名AS:</h3>
<p><code>SQL SELECT T.id+1 AS id1 FROM table1 T WHERE T.name LIKE 'w_%i'</code><br>
结果如下<br>
<img src="https://wangyingying625.github.io/post-images/1614836268735.png" alt="" loading="lazy"></p>
<h3 id="连接union">连接UNION:</h3>
<p>union是关系代数中的并(∪)操作扩展而来的,所以要满足并操作的条件<br>
并操作:把两个关系模式相同的元组组合<br>
即要求UNION前后两句sql查询到的表列数相同<br>
<code>SQL SELECT name FROM table1 WHERE id=1 UNION SELECT number FROM shop WHERE name='food'</code><br>
结果如下<br>
<img src="https://wangyingying625.github.io/post-images/1614836988247.png" alt="" loading="lazy"></p>
<h3 id="自连接">自连接:</h3>
<p>新建一张购买表buy,信息如下:<br>
<img src="https://wangyingying625.github.io/post-images/1614838025350.png" alt="" loading="lazy"><br>
若要查询既买了food又买了cloth的用户名<br>
<code>SQL SELECT T.name FROM table1 T,buy B1,buy B2 WHERE B1.uid=B2.uid AND (B1.sid=1 AND B2.sid=2) AND T.id=B1.uid</code><br>
<img src="https://wangyingying625.github.io/post-images/1614838719827.png" alt="" loading="lazy"></p>
<h3 id="交intersect部分数据库支持">交INTERSECT(部分数据库支持):</h3>
<p>实现查询既买了food又买了cloth的用户名<br>
<code>SQL SELECT T.name FROM table1 T,buy B WHERE B.uid=T.id AND B.sid=1 INTERSECT SELECT T.name FROM table1 T,buy B WHERE B.uid=T.id AND B.sid=2</code></p>
<h3 id="嵌套查询">嵌套查询:</h3>
<ol>
<li>非关联嵌套(子查询的条件与父查询无关):<br>
查询买了food的用户名<br>
<code>SQL SELECT T.name FROM table1 T WHERE T.id IN(SELECT B.uid FROM buy B WHERE B.sid=1)</code><br>
对每个用户扫描,查看其id是否在买过food的表的id里面,若在返回id对应的姓名</li>
<li>关联嵌套查询(嵌套的子查询条件与父查询相关):<br>
例1. 查询买过food用户的名称:<br>
<code>SQL SELECT T.name FROM table1 T WHERE EXISTS (SELECT * FROM buy B WHERE B.uid=T.id AND B.sid=1)</code><br>
如果某用户买过food,那么在buy表中必然存在一条记录,其uid等于该用户id且sid等于1<br>
对table1中的每个用户遍历,查看是否在buy表中存在符合上述条件的元组<br>
相当于二重循环,对外层循环中的每条元组都做一次内层循环</li>
</ol>
<p>例2. 查只有一个人买的商品<br>
<code>SQL SELECT B.sid FROM buy B WHERE B.sid NOT IN (SELECT B1.sid FROM buy B1 WHERE B.uid!=B1.uid)</code><br>
查出表中除用户1 外其他用户买的商品,如果用户1买的商品不在其他用户买的商品列表里,则用户1买的商品就是只有一人买的<br>
对buy表扫描,查看当前这条购买的这个人,除他以外其他人都买了什么,如果他买的东西不在其他人买的东西的列表那就满足条件<br>
构造步骤:<br>
查询只有除我外其他人购买了的商品:SELECT 商品 FROM 购物表 WHERE 购买者!=我<br>
查出我只有我买的商品:SELECT 商品 FROM 购物表1 WHERE 商品 NOT IN (SELECT 商品 FROM 购物表 2 WHERE 购买者!=我)<br>
遍历到所有人:SELECT 商品 FROM 购物表1 WHERE 商品 NOT IN (SELECT 商品 FROM 购物表 2 WHERE 购买者!=购物表1中对应购买者)</p>
<h3 id="聚集函数">聚集函数</h3>
<ol>
<li>COUNT(*)某表的元组数</li>
<li>COUNT([DISTINCT] A)某表中属性值A的不同值个数,属性A的值不一样时候加一</li>
<li>SUM([DISTINCT] A)对属性A进行累计求和</li>
<li>AVG([DISTINCT] A)属性A的平均值</li>
<li>MAX(A)</li>
<li>MIN(A)</li>
</ol>
<h3 id="分组group-by">分组GROUP BY</h3>
<ol>
<li>模式:GROUP BY( )</li>
<li>功能:对表中信息按照条件分组,条件相同即为一组</li>
<li>要求对分组得到的每个组它的属性在SELECT上必须是单一的(因为每个组最终只出一条信息,若不单一就无法继续)简单来说就是要求SELECT和HAVING后的属性都必须是GROUP BY后的属性的子集</li>
</ol>
<h3 id="having">HAVING</h3>
<p>SELECT的属性和HAVING属性必须是分组属性集的子集</p>
<ol>
<li>模式:HAVING</li>
<li>功能:对分好组后的信息按照条件筛选<br>
例1:<br>
定义user表如下<br>
<img src="https://wangyingying625.github.io/post-images/1614859980796.png" alt="" loading="lazy"><br>
查询年龄大于25的用户里每个级别最年轻用户的年龄并且每个级别里用户数要大于1<br>
<code>SQL SELECT U.rating,MIN(U.age) AS minAge FROM user U WHERE U.age &gt;25 GROUP BY U.rating HAVING COUNT(*)&gt;1</code><br>
结果如下:<br>
<img src="https://wangyingying625.github.io/post-images/1614860466747.png" alt="" loading="lazy"><br>
执行过程<br>
对表中信息按照rating属性排序,得到:<br>
rating   age<br>
3         33<br>
5          34<br>
7           45<br>
7           36<br>
8           45<br>
10          33<br>
分出5组<br>
再根据HAVING的条件进行筛选组,得到<br>
7           45<br>
7           36<br>
对SELECT后的条件进行映射<br>
得到<br>
7           36<br>
查询平均年龄最小的等级<br>
<code>SQL SELECT Temp.rating FROM ( SELECT S.rating ,AVG(S.age) AS avgage FROM user S GROUP BY S.rating ) AS Temp WHERE temp.avgage=(SELECT MIN (Temp.avgage))</code><br>
生成了临时表Temp</li>
</ol>
<h3 id="case表达式">CASE表达式</h3>
<p><code>SQL SELECT name,CASE status WHEN 1 THEN 'admin' WHEN 2 THEN 'user' ELSE 'unknow' END AS status FROM user</code><br>
在user表中查询用户姓名和状态,当查到状态为1 时候替换显示admin</p>
<h3 id="cast表达式">CAST表达式:</h3>
<p>定义一个新的列(补列): ** 多用于做UNION并时添加新的列 **<br>
CAST(NULL AS Varchar(20))</p>
<h3 id="定义视图view">定义视图view</h3>
<p>student(name,school)<br>
soldiers(name,service)<br>
<code>SQL CREATE VIEW prospects (name,school,service) AS SELECT name,school,CAST(NULL AS Varchar(20)) FROM Students UNION SELECT name,CAST(NULL AS Varchar(20)),service FROM Soldiers</code><br>
prospects(name,school,service)定义的视图及其结构<br>
CAST(NULL AS Varchar(20))由于student表中没有service信息,创建一列为空的信息补到student的school后充当service,使得student表有三列<br>
CAST(NULL AS Varchar(20))同上</p>
<h3 id="子查询">子查询:</h3>
<h4 id="标量子查询查询结果是属性值">标量子查询:查询结果是属性值</h4>
<p>凡是可以出现某个值的地方都可以放一个变量子查询</p>
<h4 id="表表达式查询结果是表">表表达式:查询结果是表</h4>
<h4 id="公共表表达式一个子表达式使用多次时对它定义">公共表表达式:一个子表达式使用多次时对它定义</h4>
<p>公共表就是一个临时视图<br>
<code>SQL WITH payroll(rate,avgage) AS (SELECT rating,avg(age) FROM user GROUP BY rating) SELECT avgage FROM payroll WHERE rate=10</code></p>
<h2 id="dml语句">DML语句:</h2>
<h3 id="insert语句">INSERT语句:</h3>
<p>一条INSERT语句就是向数据库插入一条元组<br>
<code>SQL INSERT INTO user VALUES('wangHua',10,12)</code></p>
<h3 id="delete语句">DELETE语句:</h3>
<p>删除满足条件元组(可能多条)<br>
<code>SQL DELETE FROM user WHERE id=1</code></p>
<h3 id="update语句">UPDATE语句:</h3>
<p><code>SQL UPDATE user SET name='liHua',rating=2 WHERE id=1</code></p>
<h3 id="view">VIEW</h3>
<p>利用视图实现外模式,通过外模式与模式的映射实现逻辑独立性<br>
在数据库中只存储其定义,不存储其对应数据,在需要数据时通过对表的映射得到<br>
使用时可当做表使用,但是虚表,视图中内容并不存,定义被存储在数据库的自动生成的默认表中(只存储定义不存储内容)<br>
<code>SQL CREATE VIEW youngUser AS SELECT id,name,rating,age FROM user WHERE age&lt;18</code><br>
视图的修改:<br>
有的数据库支持有的不支持,当视图中的某一属性能唯一映射到原表中时,可支持,此时修改视图实际修改的是表中信息</p>
<p><code>SQL CREATE VIEW youngUser AS SELECT id,name,rating,age FROM user WHERE age&lt;18</code><br>
垂直方向做了投影,水平方向做了筛选,可修改</p>
<p><code>SQL CREATE VIEW youngUser AS SELECT rating,AVG(age) FROM user GROUP BY rating</code><br>
不支持修改,因为修改视图中某一条属性无法返回到基表中的某个属性值</p>
<p>WITH子句定义的临时表定义也不在数据库中存储</p>
<h2 id="sql嵌入编程语言">SQL嵌入编程语言:</h2>
<h3 id="面临问题">面临问题:</h3>
<ol>
<li>SQL支持的数据类型与编程语言不匹配</li>
<li>SQL语言执行(关系型数据库查询结果)结果是表,编程语言想要的是变量</li>
<li>SQL中有空值NULL,如何对其处理</li>
</ol>
<h3 id="解决方案">解决方案:</h3>
<ol>
<li>嵌入式SQL</li>
<li>API(JDBC):用户直接利用接口调用SQL语句</li>
<li>类封装</li>
</ol>
<h3 id="嵌入式sql的解决思路">嵌入式SQL的解决思路:</h3>
<ol>
<li>以 EXEC SQL开头,以';'结尾的会被c语言识别为SQL语句;</li>
<li>引入 <strong>宿主变量</strong> 在C语言和数据库之间传递信息,其中在C语言中宿主变量与普通变量并无区别,在SQL中使用宿主变量时要在变量前加':',通过在C语言中赋值,在SQL中引用(或者相反)在他们俩之间传递信息</li>
<li>使用indicator(short int)变量来标记是否是空值</li>
</ol>
<h3 id="使用步骤">使用步骤:</h3>
<ol>
<li>连接数据库</li>
<li>在C语言中以EXEC SQL BEGIN DECLARE SECTION开头 EXEC SQL END DECLARE SECTION结尾标记宿主变量的定义</li>
<li>游标机制:游标定义对应的是一句SQL语句,返回这条语句执行的结果,结果类似于文件,有一个读写指针,指针指向一条元组,每读一条元组就向下走到下一条元组</li>
<li>需要预编译,得到纯C代码</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 使用代理]]></title>
        <id>https://wangyingying625.github.io/post/git-shi-yong-dai-li/</id>
        <link href="https://wangyingying625.github.io/post/git-shi-yong-dai-li/">
        </link>
        <updated>2021-03-04T05:19:28.000Z</updated>
        <content type="html"><![CDATA[<p>GRidea 的更新总是失败，需要手动给git增加一个全局代理。</p>
<p>设置代理<br>
git config --global https.proxy http://127.0.0.1:1087</p>
<p>git config --global https.proxy https://127.0.0.1:1087<br>
取消代理<br>
git config --global --unset http.proxy</p>
<p>git config --global --unset https.proxy</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OWASP TOP 10 漏洞笔记]]></title>
        <id>https://wangyingying625.github.io/post/owasp-top-10-lou-dong-bi-ji/</id>
        <link href="https://wangyingying625.github.io/post/owasp-top-10-lou-dong-bi-ji/">
        </link>
        <updated>2021-03-04T05:18:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="注入">注入</h1>
<h2 id="sql-注入">SQL 注入</h2>
<ol>
<li>产生条件:网站执行的sql代码需要结合用户输入<br>
用户输入恶意的sql代码<br>
使用order by 1检测出正常被执行的代码查询结果列数<br>
使用union拼接恶意查询语句(union查询结果列数需要与前面执行的sql语句查询列数相同)</li>
<li>测试方法:<br>
2.1 数字型:SELECT * from user WHERE id= 1 and 1=2;即可以用and永假式看是否异常测试;<br>
2.2 字符型:SELECT * from user WHERE name='name1' and '1'='1'</li>
<li>可能危害:执行SQL代码,获取数据库信息</li>
<li>注意点:union并时要求返回元组有相同的属性数目,需要提前用order by 1/2/3...测试前面语句的返回属性数</li>
</ol>
<p>mysql 可以写文件, 但是要求,绝对路径 --&gt; 写入文件</p>
<h2 id="命令注入">命令注入</h2>
<p>提交的命令注入到原始的命令中</p>
<ol>
<li>基础知识:管道符|能把前面命令的输出当做后面命令的输入<br>
; 分号后的命令能被直接执行<br>
&amp;&amp;符号如果前面命令执行成功就接着执行后面命令<br>
|| 如果前面命令执行失败就执行后面命令<br>
php的exec函数会把参数当做命令执行</li>
<li>可能危害:get shell</li>
</ol>
<h2 id="失效的身份认证">失效的身份认证</h2>
<ol>
<li>
<p>弱口令&amp;口令破解<br>
使用burpsuit抓包:<br>
send to intruder-&gt;options选择爆破点-&gt;payloads-&gt;payload Type -&gt;start attack</p>
</li>
<li>
<p>cookie伪造&amp;cookie绕过<br>
Admin=1</p>
</li>
</ol>
<h2 id="xml-外部实体xxe-xml-external-entity">XML 外部实体(XXE--XML External Entity)</h2>
<h3 id="基础知识">基础知识:</h3>
<ol>
<li>xml可扩展标记语言,用来传输和存储数据,标记电子文件使其具有结构性</li>
<li>xml包括xml声明+DTD(文档类型定义)+文档元素<br>
其中DTD内容可以用户自己声明也可以引用外部链接地址</li>
</ol>
<h3 id="xxe">XXE</h3>
<p>攻击原理:在文档类型定义处引用外部链接时,恶意用户可以引入一个可执行文件</p>
<p>Doc , Excel , 配置文件</p>
<h1 id="失效的访问控制">失效的访问控制</h1>
<h2 id="越权访问逻辑漏洞">越权访问(逻辑漏洞)</h2>
<ol>
<li>
<p>水平越权<br>
userA 修改/查看和他同一级别的用户userB隐秘属性</p>
</li>
<li>
<p>垂直越权<br>
userA 获取到比他高级的用户admin权限</p>
</li>
</ol>
<h1 id="安全配置错误">安全配置错误</h1>
<h2 id="不安全的默认配置">不安全的默认配置</h2>
<p>开启debug模式,如PHP框架(larvael)开启了debuger会显示出所有变量内容(包括数据库密码)<br>
开了php报错,会显示错误信息: 网站绝对路径</p>
<h1 id="跨站脚本xss">跨站脚本(XSS)</h1>
<ol>
<li>产生条件:网站对用户输入提交的信息未进行处理<br>
恶意用户在表单部分输入恶意js代码</li>
<li>测试方法:<br>
在表单部分输入代码<br>
<code>&lt;details open ontoggle=prompt('hello')&gt;</code></li>
<li>可能危害:<br>
获取用户cookie<br>
破坏网页结构</li>
</ol>
<h1 id="不安全的反序列化对象注入">不安全的反序列化(对象注入)</h1>
<p>序列化 : 变量 (对象) --&gt; 字符串<br>
反序列化 :字符串 --&gt; 变量 (对象)</p>
<h2 id="php中的魔术方法">php中的魔术方法:</h2>
<ol>
<li></li>
</ol>
<p>127.0.0.1/a.php<br>
User<br>
user: name :yy id: 3 lasttime: 2021.xxx<br>
序列化成字符串<br>
127.0.0.1/b.php<br>
字符串反序列化成对象</p>
<p>php : __wake()</p>
<h1 id="使用含有已知漏洞的组件">使用含有已知漏洞的组件</h1>
<p>struct2<br>
fastjson<br>
weblogic<br>
shiro</p>
<p>中国: cnvd<br>
国际: cve</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[src漏洞总结]]></title>
        <id>https://wangyingying625.github.io/post/src-lou-dong-zong-jie/</id>
        <link href="https://wangyingying625.github.io/post/src-lou-dong-zong-jie/">
        </link>
        <updated>2021-03-04T05:17:41.000Z</updated>
        <content type="html"><![CDATA[<p>漏洞1:<br>
1.可能危害:获取用户cookie,修改HTML代码<br>
2.复现过程:登录-&gt;留言板留言写入HTML标签及js代码<br>
3.复现结果:留言板处写入的代码被存进数据库,插入到原来的HTML内,破坏原来页面结构;当其他用户查看这个页面时候执行恶意插入的js代码获取用户cookie</p>
<p>反序列化漏洞:<br>
绕过认证:<br>
漏洞1(修改get参数绕过验证):<br>
1.危害:修改用户密码,登录并用该身份查看信息<br>
2.复现过程:登录时选择忘记密码-&gt;试用户名-&gt;选择找回密码-&gt;选择手机验证码验证-&gt;修改get部分参数绕过手机验证-&gt;密码修改成功<br>
3.复现结果:用户密码修改成功</p>
<p>漏洞2(修改参数userId绕过认证):<br>
1.危害:登录用户账号获取用户用户名和密码信息<br>
2.复现过程:登录已知用户-&gt;修改用户ID-&gt;返回用户信息(包括用户密码)</p>
<p>文件上传:<br>
一句话木马:</p>
<?php
eval($_POST['cmd']);
? 绕过 :

<?php 
if ((
    ($_FILES["file"]["type"] == "image/gif")
        || ($_FILES["file"]["type"] == "image/jpeg")
        || ($_FILES["file"]["type"] == "image/jpg")
        || ($_FILES["file"]["type"] == "image/pjpeg")
        || ($_FILES["file"]["type"] == "image/x-png")
        || ($_FILES["file"]["type"] == "image/png"))
path : /var/www/html
uid : server/upload/

/var/www/html/server/upload/ 不可解析 !
uid : server/upload/../a.php = server/a.php
waf:

任意文件下载(包含):
下载任意文件
执行代码
漏洞1:
注入:
漏洞1(SQL注入):
1.危害:无密码登录
2.复现过程:登录时用户名部分填入admin' or '1'='1 密码任意->无密码登录成功]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库基本概念]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-bi-ji/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-bi-ji/">
        </link>
        <updated>2021-03-04T05:13:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据库系统">数据库系统:</h2>
<p>数据库系统包括:数据库(存储数据),数据库管理系统(对数据库进行管理),数据和数据库管理员💑</p>
<h3 id="数据库管理系统提供给用户访问数据库的接口">数据库管理系统提供给用户访问数据库的接口:</h3>
<ol>
<li>SQL语言:使用这种语言访问数据库(不是编程语言,不是功能完备的语言,不能进行复杂的编程)</li>
<li>访问数据库的工具(GUI):提供给用户图形化界面</li>
<li>API:应用程序里访问数据库(JDBC)</li>
<li>把访问数据库接口封装成类(php框架laravel)</li>
</ol>
<h2 id="关系模型">关系模型:</h2>
<p>把实体和实体间的联系都抽象成关系,一个关系对应一张表,对数据库的操作内容和操作结果都是关系.对应的还有层次模型,网状模型等</p>
<h2 id="关系型数据库采用关系模型来组织和构建的数据库">关系型数据库(采用关系模型来组织和构建的数据库):</h2>
<p>常用的关系型数据库:oracle,MySQL,SQL server,DB2<br>
每种数据库支持的具体类型可能不同</p>
<h3 id="关系型数据库查询语言的形式化基础">关系型数据库查询语言的形式化基础:</h3>
<ol>
<li>
<p>关系代数(过程化)</p>
</li>
<li>
<p>关系演算(非过程化,查询时不需要具体描述查询的步骤,只需描述要查询的结果需满足条件)</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用命令]]></title>
        <id>https://wangyingying625.github.io/post/chang-yong-ming-ling/</id>
        <link href="https://wangyingying625.github.io/post/chang-yong-ming-ling/">
        </link>
        <updated>2021-03-04T04:48:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.打开文件夹  open 路径</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://wangyingying625.github.io/post/hello-gridea/</id>
        <link href="https://wangyingying625.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>