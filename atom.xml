<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-21T03:42:28.515Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[关系模式的分解]]></title>
        <id>https://wangyingying625.github.io/post/guan-xi-mo-shi-de-fen-jie/</id>
        <link href="https://wangyingying625.github.io/post/guan-xi-mo-shi-de-fen-jie/">
        </link>
        <updated>2021-03-19T13:10:16.000Z</updated>
        <content type="html"><![CDATA[<p>关系模式分解就是把一个关系模式分解成好多个关系模式<br>
判断分解后的关系模式们是否与分解前等价的方法是 判断是否无损连接和函数依赖</p>
<p>看了视频但是对属性集的闭包部分的理解还是有些不顺畅</p>
<hr>
<p>我决定用最通俗易懂的方式解释一些基本概念<br>
逻辑蕴涵:给定一个函数依赖集F(就是学号-&gt;姓名),如果能通过F证明其他函数依赖也成立(如学号-&gt;学院),那就认为其他函数依赖被F蕴涵</p>
<p>函数依赖集的闭包:现有一关系模式 R为student(Sno,Sname,Sage,Sdep),F为属性集上的函数依赖即<br>
(Sno-&gt;Sname,Sno-&gt;Sdep,Sname-&gt;Sage)<br>
那么F的闭包指的就是在R的属性集中所有可以由依赖集合F推导出的依赖集合,记作F+</p>
<p>属性集的闭包:对依赖集F，F+中所有X→A的A的集合称为X的闭包，记为XF+。可以理解为XF+表示所有X可以决定的属性。</p>
<p>最小函数依赖集(最小覆盖,极小函数依赖集):</p>
<ol>
<li>F中任意一个函数依赖右面仅有一个属性</li>
<li>F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</li>
<li>F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}U{Z→A}与F等价。</li>
</ol>
<p>Armstrong公理:(用来推导函数依赖的)</p>
<ol>
<li>自反律:B包含于A时,A-&gt;B</li>
<li>增广律:A-&gt;B那么AC-&gt;BC</li>
<li>传递律:A-&gt;B,B-&gt;C那么A-&gt;C</li>
</ol>
<hr>
<p>关系模式的分解方法:<br>
函数依赖投影求法:<br>
首先需要明白这个操作是在做什么,为了什么;</p>
<p>决定一个属性集是不是键的时候需要考虑第一它是否能决定属性集里所有元素,第二它是否具有最小性(即他的任何子集都不能决定属性集里的所有元素)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库中的函数依赖]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-zhong-de-han-shu-yi-lai/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-zhong-de-han-shu-yi-lai/">
        </link>
        <updated>2021-03-19T04:18:20.000Z</updated>
        <content type="html"><![CDATA[<p>数据库已经看完一遍了,但是发现函数依赖这块还是盲点,于是决定专门为它写一篇<br>
首先函数依赖出现在数据库设计中的原因是什么呢?<br>
很多时候我们设计的数据库往往会有很多问题,比如同一数据可能在两张表中出现,导致数据的不一致,<br>
还有当一张表中数据项过多时也会引起插入异常和删除异常.<br>
那么怎么来判断我的关系模式(数据库表)设计的是不是好呢<br>
这就涉及到函数依赖:</p>
<h2 id="函数依赖">函数依赖</h2>
<p>x中值相等时候Y中值也相等<br>
R是一个关系模式,且里面有属性α和β,如果对于R上任意的两条元组t1和t2都有当α上的值相同时β上的值也相同,那么就说β函数依赖于α.</p>
<h3 id="平凡的函数依赖">平凡的函数依赖</h3>
<p>β⊆α则α-&gt;β</p>
<h3 id="完全函数依赖">完全函数依赖</h3>
<p>如果x能决定Y,那么任意一个x的真子集都不能决定外,就说Y完全函数依赖于x</p>
<h3 id="部分函数依赖">部分函数依赖</h3>
<p>x能决定Y,但是其实x的某个真子集就能决定外,就说Y部分函数依赖于x</p>
<h3 id="传递函数依赖">传递函数依赖</h3>
<p>x能决定y,y能决定z,就说z对x有传递函数依赖</p>
<h3 id="确定集合的闭包">确定集合的闭包:</h3>
<p><img src="https://wangyingying625.github.io/post-images/1616133575272.png" alt="" loading="lazy"><br>
(BC)+=BCA   在关系中找由BC能确定谁,就加进去闭包里面,在用闭包里面的元素去集合中找还能不能确定其他元素,直到无其他元素能被新闭包中的元素确定</p>
<h3 id="找关系的候选码">找关系的候选码</h3>
<p><img src="https://wangyingying625.github.io/post-images/1616133692636.png" alt="" loading="lazy"><br>
(BC)+=BCA<br>
(AB)+=AB<br>
(AC)+=ABC<br>
即关系的候选码是BC和AC</p>
<h2 id="范式用来区分关系模式的优劣">范式(用来区分关系模式的优劣)</h2>
<h3 id="1nf">1NF</h3>
<p>表中所有的属性域都是原子的</p>
<h3 id="2nf">2NF</h3>
<p>消除了1NF中非主属性对主属性的部分函数依赖</p>
<h3 id="3nf">3NF</h3>
<p>消除了2NF中非主属性对码的传递函数依赖</p>
<h3 id="bcnf">BCNF</h3>
<p>消除了3NF中主属性对码的部分和传递函数依赖</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux的进程和相关的几个重要函数]]></title>
        <id>https://wangyingying625.github.io/post/linux-de-jin-cheng-he-xiang-guan-de-ji-ge-chong-yao-han-shu/</id>
        <link href="https://wangyingying625.github.io/post/linux-de-jin-cheng-he-xiang-guan-de-ji-ge-chong-yao-han-shu/">
        </link>
        <updated>2021-03-19T03:43:01.000Z</updated>
        <content type="html"><![CDATA[<p>在Linux系统中每个进程都有一个唯一的编号叫pid,除了init的根进程外任何一个进程都必须由父进程产生.<br>
一个系统中的所有父子进程连起来是一个树的关系,init的进程是根,其他进程是它的子孙<br>
由父进程产生子进程的方法有:</p>
<h2 id="fork">fork()</h2>
<p>这个方法会把父进程的所有数据复制一份给子进程,产生的子进程是和调用fork()方法时候的父进程一样的,父进程的fpid指向子进程的进程id,子进程因为它自己没有子进程所以fpid值为1,可以通过判断当前进程的fpid来让两个进程选择性的执行一些代码.<br>
接着可以通过返回值的不同来判断执行当前代码的是父进程还是子进程</p>
<p>在父进程中，fork返回新创建子进程的进程ID；<br>
在子进程中,fork返回值是0</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[看见你就会看见阳光]]></title>
        <id>https://wangyingying625.github.io/post/kan-jian-ni-jiu-hui-kan-jian-yang-guang/</id>
        <link href="https://wangyingying625.github.io/post/kan-jian-ni-jiu-hui-kan-jian-yang-guang/">
        </link>
        <updated>2021-03-19T03:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>我今天必须吐槽,gridea太不好用了,等我熬过这段忙碌又艰难的生活我一定第一件事就是换掉这个博客,再留你小子几天.<br>
好的正文开始!<br>
没错,是一个很温暖很阳光的标题,但是我最近的生活里充满了各种不顺利和无奈,我不知道是不是每个人都会有这样的一段时间,是不是我努力的熬过来我就会变得强,我其实不知道答案,但是我不断的告诉自己,是的!是的!是的!所以每次失望的放下电脑躺在床上放声大哭,然后再做起来再拿起电脑再去尝试.</p>
<p>今天是他生日,但是很戏剧性的是今天他被安排出差了.就一天,今天走明天就可能回来,本来应该觉得没关系的就一天而已嘛,但是就是觉得不舒服,哪哪都不舒服,甚至这种感觉从昨天前天就开始了.</p>
<p>这段时间我们的生活里充满了无奈和不顺利,他说这是因为我们对困难处境的记忆比对幸福的记忆深刻.我说因为我们能互相感受到彼此的情绪,所以一个人的困难被过成了两份.很多时候我也意识到如果没有他的陪伴,我也不能变成今天这样,虽然还是有很多缺点,还是很胆小但是确实多了些坚韧,这应该是几年前那个我想不到我会有的吧.</p>
<p>今天早晨我妈给我发微信我才意识到确实很久没有和她联系了,但是我过得不好的时候我真的不想和他们分享,不想他们那么无力的担心我,于是轻飘飘的回复了一个我自己都不知道到底有什么含义的表情,轻飘飘的假装这就是我的生活.是的,我宁愿在这里打出这一段段根本不会有人看的文字也不想告诉他们我在经历生活中必不可缺的属于困难的那一部分.</p>
<p>好在今天这里就只有我一个人,所以我还是可以擦干眼泪轻飘飘的假装这些事情对我都没有任何影响.<br>
然后接着打开视频,去一遍一遍的录制,去检查,去克服不自信.如果这是我要成长要进步就必经的道路的话,那我能撑过来,那没什么.我依然会坐在桌前去打开视频去模拟去录制.依然会在哭过一场之后告诉自己不过如此,这都没什么.<br>
<img src="https://wangyingying625.github.io/post-images/1616124377975.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[同态与同构]]></title>
        <id>https://wangyingying625.github.io/post/tong-tai-yu-tong-gou/</id>
        <link href="https://wangyingying625.github.io/post/tong-tai-yu-tong-gou/">
        </link>
        <updated>2021-03-14T13:54:04.000Z</updated>
        <content type="html"><![CDATA[<p>当研究一个新的代数系统时候,我们就想找到一个已经了解的代数系统,看看它们之间是否有相似的性质.<br>
那么两个代数系统之间的关系就被概括成同构和同态</p>
<h2 id="同态">同态</h2>
<p>V1=&lt;A,o,o1,o2...&gt;,V2=&lt;B,*,*1,*2...&gt;是同类型的代数系统,假设oi是r元的,*i也是r元的,若满足:<br>
f(oi(a1,a2,a3...))=*i(f(a1),f(a2),f(a3)...),其中a1,a2,a3都是A中的元素<br>
即先运算再映射的值与先映射再运算的值相等</p>
<h2 id="同构">同构</h2>
<p>同态按照映射类型可分为:<br>
单同态<br>
满同态<br>
同构</p>
<p>群 G和群H之间若建立了同构映射，那么不仅群 G 中的每个元素在群 H中都有一一对应，而且对于群 G中的两个元素a,b  ，在群运算 o下得到的元素aob 也在这个映射下保持一一对应<br>
同构的两个代数系统本质没有任何差别,只是用了不同的解读方式</p>
<p>但是两个代数系统同构要求比较高,于是我们尝试找弱一点的同态代数系统,同态与同构的不同在于映射的函数f不是双射的,可能是单射可能是满射.<br>
如果是单射,那么新的代数系统中只有一部分与已知代数系统同构<br>
如果是满射,那么新的代数系统只与已知代数系统的一部分同构</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[格和布尔代数]]></title>
        <id>https://wangyingying625.github.io/post/ge-he-bu-er-dai-shu/</id>
        <link href="https://wangyingying625.github.io/post/ge-he-bu-er-dai-shu/">
        </link>
        <updated>2021-03-14T10:58:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="格">格</h2>
<p>为了说明格的概念和性质需要有偏序关系的准备知识</p>
<ol>
<li>什么是关系呢?<br>
关系(2元关系):元素全是有序对的集合<br>
如:R1={&lt;1,2&gt;,&lt;2,3&gt;}就是一个二元关系;<br>
R2={&lt;1,2&gt;,3,4}不是二元关系,其中3,4不是有序对<br>
(我会理解为关系是一种把一个元素变为另一个元素的方法,就像R1就是把1变成2,2变成3 的方法)</li>
</ol>
<p>总结一下就是首先关系是一个集合,集合中放的是有序对,即&lt;a,b&gt;与&lt;b,a&gt;代表的含义不同</p>
<ol start="2">
<li>那么,什么又叫偏序关系呢?<br>
这就得先说一说关系的一些性质了.关系是有序对的集合,它可能有一些什么性质来让我们更愿意使用它呢?<br>
自反:设R是A上的一个二元关系,说R是自反的当且仅当任取x在集合A里那么&lt;x,x&gt;就是关系R的一个元素.集合中的每个元素自己都和自己有关系(全部x都得满足)<br>
也就是说通过关系R能让元素集合A里面的所有元素都能保持自己</li>
</ol>
<p>反自反:任何x,自己和自己都没有关系(所有X都不能和自己有关系R)</p>
<p>对称:任选x和y,如果&lt;x,y&gt;有关系R那么&lt;y,x&gt;也有关系R(相等关系)<br>
也就是说一旦通过关系R,x能变成y,那么关系R也一定有办法把y变成x</p>
<p>反对称:任何两个点之间只有一条有向边</p>
<p>传递:当X和Y有关系,并且Y和Z有关系时,X和Z有关系(R和R的合成是R的子集)<br>
也就是说通过关系R如果x能变成y ,y 又能变成z的话.R就一定能把x直接变成z</p>
<p>那么这些乏味的概念和偏序关系究竟有什么关系呢?</p>
<p>In fact,偏序关系就是一种关系呀,就可以当做是把一个元素变成另一个元素的一种办法,但是它的变换是有要求的,它要求这个关系满足 自反性,反对称性和传递性,一般记作≼,被举的最多的例子就整数集上的大于和小于关系.<br>
为了让偏序关系被表示的更加明显和更方便使用,用哈斯图来表示它,比如集合{1,2,4}上的偏序关系就可以用下面的哈斯图来表示<br>
<img src="https://wangyingying625.github.io/post-images/1615721390271.png" alt="" loading="lazy"></p>
<p>偏序的概念可以联系到权限:假设ABC三人权限由高到低分别为超级管理员,管理员和普通用户,首先自反性保证了自己的信息自己能看到,反对称性表示B能看到C的信息,但是C看不到B的.传递性表明A能看到B的,B又能看到C的那么A一定能看到C的啊</p>
<p>有了这些就可以看格了!</p>
<p>首先是概念:<br>
格有两种等价概念:</p>
<ol>
<li>假设&lt;L,≼&gt;是一个偏序集,对于集合L中的任何两个元素都有最大下界和最小上界,那么&lt;L,≼&gt;就是格<br>
还用上面的ABC来举例,也就是说A和B总能找到一个人(A),那个人是能看到AB信息的人里权限最小的,也存在一个人那个人是能被A和B都看的人里权限最大的(C)</li>
</ol>
<p>那么是不是所有的偏序集都有这样的性质呢,并不是!<br>
<img src="https://wangyingying625.github.io/post-images/1615723952406.jpg" alt="" loading="lazy"><br>
这个显然不是格,因为部门A管理员和部门B管理员没有最小上界<br>
<img src="https://wangyingying625.github.io/post-images/1615723964097.jpg" alt="" loading="lazy"><br>
那么这个呢?这个也不是,因为A管理员和B管理员没有最大下界即A,B小组长无法区分大小</p>
<ol start="2">
<li>
<p>设&lt;L,∧,∨&gt;是具有两个二元运算的代数系统,如果∧对∨满足交换结合和吸收律,则称&lt;L,∧,∨&gt;是格</p>
<p>这是什么意思呢?<br>
如果偏序关系中有a≤b,那么就意味着a∨b=b<br>
也意味着a∧b=a<br>
这就说明偏序关系是可以用∨∧这两个运算来等价表示的</p>
<p>那么既然偏序关系要求具备自反,反对称,传递等关系的性质,当然也要要求这两个二元运算满足一些二元运算的要求.即交换,结合,和吸收律<br>
交换:x∧y=y∧x<br>
结合:(x∧y)∧z=x∧(y∧z)<br>
吸收:x∧(y∨x)=x</p>
</li>
</ol>
<p>那么有这些要求的格有什么性质呢:<br>
对偶命题:<br>
若果把格中的≤换成≥,同时把∨和∧互换,格中成立的一切命题换后也成立</p>
<p>和群类似,格中也有一些元素,它们自己就能满足格的概念.于是这些元素构成的集合和偏序关系就构成了子格</p>
<p>此外还有一些格具有更加特殊和良好的性质:<br>
<img src="https://wangyingying625.github.io/post-images/1615727173636.png" alt="" loading="lazy"></p>
<ol>
<li>完全格:格的每个非空子集都有最大下界和最小上界---如下图<br>
<img src="https://wangyingying625.github.io/post-images/1615726747189.png" alt="" loading="lazy"></li>
<li>分配格:设&lt;L,∧,∨&gt;是格,若对L中任取a,b,c都满足<br>
a∧(b∨c)=(a∧b)∨(a∧c)<br>
a∨(b∧c)=(a∨b)∧(a∨c)<br>
<img src="https://wangyingying625.github.io/post-images/1615727076862.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615727218456.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615727266934.png" alt="" loading="lazy"><br>
没错,我偷懒了🤔</li>
<li>有界格:设&lt;L,∧,∨&gt;是格,存在一个元素a∈L,使得a≤L中所有元素,那么称a是全下界;同时也存在一个元素b∈L,使得使得b≥L中所有元素,那么称b是全上界. 一般把全上界记为1,全下界记为0,有界格也写成&lt;L, ≤, 0, 1&gt;<br>
<img src="https://wangyingying625.github.io/post-images/1615727566609.png" alt="" loading="lazy"></li>
<li>有补格:有补格的定义涉及到补元,首先摆出补元的概念:<br>
补元：有界格&lt;L, ≤, 0, 1&gt;中, 对任意元素a∈L, 若存在b∈L, 并且a∧b = 0, a∨b = 1, 则称b是a的补元，补元不一定唯一。<br>
有补格：每一个元素都有补元，则称为有补格。<br>
有界分配格的补元唯一<br>
有界格中全上界与全下界互补</li>
<li>布尔格:如果一个格是有补分配格，就称为布尔代数<br>
<img src="https://wangyingying625.github.io/post-images/1615727947869.png" alt="" loading="lazy"></li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615728235216.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[群的理解]]></title>
        <id>https://wangyingying625.github.io/post/qun-de-li-jie/</id>
        <link href="https://wangyingying625.github.io/post/qun-de-li-jie/">
        </link>
        <updated>2021-03-14T09:26:42.000Z</updated>
        <content type="html"><![CDATA[<p>今天也是被离散数学折磨的一天<br>
学到了代数系统里的群,据说这是最简答的一种代数系统,不愿意接受自己连最简单的都学不明白的事实于是看了一堆相关的视频和文章,结论如下:</p>
<p>首先,群是一种代数系统,是代数系统就要求它有一些元素,还要求元素之间能进行某种运算.群的运算必须是二元运算,也就是说进行这种运算的只能是两个元素.</p>
<p>那么随便什么运算只要是两个元素之间进行的就可以吗?当然也不是.群对这个二元运算有更高的要求<br>
它要求这个二元运算是封闭的,可结合的,有单位元每个元素都有逆元.</p>
<p>首先封闭要求,群里任意两个元素之间都能进行这种运算,并且运算的结果仍然是群里的元素,不能跑出去</p>
<p>可结合指的是,假设进行运算的是元素a<em>b</em>c那么无论我先进行a<em>b还是b</em>c都不影响运算的结果</p>
<p>有单位元指的是群的元素里面存在那么一个元素,它在群的运算中不起作用,不管和谁运算,结果都是人家</p>
<p>有逆元指的是群中任何一个元素都能在群里找到另外一个元素,他们俩进行运算的结果是单位元.</p>
<p>只有满足以上四个公理的运算和集合才能叫做群.<br>
然而一个群中的元素们也有小团体，关系好的一些元素组成了一个子群，这个团体内也满足群的一切性质，只不过是组成元素是大群的一部分。</p>
<p>在此基础上阿贝尔群指的是,小猫和小狗聊天的结果与小狗和小猫聊天的结果一样最终都聊到了小鸭</p>
<p>循环群指的是,小猫和小猫聊天聊着聊着聊出来小狗,小狗和小猫聊天聊着聊着聊出来小猪...直到把集合里所有元素都聊出来,又聊回去小猫自己.也就是说小猫自己经过聊天这个运算聊出来了集合里的全部小动物们</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tell me about yourself]]></title>
        <id>https://wangyingying625.github.io/post/tell-me-about-yourself/</id>
        <link href="https://wangyingying625.github.io/post/tell-me-about-yourself/">
        </link>
        <updated>2021-03-13T13:51:34.000Z</updated>
        <content type="html"><![CDATA[<p>When you are applying for a position in a company especially English ability in reading and writing is important in the position,or when you are prepareing for the second examination about postgraduate entrance just like me, it is indispensable to introduce yourself in English.<br>
Then I will write about my introduction and my thought about writing it.<br>
(It is my first English blog,Although try my best to check it,errors and defects are inevitable,just forgive me.)</p>
<p>In the first place,post my introduction.It can also help you to know me by reading it.</p>
<blockquote></blockquote>
<p>Good afternoon,teachers.Thank you for the precious opporitunity.<br>
I will introduce myself from three aspects.The first is my basic information,the second is my undergraduate study,and the third is my work experience.</p>
<p>First,My name is mldwyy,twenty-three years old.I was born and raised in LL,a city of XX province.It's well-know for it's food,such as xxx .And in my spare time.I like  playing with my cat.Her name is TaoTao.She is adopted and we adopted her with this name.As for my character,I am a introverted girl.And sometimes I notice that I am shy to share my ideas when there is a room of people.And it is something that I know I need to work on.In fact,recently I having been watching a few TED videos.And through the videos I have picked up a lot tools.Now they are helping me a lot.</p>
<p>Second, I graduated from the xxx departmen of xx University in July,two thousand twenty.I have been study hard during my school time and my grade is excellent and I have gained scholarship several times.Because I didn't pass the examPostgraduate Candidates Exempt from Admission Exam</p>
<p>Third,I have worked in an Internet company as a front-end engineer for nearly four months.My daily job was reading technical documentations and useing it to writie website programmes.So it is my strength that read and summarize a documentation  in a short time. And it was during that time that I decided to choose network security as my future major.I find it's necessary to help Interent Internet company improve the safety of their products.And that's I am passionate about.To learn more about it ,I ask for my friend in that major about a workable study plan and learned the basics of common vulnerabilities. I wish to devote my life and energy into the development of it.</p>
<p>That's all,Thanks for your listening.</p>
<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言]]></title>
        <id>https://wangyingying625.github.io/post/c-yu-yan/</id>
        <link href="https://wangyingying625.github.io/post/c-yu-yan/">
        </link>
        <updated>2021-03-12T09:25:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="unsigned与signed的转换">unsigned与signed的转换</h3>
<p>负数用补码表示,signed转化为unsigned时候不对数据做任何转换,只改变对数据的解释方式(即把以补码表示的负数直接输出)</p>
<pre><code class="language-c"> unsigned short a = -1;
    short b = a;
    ```
    输出b:-1,a:65535

### scanf结束之后会有一个'\n',如果scanf之后跟着getchar将会认为scanf结束时候的'\n'是getchar的输入
需要多加一个getchar()屏蔽\n的影响

### </code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见算法]]></title>
        <id>https://wangyingying625.github.io/post/chang-jian-suan-fa/</id>
        <link href="https://wangyingying625.github.io/post/chang-jian-suan-fa/">
        </link>
        <updated>2021-03-12T08:27:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="把一个数组根据下标是奇数还是偶数分割成两个数组">把一个数组根据下标是奇数还是偶数分割成两个数组</h3>
<p>假设要分割的数组a=[1,2,3,4,5,6,7,8,9]</p>
<ol>
<li>定义一个变量i用来遍历数组a;</li>
<li>定义一个变量j用来标识数组b中下一个元素要存储的位置;</li>
<li>定义一个变量k用来标识数组c中下一个元素要存储的位置<br>
当(i%2)==0把a[i]中的值存入数组b[j++]<br>
否则把a[i]中的值存入数组c[k++]</li>
</ol>
<h3 id="删除字符串中的所有空格并且输出删除后的字符串以及被删除的空格数">删除字符串中的所有空格并且输出删除后的字符串以及被删除的空格数</h3>
<p>假设被操作的字符串是s=['h','e','l','l','o',' ','w','o','r','d']</p>
<ol>
<li>定义一个变量i用来遍历字符串s</li>
<li>定义一个变量j用来标识删除过后的字符串下个元素要存入的位置</li>
<li>遍历字符串s,如果当前字符是' ',则指针i后移;若当前字符不是' '则把当前字符存入s[j]的位置,并且j++</li>
<li>被删除的空格数就是i-j</li>
</ol>
<h3 id="排序算法">排序算法</h3>
<h4 id="选择">选择</h4>
<ol>
<li>简单选择:<br>
每一轮从未排好序的序列里选择一个最小的,与最前面未排序的元素交换<br>
直到排好</li>
<li>堆排序</li>
</ol>
<h4 id="交换">交换</h4>
<ol>
<li>冒泡<br>
从数组头开始两两比较,若前面的比后面的大就交换,第一轮比较结束时最大的元素被移动到最后<br>
从数组头开始再次两两比较,比较到倒数第二个时候截止<br>
...重复直到比较完或者一轮都没有交换</li>
<li>快排<br>
选取数列的第一个元素作为基准<br>
从第二个元素开始与基准比较,若比基准小就放到当前基准在数组中的地方,并把基准在数组中的指针向后移1</li>
</ol>
<h4 id="插入">插入</h4>
<ol>
<li>简单插入<br>
默认第一个元素排好序,从第二个元素开始,和前面的元素比较,若比前面的元素小就交换,直到比前面的大,开始下一轮比较直到全部排好</li>
<li>希尔排序<br>
把表按照某一特定增量k分割<br>
同一增量下的元素进行简单插入排序<br>
增量变为k/2,重复上述过程</li>
</ol>
<h4 id="归并">归并</h4>
<ol>
<li>二路归并排序<br>
把数组分为n/2个等长的子数组<br>
每个子数组里进行二路归并排序<br>
将排好序的相邻两个子数组再进行二路归并排序,知道最后只剩下两个n/2的数组</li>
</ol>
]]></content>
    </entry>
</feed>