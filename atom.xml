<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangyingying625.github.io</id>
    <title>mldwyy</title>
    <updated>2021-03-11T11:40:09.717Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangyingying625.github.io"/>
    <link rel="self" href="https://wangyingying625.github.io/atom.xml"/>
    <logo>https://wangyingying625.github.io/images/avatar.png</logo>
    <icon>https://wangyingying625.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, mldwyy</rights>
    <entry>
        <title type="html"><![CDATA[代数系统]]></title>
        <id>https://wangyingying625.github.io/post/dai-shu-xi-tong/</id>
        <link href="https://wangyingying625.github.io/post/dai-shu-xi-tong/">
        </link>
        <updated>2021-03-11T02:23:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="代数结构">代数结构</h2>
<p>结构=集合+对应规则+公理</p>
<h3 id="代数系统基本概念">代数系统基本概念</h3>
<h4 id="代数系统的构成">代数系统的构成:</h4>
<ol>
<li>成分:载体(集合)和运算</li>
<li>公理:运算性质(交换结合分配零元单位元等)</li>
</ol>
<h5 id="n元运算">n元运算</h5>
<h6 id="定义">定义:</h6>
<ol>
<li>设A是集合,函数f:AXA-&gt;A称为A上的二元运算,也可以写为f(&lt;a1,a2&gt;)=a3</li>
<li>AXA意味着该二元运算的定义域是A即两次从A中任选元素都能进行运算(两次可选同意元素),如果随便取两次取出的a不能进行f这种运算,那么f就不是二元运算.(除法不是实数集合上的二元运算,当除数取0时候不能运算)</li>
<li>值域也是A,即运算对集合是封闭的</li>
</ol>
<h6 id="写法">写法:</h6>
<p>n元运算的写法:<br>
o(x1,x2,x3,x4,x5...)=y</p>
<h6 id="表示">表示:</h6>
<ol>
<li>表达式:xoy=x+y*2</li>
<li>运算表,左边第一列和上边第一行列出参与运算的表达式,中间写入运算的结果</li>
</ol>
<h6 id="二元运算律">二元运算律:</h6>
<p>####### 只涉及一个二元运算的:</p>
<ol>
<li>交换:aob=boa</li>
<li>结合:(aob)oc=ao(boc)</li>
<li>幂等:aoa=a</li>
<li>消去:aob=aoc∧a≠𝛉=&gt;b=c(a不是零元)<br>
####### 涉及两个运算的</li>
<li>分配:ao(b<em>c)=(aob)</em>(aoc),(b<em>c)oa=(boa)</em>(coa)</li>
<li>吸收:ao(a<em>b)=a,a</em>(aob)=a</li>
</ol>
<h6 id="特异元素的定义与性质">特异元素的定义与性质</h6>
<ol>
<li>单位元e:eoa=aoe=a(对系统中所有元素都满足,一系统最多一个)运算中不起作用</li>
<li>零元𝛉:𝛉oa=ao𝛉=𝛉(对系统中所有元素)</li>
<li>幂等元a:aoa=a</li>
<li>可逆元x:xoy=yox=e</li>
</ol>
<p>单位元和零元存在必唯一<br>
可结合的运算逆元必定唯一</p>
<h6 id="判断某一给定运算是否满足某些二元运算律是否有特异元素">判断某一给定运算是否满足某些二元运算律,是否有特异元素</h6>
<ol>
<li>表达式法</li>
<li>表格法</li>
</ol>
<h4 id="构成代数系统的方法">构成代数系统的方法</h4>
<ol>
<li>从原有代数系统抽一子集出来</li>
<li>由不同的代数系统做笛卡尔积(把两个不同的代数系统组合成新的代数系统)</li>
<li>抽象</li>
</ol>
<h3 id="代数系统">代数系统</h3>
<h4 id="概念">概念</h4>
<ol>
<li>
<p>成分:V=&lt;A,o,*...&gt;<br>
其中:A是载体,非空<br>
后面都是对集合A的各种运算</p>
</li>
<li>
<p>分类:<br>
同类型的:构成成分相同(如都有两个二元运算的&lt;Z,+,-&gt;和&lt;S,*,/&gt;)<br>
同种的:构成成分和公理都相同</p>
<p>构成成分:运算个数,对应运算的元数<br>
公理:交换,结合,幂等,吸收,分配,小区率,单位元...</p>
</li>
</ol>
<h4 id="由一个代数系统产生更多代数系统的方法">由一个代数系统产生更多代数系统的方法</h4>
<h5 id="子代数">子代数:</h5>
<p>代数系统里是否存在一子集,子集能良好的保持代数系统的性质:</p>
<ol>
<li>定义:设V=&lt;A,o1,o2,o3,...&gt;是代数系统,B是A的非空子集.若B对于V中的所有运算封闭,则称&lt;B,o1,o1...&gt;是V的子代数,若B真包含与A则称其是V的真子代数</li>
<li>当集合A里只有一个元素时是平凡的子代数</li>
</ol>
<h5 id="积代数">积代数:</h5>
<p>一. 定义:设V1=&lt;A,o,o1,o2...&gt;与V2=&lt;B,*,*1,<em>2...&gt;是同类型的代数系统,对于i=1,2,3...,两个代数系统中oi与</em>i对应的元数一样,则V1xV2=&lt;AxB,<sub>,</sub>1,~2,...&gt;<br>
其中:AxB是集合A与B的笛卡尔积<br>
本来的代数系统集合A是元素为数字或者字符或者矩阵的集合,生成的积代数的元素A'是序偶对的集合<br>
<img src="https://wangyingying625.github.io/post-images/1615445753647.jpg" alt="" loading="lazy"><br>
二. 性质:</p>
<ol>
<li>若第一个系统的第i个运算可交换,第二个系统的第i个运算也可交换,则生成的积代数的运算oi也是可交换的(可结合和幂等也有一样的性质)</li>
<li>若原来的因子运算oi,oj可分配且*i,*j可分配,那么新生成的<sub>i,</sub>j也可分配(吸收率也有改性质)</li>
<li>两个系统中的针对相同位置的运算oi,*i的零元和单位元相应的组合也是新运算中的零元和单位元</li>
<li>两个系统中的针对相同位置含单位元的运算oi,*i的逆元相应的组合也是新运算中的逆元</li>
</ol>
<h4 id="同构和同态代数系统之间的关系">同构和同态(代数系统之间的关系):</h4>
<p>把一个代数系统同函数映射到另外一个代数系统<br>
两个系统如果同构就没有区别,不过是赋予了不同的含义</p>
<h5 id="同态可以把一些有相同性质的代数系统联系起来">同态:(可以把一些有相同性质的代数系统联系起来)</h5>
<p>V1=&lt;A,o,o1,o2...&gt;,V2=&lt;B,*,*1,*2...&gt;是同类型的代数系统,假设oi是r元的,*i也是r元的,若满足:<br>
f(oi(a1,a2,a3...))=*i(f(a1),f(a2),f(a3)...),其中a1,a2,a3都是A中的元素<br>
即先运算再映射的值与先映射再运算的值相等<br>
<img src="https://wangyingying625.github.io/post-images/1615449353651.jpg" alt="" loading="lazy"></p>
<h5 id="同构">同构:</h5>
<p>同态按照映射类型可分为:<br>
单同态<br>
满同态<br>
同构<br>
<img src="https://wangyingying625.github.io/post-images/1615451578931.jpg" alt="" loading="lazy"></p>
<h4 id="同余关系和商代数">同余关系和商代数</h4>
<p>同余关系是一个等价关系,通过这个关系可以把元素划分成等价类.两个元素彼此等价,则运算过程中替换后,运算结果还等价.由此可把类抽象,即认为同一个类中的元素是一个元素.<br>
<img src="https://wangyingying625.github.io/post-images/1615458497151.jpg" alt="" loading="lazy"></p>
<h4 id="把代数系统进行分类得到不同种类的代数系统">把代数系统进行分类,得到不同种类的代数系统</h4>
<ol>
<li>只有一个运算的半群和群</li>
<li>有两个运算的环域</li>
<li>还有两个运算的格和布尔代数</li>
</ol>
<hr>
<h3 id="半群和独异点只有一个二元运算">半群和独异点(只有一个二元运算)</h3>
<p>广群:只需具备封闭性--&gt;添加公理<br>
半群:可结合的--&gt;添加公理<br>
独异点:含单位元</p>
<h4 id="半群">半群:</h4>
<h4 id="独异点含幺半群">独异点(含幺半群)</h4>
<p>可通过对半群增加单位元并且定义与单位元相关的运算扩张而成</p>
<h3 id="群">群(*)</h3>
<h3 id="环和域">环和域</h3>
<h3 id="格和布尔代数">格和布尔代数</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散数学思维导图]]></title>
        <id>https://wangyingying625.github.io/post/chi-san-shu-xue-si-wei-dao-tu/</id>
        <link href="https://wangyingying625.github.io/post/chi-san-shu-xue-si-wei-dao-tu/">
        </link>
        <updated>2021-03-10T08:52:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数理逻辑">数理逻辑</h2>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615366403802.png" alt="" loading="lazy"></figure>
<h2 id="集合论">集合论</h2>
<figure data-type="image" tabindex="2"><img src="https://wangyingying625.github.io/post-images/1615429075509.png" alt="" loading="lazy"></figure>
<h2 id=""></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[爱读书的大肥兔]]></title>
        <id>https://wangyingying625.github.io/post/ai-du-shu-de-da-fei-tu/</id>
        <link href="https://wangyingying625.github.io/post/ai-du-shu-de-da-fei-tu/">
        </link>
        <updated>2021-03-10T04:38:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="被人讨厌的勇气">被人讨厌的勇气</h3>
<ol>
<li>既没有自卑感也不必炫耀优越性,能够保持一种平静而自然的状态.真正的爱应该是这样的.</li>
<li>过于希望得到别人的认可,就会按照别人的期待去生活.也就是舍弃真正的自己,活在别人的人生中.</li>
<li>假如说你不是为了满足别人的期待而活,那么他人也不是为了满足你的期待而活,当别人的行为不符合自己的想法时也不可发怒.</li>
<li>想要取得别人的认可的时候,几乎所有人都会采取&quot;满足别人的期待&quot;这一手段,这其实都是受&quot;如果做了恰当的事情就能够得到表扬&quot;这种赏罚教育的影响.但是,若果工作的主要目标变成了&quot;满足别人的期待&quot;,那工作就会变得相当痛苦.因为那样就会一味的在意别人的实现,害怕别人的评价,根本无法做真正的自己.</li>
<li>基本上,一切人际关系矛盾都起因于对别人的课题王加干涉或者自己的课题被别人妄加干涉.</li>
<li>时尚的父母总是说&quot;为你着想&quot;之类的话,但是,父母的行为有时候很明显是为了满足自己的目的--面子和虚荣又或者是支配欲.正因为察觉到了这种欺骗行为,孩子才会反抗.</li>
<li>关于自己的人生你能够做的就只有&quot;选择自己认为最好的道路&quot;.另一方面,别人如何评价你的选择,那是别人的课题,你根本无法左右.</li>
<li>没有学会直面困难的孩子最终会想要逃避一切困难.<br>
<img src="https://wangyingying625.github.io/post-images/1615352619902.jpg" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合论]]></title>
        <id>https://wangyingying625.github.io/post/ji-he/</id>
        <link href="https://wangyingying625.github.io/post/ji-he/">
        </link>
        <updated>2021-03-09T05:52:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="集合论">集合论:</h2>
<p>用集合论作为描述工具<br>
集合中的元素要各不相同<br>
集合中的元素不规定顺序<br>
集合的两种表示法可以互相转换</p>
<h3 id="集合基本概念">集合基本概念</h3>
<h4 id="集合的表示">集合的表示:</h4>
<ol>
<li>列举法 A={1,2,3}</li>
<li>描述法</li>
</ol>
<h3 id="常用术语">常用术语:</h3>
<ol>
<li>子集⊆:若B是A的子集,要求B中元素都是A中元素,也叫B包含于A,A包含B.空集是一切集合的子集</li>
<li>相等:A包含B且B包含A</li>
<li>真子集⊂:A是B的子集且A不等于B,则A⊂于B</li>
<li>幂集:设A是一个集合,则由A的全体子集组成的集合是A的幂集,记为P(A)</li>
<li>集合的元素个数:|A|表示集合A中的元素个数<br>
若|A|=n,则|P(A)|=2ⁿ</li>
<li>定义域:dom R</li>
<li>值域:ran R</li>
<li>域:ran R U dom R</li>
</ol>
<h3 id="集合的运算">集合的运算:</h3>
<ol>
<li>并集∪:设A与B为两个集合,由A和B中所有元素组成的集合是A和B的并集AUB</li>
<li>交集∩</li>
<li>不相交:设A和B为两个集合,若A∩B=∅,则A与B不相交</li>
<li>相对补:A-B,属于集合A而不属于集合B的全体元素</li>
<li>绝对补:任意集合A对全集E的绝对补,记为~A</li>
<li>对称差⨁:属于A不属于B的和属于B但不属于A的全体元素组成的集合</li>
<li>文氏图:集合与集合之间的关系以及一些运算的结果可以用文氏图直观表示.其中矩阵表示全集,圆或者其他封闭的曲线可以表示E的子集,运算结果得到的集合用阴影表示.<br>
<img src="https://wangyingying625.github.io/post-images/1615262997178.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="基本的集合恒等式">基本的集合恒等式:</h3>
<p>设E是全集,A,B,C是E的任意子集:</p>
<ol>
<li>幂等律:A ∪ A=A ,  A∩A=A</li>
<li>交换律:AUB=BUA ,A ∩B=B∩A</li>
<li>结合律:(AUB)UC=AU(BUC) , (A∩B)∩C=A∩(B∩C)</li>
<li>分配律:AU(B∩C)=(AUB)∩(AUC) , A∩(BUC)=(A∩B)U(A∩C)</li>
<li>德摩根律:<sub>(AUB)=</sub> A∩~B , <sub>(A∩B)=</sub>AU~B</li>
<li>吸收率:AU(A∩B)=A , A∩（AUB）= A</li>
<li>零律:AUE=E , A∩∅=∅</li>
<li>同一律:AU∅=A , A∩E=A</li>
<li>排中律:AU~A=E</li>
<li>矛盾律:A∩~A=∅</li>
<li>余补律:~∅=E , ~E=∅</li>
<li>双重否定率:<sub>(</sub>A)=A</li>
<li>补交转换率:A-B=A∩~B<br>
优先级:绝对补 幂集 广义交 广义并,并 交 相对补 对称差<br>
集合等式的证明可以用命题演算证明<br>
<img src="https://wangyingying625.github.io/post-images/1615269104056.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="有序对">有序对:</h3>
<p>&lt;a,b&gt;={{a},{a,b}},其中a是第一元素,b是第二元素.<br>
&lt;a,b,c&gt;=&lt;&lt;a,b&gt;,c&gt;  有序三元组</p>
<h3 id="卡式积笛卡尔积">卡式积(笛卡尔积):</h3>
<p>A与B是两个集合,他们的卡式积是一个新的集合.集合中的元素都是有序对,有序对中第一元素都在A中,第二元素都在B中,所有这样的有序对构成卡式积.</p>
<h4 id="卡式积性质">卡式积性质:</h4>
<ol>
<li>非交换(除非A=B或者A=∅或者B=∅)Ax∅=∅</li>
<li>非结合:(AxB)xc≠Ax(Bxc)甚至(AxA)xA≠Ax(AxA)</li>
<li>分配律:Ax(B∪C)=(AxB)∪(AxC)</li>
<li>AxB=∅ &lt;=&gt; A=∅∪B=∅两非空集合卡式积一定非空</li>
<li>无零因子</li>
</ol>
<p>性质证明:<br>
设A,B,C是任意集合:证明若A≠∅,则AxB ⊆ AxC &lt;=&gt; B ⊆ C<br>
<img src="https://wangyingying625.github.io/post-images/1615272819895.jpg" alt="" loading="lazy"></p>
<h2 id="二元关系与关系数据库相关">二元关系(与关系数据库相关)</h2>
<p>元素都是有序n元素的集合叫n元关系<br>
F1={&lt;1,2,3&gt;,&lt;你,我,他&gt;}是一个三元关系</p>
<h3 id="基本概念">基本概念</h3>
<ol>
<li>
<p>关系(2元关系):元素全是有序对的集合<br>
F1={&lt;1,2&gt;,&lt;2,3&gt;}<br>
F2={&lt;1,2&gt;,3,4}不是二元关系,其中3,4不是有序对</p>
</li>
<li>
<p>A到B的二元关系:AxB的任意子集(A对B的笛卡尔乘积都是A到B的二元关系)<br>
若|A|=m,|B|=n,则|AxB|=mn,|P(AxB)|=2nm次方<br>
即A到B的不同二元关系有2nm次方个</p>
<p>例1:设A={a1,a2},B={b1}<br>
则A到B的二元关系有:<br>
R1=∅,R2={&lt;a1,b1&gt;},R3={<a2>,<b1>},R4={&lt;a1,b1&gt;,&lt;a2,b1&gt;}<br>
B到A的二元关系有:<br>
R1=∅,R2={&lt;b1,a1&gt;},R3={<b1>,<a2>},R4={&lt;b1,a1&gt;,&lt;b1,a2&gt;}</p>
</li>
<li>
<p>恒等关系:A中每个元素自己和自己有关系的那种关系</p>
</li>
</ol>
<h3 id="基本运算">基本运算:</h3>
<ol>
<li>逆</li>
<li>合成(复合函数)</li>
<li>限制⨡:关系F和集合A,关系F对A的限制就是一些关系的集合,这些关系满足第一元素来自于A</li>
<li>象F[{a}]:关系F在集合A上的象就是F中第一个元素在A里面的第二个元素的集合(类似于H(A))</li>
<li>单根:F是单根的意味着在关系F=&lt;x,y&gt;中,<strong>任意</strong>一个y都对应<strong>唯一</strong>的x</li>
<li>单值:F是单值的意味着F中<strong>任意</strong>一个x都唯一对应一个y</li>
<li>(FoG)的逆=G-1oF-1</li>
</ol>
<p><img src="https://wangyingying625.github.io/post-images/1615276477548.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615277275790.jpg" alt="" loading="lazy"></p>
<h3 id="表示和性质">表示和性质</h3>
<h4 id="表示">表示:</h4>
<ol>
<li>集合</li>
<li>关系矩阵</li>
<li>关系图</li>
</ol>
<h4 id="性质">性质:</h4>
<ol>
<li>自反:设R是A上的一个二元关系,说R是自反的当且仅当任取x在集合A里那么&lt;x,x&gt;就有关系R.集合中的每个元素自己都和自己有关系(全部x都得满足)[关系矩阵主对角线元素都是1,关系图每个顶点都有环]</li>
<li>反自反:任何x,自己和自己都没有关系(所有X都不能和自己有关系R)[要求每个点都没有环,主对角线全为0]</li>
<li>非自反:存在x属于A那么&lt;x,x&gt;必不属于关系R(只要有一个不属于就行)</li>
<li>对称:任选x和y,如果&lt;x,y&gt;有关系R那么&lt;y,x&gt;也有关系R(相等关系)[关系图中不同两点间必然是双箭头,矩阵中必然是对称矩阵]任何两个点间都没有边的关系既是对称的也是反对称的</li>
<li>反对称:任何两个点之间只有一条有向边</li>
<li>非对称:只有有一个&lt;x,y&gt;不对称[存在两个点间只有一条边]</li>
<li>传递:当X和Y有关系,并且Y和Z有关系时,X和Z有关系(R和R的合成是R的子集)</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615280969332.jpg" alt="" loading="lazy"></figure>
<h3 id="闭包">闭包:</h3>
<p>关系的幂:<br>
<img src="https://wangyingying625.github.io/post-images/1615283212083.jpg" alt="" loading="lazy"><br>
包含给定的元素并且具有给定性质的最小集合</p>
<ol>
<li>自反闭包:要求都包含关系R,结果的二元关系是自反的(原来的R可能不自反,加一些元素使其自反),并且是最小的,R的自反闭包用r(R)表示</li>
<li>对称闭包:...结果的二元关系是对称的...,R的对称闭包用s(R)表示(任意两个结点都是对称的)</li>
<li>传递闭包:...结果的二元关系是传递的...R的传递闭包用t(R)表示(任意两个结点都是传递的)<br>
r(R1UR2)=r(R1)Ur(R2)并起来并不会增加环的数量<br>
s(R1UR2)=s(R1)Us(R2)两点之间本来就都有两条边,并起来并不会增加双向边的数量<br>
t(R1UR2)⊇t(R1)Ut(R2)并了以后长度为2 的路径会更多</li>
</ol>
<h4 id="求法">求法:</h4>
<p>r(R)=RUIA(恒等关系);矩阵上就是把对角线元素都改为1;图上就是每个点都加环<br>
s(R)=RUR逆;矩阵上变为对称阵;原来无边的不用加,原来有一条半的加反向边<br>
t(R)=RUR²UR³U...<br>
<img src="https://wangyingying625.github.io/post-images/1615287920816.jpg" alt="" loading="lazy"><br>
sr(R)=rs(R) , tr(R)=rt(R) , st(R)不一定对称⊆ts(R)</p>
<h3 id="等价关系用来分类">等价关系(用来分类)</h3>
<p>设A≠∅,且R⊆AxA,若R是自反的对称的传递的,则R是等价关系</p>
<h4 id="性质-2">性质:</h4>
<p>设R是A≠∅上的等价关系,则⩝x,y∈A有</p>
<ol>
<li>[x]≠∅(必定有x自己)</li>
<li>xRy=&gt;[x]=<a href="x%E5%92%8Cy%E6%9C%89%E5%85%B3%E7%B3%BB,y%E4%B9%9F%E5%92%8Cx%E6%9C%89%E5%85%B3%E7%B3%BB,y%E8%BF%98%E5%92%8C%E5%AE%83%E6%89%80%E5%9C%A8%E7%AD%89%E4%BB%B7%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0%E6%9C%89%E5%85%B3%E7%B3%BB,%E9%82%A3x%E4%B9%9F%E5%92%8Cy%E7%9A%84%E7%AD%89%E4%BB%B7%E7%B1%BB%E6%9C%89%E5%85%B3%E7%B3%BB">y</a></li>
<li>¬ xRy=&gt;[x]∩[y]≠∅当两元素没关系时他们的等价类一定不相交</li>
<li>所有等价类并起来就是原集合A</li>
</ol>
<h3 id="商集分类结果">商集:分类结果</h3>
<h3 id="序关系用来在一个类里排序">序关系(用来在一个类里排序)</h3>
<h1 id="函数">函数</h1>
<h1 id="自然数">自然数</h1>
<h1 id="基数和序数">基数和序数</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OWASP问题版]]></title>
        <id>https://wangyingying625.github.io/post/owasp-wen-ti-ban/</id>
        <link href="https://wangyingying625.github.io/post/owasp-wen-ti-ban/">
        </link>
        <updated>2021-03-08T13:31:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sql">SQL</h2>
<h3 id="什么情况下会产生sql注入漏洞">什么情况下会产生SQL注入漏洞</h3>
<p>SQL注入漏洞的产生是由于程序将用户的输入当做SQL语句的一部分,拼接在程序写好的那部分SQL语句后面执行了.那么当用户在输入时,利用UNION连接符拼接恶意的SQL语句,这些语句也将会被执行.</p>
<h3 id="如何测试某个功能点是否存在sql注入漏洞">如何测试某个功能点是否存在SQL注入漏洞</h3>
<p>如果是int型并且插入位置在WHERE后面:可在输入的位置添加 AND 1=2,看执行结果是否 (如果是字符型需要考虑括号的闭合)<br>
可用#屏蔽后面的SQL代码</p>
<h3 id="预防">预防:</h3>
<ol>
<li>对SQL语句预编译</li>
<li>对单引号进行转义</li>
<li>强制类型转换为数字</li>
</ol>
<h2 id=""></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散数学问题]]></title>
        <id>https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/</id>
        <link href="https://wangyingying625.github.io/post/chi-san-shu-xue-wen-ti/">
        </link>
        <updated>2021-03-08T08:23:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="命题与陈述句有什么关系">命题与陈述句有什么关系?</h2>
<p>命题是具有确定真假值的陈述句,由于命题有确定的真假值,所以可以当做布尔变量看待它</p>
<h2 id="如何从真值表写出主析取合取范式">如何从真值表写出主析取(合取)范式?</h2>
<p>主析取范式是极小项析取组成的,只需根据真值表写出满足条件的极小项即可.那么如何去找满足条件的极小项呢,要想让主析取范式(与原式等价)取真要求任一极小项取真,那么把所有极小项赋值为真的指派并起来就是主析取范式<br>
主合取范式是有极大项组成的,要想让主合取范式(原式)取假只需任一极大项取假,假设p=0,q=1时原命题为假,那么其中一个极大项应该为(p∨¬q)<br>
若得出主析取范式也可用主析取范式直接求出主合取范式</p>
<h2 id="如何判断两个公式是否等价">如何判断两个公式是否等价</h2>
<ol>
<li>列两个公式的真值表,若各种指派下他们俩取值都相等就等价</li>
<li>用基本等价公式推导证明</li>
<li>求各自的主析取(合取)范式,若所有的两个范式一样那就等价</li>
</ol>
<h2 id="如何给集合下定义">如何给集合下定义</h2>
<p>具有某种特殊性质的客体的集合</p>
<h2 id="二元关系有哪些表示方法">二元关系有哪些表示方法</h2>
<ol>
<li>集合表示法</li>
<li>矩阵表示</li>
<li>图表示</li>
</ol>
<h2 id="如何用集合定义关系函数">如何用集合定义关系,函数</h2>
<p>关系是以序偶作为元素的集合<br>
函数是一种特定的关系,要求定义域中的每个x都能唯一确定y</p>
<h2 id="什么是商集什么是划分">什么是商集,什么是划分</h2>
<p>商集是等价关系下的划分</p>
<h2 id="如何构造从集合a到集合b的双射函数">如何构造从集合A到集合B的双射函数</h2>
<ol>
<li>若AB都是有穷集合,先列出AB在把AB中的元素进行对应</li>
<li>若AB是实数区间,则平滑连接点&lt;A最小,B最小&gt;到&lt;A最大,B最大&gt;</li>
<li>若AB都是无穷集合,则把AB分别列出来,从前往后一一对应</li>
</ol>
<h2 id="什么是图">什么是图</h2>
<h2 id="有哪些图">有哪些图</h2>
<h2 id="图有什么性质">图有什么性质</h2>
<h2 id="什么是欧拉图">什么是欧拉图</h2>
<h2 id="什么是哈密顿图">什么是哈密顿图</h2>
<h2 id="什么是树">什么是树</h2>
<h2 id="如何用矩阵表示图">如何用矩阵表示图</h2>
<h2 id="什么是平面图">什么是平面图</h2>
<h2 id="什么是图的着色">什么是图的着色</h2>
<h2 id="什么是带权图">什么是带权图</h2>
<h2 id="什么是支配集">什么是支配集</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图论]]></title>
        <id>https://wangyingying625.github.io/post/tu-lun/</id>
        <link href="https://wangyingying625.github.io/post/tu-lun/">
        </link>
        <updated>2021-03-08T08:22:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="图">图</h1>
<h2 id="基本概念">基本概念</h2>
<h2 id="连通性">连通性</h2>
<h2 id="欧拉图与哈密顿图">欧拉图与哈密顿图</h2>
<h2 id="树">树</h2>
<h2 id="图的矩阵表示">图的矩阵表示</h2>
<h2 id="平面图">平面图</h2>
<h2 id="着色">着色</h2>
<h2 id="带权图">带权图</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命题和谓词逻辑]]></title>
        <id>https://wangyingying625.github.io/post/ji-he-lun/</id>
        <link href="https://wangyingying625.github.io/post/ji-he-lun/">
        </link>
        <updated>2021-03-08T08:18:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2>
<h3 id="命题公式">命题公式:</h3>
<h4 id="联结词">联结词:</h4>
<p>p,q,r...表示原子命题(简单命题,可当做逻辑变量即布尔变量);0表示假,1表示真</p>
<ol>
<li>否定联结词 ¬ :<br>
¬p称为p的否定式 :<br>
<img src="https://wangyingying625.github.io/post-images/1615192683283.png" alt="" loading="lazy"></li>
<li>合取联结词∧:<br>
p ∧q称为p与q的合取式<br>
<img src="https://wangyingying625.github.io/post-images/1615192963199.png" alt="" loading="lazy"></li>
<li>析取联结词∨:<br>
p∨q称为q与p的析取式<br>
<img src="https://wangyingying625.github.io/post-images/1615193105570.png" alt="" loading="lazy"></li>
<li>蕴涵联结词-&gt;:<br>
p-&gt;q的真假性与p&lt;=q一致<br>
<img src="https://wangyingying625.github.io/post-images/1615193176146.png" alt="" loading="lazy"></li>
<li>等价联结词&lt;-&gt;:<br>
p&lt;-&gt;q与p==q真假性一致<br>
<img src="https://wangyingying625.github.io/post-images/1615193661156.png" alt="" loading="lazy"><br>
优先级: ¬ ,∨ ∧,-&gt; &lt;-&gt;</li>
</ol>
<h3 id="命题公式-2">命题公式:</h3>
<h4 id="命题公式的组成">命题公式的组成:</h4>
<ol>
<li>单个命题变元就是命题公式</li>
<li>对命题变元进行有限次联结词连接得到的也是命题公式</li>
</ol>
<h4 id="命题公式的类型">命题公式的类型:</h4>
<ol>
<li>可满足式:当一个命题公式,其中的原子命题取不同的值时可能对应公式取值为真.</li>
<li>矛盾式(永假式):原子命题所有可能的取值组合(0,1组合)下,此公式的取值都为假</li>
<li>重言式(永真式):原子命题所有可能的取值组合(0,1组合)下,此公式的取值都为真(是可满足式的一种)</li>
</ol>
<h3 id="等值式">等值式:</h3>
<p>定义:两个命题公式满足A&lt;=&gt;B则A&lt;-&gt;B是永真式.即A与B可以互相代替</p>
<p>正确性的证明:两边列真值表,若在原子命题取不同值的时候两边的取值都一样,则验证正确</p>
<h4 id="常用等值式">常用等值式:</h4>
<ol>
<li>蕴涵等值式:p-&gt;q  &lt;=&gt;   ¬ p∨q  (蕴涵联结词是多余的,可被与或非表示)</li>
<li>幂等律：A∧A⇔A      ||||||||||        A∨A⇔A</li>
<li>交换律：A∨B⇔B∨A    ||||||||||||     A∧B⇔B∧A</li>
<li>结合律：<br>
（A∧B）∧C⇔A∧（B∧C）<br>
（A∨B）∨C⇔A∨（B∨C）</li>
<li>分配律：<br>
A∨（B∧C）⇔（A∨B）∧（A∨C）<br>
A∧（B∨C）⇔（A∧B）∨（A∧C）</li>
<li>德摩根律：<br>
┐（A∨B）⇔┐A∧┐B<br>
┐（A∧B）⇔┐A∨┐B</li>
<li>吸收律：<br>
A∨（A∧B）⇔A<br>
A∧（A∨B）⇔A</li>
<li>零律：<br>
A∨1⇔1<br>
A∧0⇔0</li>
<li>同一律：<br>
A∨0⇔A<br>
A∧1⇔A</li>
<li>排中律：A∨┐A⇔1(若A不对则非A一定对)</li>
<li>矛盾律：A∧┐A⇔0(若A对则非A一定不对)</li>
<li>双重否定律：┐┐A⇔A</li>
<li>等价等值式:A&lt;-&gt;B &lt;=&gt; (A -&gt; B)∧(B-&gt;A) (等价联结词是多余的,可被蕴含联结词和与或非表示)</li>
<li>等价否定等值式：A↔B⇔┐A↔┐B</li>
<li>归谬论：（A→B）∧（A→┐B）⇔┐A<br>
只涉及与或非时,与跟或换时0跟1也换</li>
</ol>
<h4 id="等值演算就是给一个命题公式通过等值式的转换得到另外一个命题公式他们俩是等价的可用真值表验证">等值演算:就是给一个命题公式通过等值式的转换得到另外一个命题公式,他们俩是等价的(可用真值表验证)</h4>
<p>判断两个公式是否相等的两种方法:等值演算;列真值表<br>
任何两个公式只要是相等的一定能通过等值演算证明</p>
<h3 id="推理">推理:</h3>
<p>由一个命题得出另外一个命题的过程</p>
<h4 id="推理的形式结构">推理的形式结构:</h4>
<p>前提:A1,A2,A3...<br>
结论:B<br>
形式结构:<br>
(A1 ∧ A2 ∧ A3 ∧ A4...)-&gt;B</p>
<h4 id="推理定律">推理定律</h4>
<p>A=&gt;B则A-&gt;B是永真式</p>
<ol>
<li>拒取式:(A-&gt;B)∧ ¬ B  =&gt;  A</li>
<li>附加律:A=&gt;(A∨B)</li>
<li>化简律:(A∧B)=&gt;A,(A∧B)=&gt;B</li>
<li>假言:(A-&gt;B)∧A=&gt;B(A能推出B,并且A是对的,那么B就是对的)</li>
<li>析取三段论:(A∨B)∧ ¬ A=&gt;B<br>
(AVB)∧ ¬ B=&gt;A<br>
A和B必有嫌疑人,排除A那B是嫌疑人</li>
<li>假言三段论:(A-&gt;B)∧(B-&gt;C) =&gt;(A-&gt;C)</li>
<li>等价三段论:(A&lt;-&gt;B)∧(B&lt;-&gt;C) =&gt;(A&lt;-&gt;C)</li>
<li>构造性两难:(A-&gt;B)∧(C-&gt;D)∧(AVC) =&gt; (BVD)</li>
</ol>
<h4 id="判断推理正确的方法">判断推理正确的方法</h4>
<p>前提:p-&gt;(q-&gt;r),p,q<br>
结论:r<br>
方法一:</p>
<ol>
<li>写出推理的形式结构</li>
<li>证明该形式结构永真<br>
<img src="https://wangyingying625.github.io/post-images/1615198910960.jpg" alt="" loading="lazy"><br>
方法二:从前提推演结论<br>
(P-&gt;(q-&gt;r))∧p∧q  =&gt;<br>
(q-&gt;r)∧q  =&gt;<br>
r</li>
</ol>
<h3 id="谓词逻辑">谓词逻辑:</h3>
<p>对命题再进行细分.命题是陈述句,再按照主语谓语分<br>
主语是个体,谓语是谓词</p>
<h4 id="基本概念-2">基本概念</h4>
<ol>
<li>个体:可以独立存在的客体,通常用a,b,c表示个体常元;用x,y,z表示个体变元</li>
<li>谓词:表示个体性质或者彼此之间联系的词,常用F,G,H..表示<br>
F(x)表示x具有性质F<br>
若F(x,y)表示x&gt;y则F(3,2)表示3大于2</li>
<li>量词:表示数量的词:<br>
全称量词:所有的⩝<br>
⩝x表示所有的x<br>
⩝xF(x)表示个体域里的所有x都有F(x)这个属性<br>
存在量词:存在∃<br>
∃xF(x)表示个体域中有x 有性质F</li>
</ol>
<h4 id="命题符号化">命题符号化:</h4>
<p><img src="https://wangyingying625.github.io/post-images/1615200644492.jpg" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615200651176.jpg" alt="" loading="lazy"></p>
<h4 id="一阶谓词逻辑公式">一阶谓词逻辑公式</h4>
<p>量词加在个体上,即任何X或者存在X<br>
<img src="https://wangyingying625.github.io/post-images/1615201094641.jpg" alt="" loading="lazy"><br>
如果逻辑公式A在任何解释下都为真,则它是永真式<br>
如果逻辑公式A在任何解释下都为真,则它是永假式<br>
如果逻辑公式A至少存在一个解释使其为真,则它是可满足式<br>
如果A&lt;-&gt;B是永真的,那么A与B等值,记为A&lt;=&gt;B</p>
<h5 id="基本等值式">基本等值式:</h5>
<ol>
<li>在有限个体域上消去量词:<br>
⩝xA(x)&lt;=&gt;A(x1)∧A(x2)∧A(x3)∧A(x4)∧A(x5)∧A(x6)...<br>
∃yB(y)&lt;=&gt;B(y1)∨B(y2)∨B(y3)∨B(y4)∨B(y5)∨B(y6)∨B(y7)...</li>
<li>量词否定等值式:<br>
¬ ⩝xA(x) &lt;=&gt; ∃x ¬ A(x)<br>
¬ ∃xB(x) &lt;=&gt; ⩝x ¬ B(x)</li>
<li>量词辖域收缩和扩张等值式:<br>
<img src="https://wangyingying625.github.io/post-images/1615201852622.png" alt="" loading="lazy"><br>
<img src="https://wangyingying625.github.io/post-images/1615202547661.png" alt="" loading="lazy"></li>
</ol>
<h4 id="前束范式">前束范式:</h4>
<p>若公式A满足:其一切量词都未被否定地处于公式的最前端且其辖域都延伸至公式的末端的谓词演算公式。<br>
可用基本等值式求前束范式<br>
<img src="https://wangyingying625.github.io/post-images/1615203809312.jpg" alt="" loading="lazy"></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库思维导图]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-si-wei-dao-tu/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-si-wei-dao-tu/">
        </link>
        <updated>2021-03-07T11:20:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据模型">数据模型</h2>
<figure data-type="image" tabindex="1"><img src="https://wangyingying625.github.io/post-images/1615116032962.png" alt="" loading="lazy"></figure>
<h2 id="数据库管理系统dbms">数据库管理系统DBMS</h2>
<figure data-type="image" tabindex="2"><img src="https://wangyingying625.github.io/post-images/1615129998237.png" alt="" loading="lazy"></figure>
<h2 id="关系数据库设计">关系数据库设计</h2>
<figure data-type="image" tabindex="3"><img src="https://wangyingying625.github.io/post-images/1615130073999.png" alt="" loading="lazy"></figure>
<h2 id="数据库安全性">数据库安全性</h2>
<figure data-type="image" tabindex="4"><img src="https://wangyingying625.github.io/post-images/1615182369785.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库问题]]></title>
        <id>https://wangyingying625.github.io/post/shu-ju-ku-wen-ti/</id>
        <link href="https://wangyingying625.github.io/post/shu-ju-ku-wen-ti/">
        </link>
        <updated>2021-03-07T09:16:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是数据库">什么是数据库?</h3>
<p>答:从本质上看,数据库就是信息的集合,这个集合能长期保存,可以共享并且有一定的数据结构</p>
<h3 id="什么是数据">什么是数据?</h3>
<p>答:数据是数据库中存储的基本对象.</p>
<h3 id="什么是数据库系统">什么是数据库系统:</h3>
<p>数据库系统是有数据库,数据,数据库管理系统和数据库管理员组成的系统</p>
<h3 id="什么是数据库管理系统dbms">什么是数据库管理系统(DBMS):</h3>
<h3 id="dbms有什么功能">DBMS有什么功能:</h3>
<ol>
<li>允许用户使用数据定义语言(DDL)建立新的数据库并定义它的模式(逻辑结构)</li>
<li>允许使用数据库操作语言(DML)和查询语言(QL)为用户提供查询和更新数据库的接口</li>
<li>控制多个用户的存取,一个用户对数据库的操作不影响另一个用户</li>
<li>支持大量数据的长期存储</li>
<li>在面对故障时能有恢复数据库的能力</li>
</ol>
<h3 id="dbms的功能要求dbms具备哪些结构">DBMS的功能要求DBMS具备哪些结构:</h3>
<ol>
<li>语法分析器:对用户提交的SQL语句进行语法分析</li>
<li>授权检查:检查尝试执行SQL语句的用户是否有权限执行它</li>
<li>查询分析和查询处理</li>
<li>访问管理:解决如何把表存储成磁盘中的文件流</li>
</ol>
<h3 id="什么是数据模型">什么是数据模型</h3>
<p>用来描述数据或者是信息的标记,一般由三部分组成</p>
<ol>
<li>数据结构</li>
<li>数据操作</li>
<li>完整性约束条件</li>
</ol>
<h3 id="关系数据模型有什么特点">关系数据模型有什么特点:</h3>
<p>关系数据模型把现实中的实体和实体间的联系都抽象成关系,即表.对关系操作的内容和结果都是表</p>
<h3 id="sql中的三种关系">SQL中的三种关系:</h3>
<ol>
<li>表:在物理磁盘中存储</li>
<li>视图:虚表,不在物理磁盘中存储其内容,只在数据库中存储其定义,需要内容时通过数据库中的表根据用户的需求映射</li>
<li>临时表:不在数据库中存储其内容也不在数据库中存储其定义,由SQL语句临时构造,在SQL语句执行完之后就被删除</li>
</ol>
<h3 id="如何建立一个关系型数据库">如何建立一个关系型数据库:</h3>
<p>建立数据库需要回答:存储什么信息;信息元素之间如何关联;需要有什么样的约束</p>
<ol>
<li>需求分析:考察数据库中可能涉及到的数据以及数据的特征,建立数据字典</li>
<li>概念设计:抽象实体,建立实体间联系,画出E-R图</li>
<li>逻辑设计:把E-R图转化为表</li>
<li>物理设计:设计数据库的存储结构及访问方法.考虑文件的存储形式和索引的建立.</li>
</ol>
<h3 id="什么是事务">什么是事务</h3>
<p>事务是对数据库操作的基本单位,本质上是一组SQL语句;<br>
事务具有原子性,原子性指的是SQL语句要么全部执行,要么一句也不执行<br>
事务具有一致性:数据库的一个状态经过一个事务运行到另外一个状态<br>
事务具有隔离性:并发执行的多个事务间互不干扰<br>
事务具有持久性:一个事务若成功执行,那它对数据库的影响就是永久的</p>
<p>引入事务的作用有:</p>
<ol>
<li>数据库异常时的恢复(根据数据库的更新策略不同采取的具体措施也不同,commit列表和active列表)</li>
<li>提供事务回滚,能让数据库从一个状态运行到另一个状态</li>
<li>多应用程序并发访问数据库时为这些程序提供隔离方法(加锁,两段锁协议能避免多用户并发访问数据库时发生冲突即事务可串行调度,加锁又可能让系统死锁,死锁的预防策略是一次封锁,等待死亡)</li>
</ol>
<h3 id="什么是死锁什么是活锁">什么是死锁,什么是活锁</h3>
<p>死锁:A申请B占有的排他锁;B也申请A占有的排他锁,导致两个事务都无法推进下去的情况<br>
活锁:A申请B占有的排他锁,B释放锁后给了C...A长期得不到锁</p>
<h3 id="预防死锁的策略">预防死锁的策略:</h3>
<ol>
<li>一次封锁发:任何事务执行前要求它获得所有需要的锁,如果不能获得全部需要的锁就不执行</li>
<li>等待死亡法:为每个事务增加一个时间戳属性,当事务A申请事务B的锁时,比较时间戳,若A比B年轻,事务A回滚,等待某一随机时间再用之前的时间戳申请;若A比B年老,事务A等待事务B释放锁</li>
</ol>
<h3 id="dbms查询优化的策略">DBMS查询优化的策略:</h3>
<ol>
<li>代数优化:DBMS对SQL语句形成的操作树进行处理:在查询结果不变的情况下尽量把一元操作往操作树的叶子部位压</li>
<li>操作优化:用最优的方式执行基本操作,最主要的是连接操作<br>
对连接操作的优化策略有:连接操作时每次从磁盘中取一个块的元组放进缓冲区,对被连接属性的比较在内存中计算,从而减少IO次数,减少连接操作耗时,本质上是用空间换时间.<br>
对连接属性添加B+树索引,有索引的表用做内循环,减少对连接属性的比较时间<br>
对连接属性按照hash映射存储,这样连接属性值相同的就在同一个hash块里,同样增加了对连接属性的比较时间</li>
</ol>
<h3 id="事务对数据库的更新策略有哪些">事务对数据库的更新策略有哪些</h3>
<ol>
<li>更改直接写进数据库:<br>
创建事务-&gt;将事务id写入active列表-&gt;把旧数据记入log-&gt;新数据把旧数据覆盖-&gt;事务id写入commit列表-&gt;事务id从active列表中删除<br>
重启动检查时,若发现事务id只在active列表中出现,那么对该事务进行undo(撤销)操作,回滚事务,然后从active列表删除其id;若事务id在active和commit列表都出现,说明该事务已经对数据库进行了修改,只是还没来得及从commit中删除其id就出了故障,那么只需从commit中删除其id;若只在commit中发现事务id证明事务已经顺利执行完,不做任何事.</li>
<li>更改在commit时写进数据库:<br>
创建事务-&gt;将事务id写入active列表-&gt;把新数据写入log-&gt;当数据写完需要commit时事务id写入commit-&gt;把log中数据写进数据库-&gt;事务id从active中删除<br>
重启检查时,若发现事务id只在active中,在active列表中删除其id<br>
若发现事务id在commit和active中,redo<br>
只在commit中找到,nothing to do</li>
<li>再新建一个进程,一旦磁盘空闲时,这个进程就开始搬数据<br>
创建事务-&gt;把其id写入active列表-&gt;把新数据写入log-&gt;同时如果磁盘空闲,同时把新数据写入数据库-&gt;事务id写入commit列表-&gt;commit事务前检查是否所有需要更爱的数据全部写入数据库-&gt;从active列表删除事务id<br>
重启检查时,若发现事务id只在active列表,undo并且删除active列表中的id<br>
若事务id同时出现在commit列表和active列表,redo<br>
事务id只在commit中,nothing to do</li>
</ol>
<h3 id="多事务并发时候可能会产生冲突这些冲突可能会造成什么影响">多事务并发时候可能会产生冲突,这些冲突可能会造成什么影响:</h3>
<ol>
<li>读写冲突--读脏数据:事务A改了数据1后事务B去读数据1,在事务B读完之后事务A执行异常回滚事务,导致事务B读取到了脏数据</li>
<li>读写冲突--不可重复读:事务A读完数据1后事务B对数据1进行了更改,事务A再次读数据1时和上次读到的不一致</li>
<li>写写冲突--丢失更新:事务A写了数据1还没来得及存回数据库时,事务B读取了数据1,也对其进行修改</li>
</ol>
<h3 id="如何解决这些冲突带来的影响如何让事务间的执行可串行化">如何解决这些冲突带来的影响(如何让事务间的执行可串行化):</h3>
<p>可串行化调度:计算机对并发执行事务的调度是随机的,在计算机中多个并发执行事务的结果是正确的当且仅当它的结果与按某一次序顺序执行时候的结果相同.<br>
加锁:</p>
<ol>
<li>X锁:X锁是排他锁,当对某一数据加了X锁之后其他事务无法再向该数据加锁</li>
<li>X+S锁:X锁排他,S锁不排他.当对某一数据加了S锁时,允许其他事务再对该数据加S锁,但不允许加X锁<br>
加了X锁的数据不允许其他事务对它加任何锁</li>
<li>X+S+U锁:U锁是考虑到对数据库的更改也分为读数据库和写数据库两步,当用户要修改数据库时先申请U锁,加了U锁的数据允许再加S锁,但不允许再加U和X锁</li>
</ol>
<h3 id="两段锁协议">两段锁协议:</h3>
<p>事务分为两个阶段:第一个阶段获得锁,在这个阶段事务可以申请获得任何数据上的任何锁<br>
第二个阶段是释放锁,在这个阶段事务不能再申请任何锁,只能释放锁<br>
若并发事务都遵守两段锁协议则对这些事务的任何并发调度都是可串行化的(是可串行化的策略,并不是避免死锁的)</p>
<h3 id="对数据库的安全性控制有哪些措施">对数据库的安全性控制有哪些措施:</h3>
<ol>
<li>用户身份鉴别:为用户设置密码</li>
<li>访问控制:对用户进行授权</li>
<li>数据加密:对敏感数据加密存储</li>
<li>审计追踪:对关键属性添加审计指令,这些数据就会被监视,当有操作在这些数据上时就会记录</li>
</ol>
<h3 id="为数据库定义约束的方法">为数据库定义约束的方法:</h3>
<ol>
<li>用断言定义: ASSERT ageRe on user:age&gt;0</li>
<li>定义表时用check子句:CREATE TABLE user(id INT,name VARCHAR(10),age INT)CHECK (age&gt;0)</li>
</ol>
<h3 id="常用的聚集函数">常用的聚集函数:</h3>
<ol>
<li>AVG</li>
<li>MIN</li>
<li>MAX</li>
<li>COUNT</li>
<li>SUM</li>
</ol>
<h3 id="group-by使用时的要求">GROUP BY使用时的要求:</h3>
<p>在select指定的字段要么要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中</p>
<h3 id="数据库设计中的各范式及其要求">数据库设计中的各范式及其要求:</h3>
<ol>
<li>1NF:强调列的原子性,即要求不能大表套小表</li>
<li>2NF:1NF+必须有主键+非主键的属性必须完全依赖于主键不能部分依赖</li>
<li>3NF:2NF+非主键必须直接依赖于主键不能传递依赖</li>
<li>BCNF:3NF+若属性A能决定属性B要求属性A必须是主键</li>
</ol>
]]></content>
    </entry>
</feed>